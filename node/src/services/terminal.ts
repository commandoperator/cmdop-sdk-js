/**
 * Terminal service for session management and I/O
 */

import { SessionError } from '@cmdop/core';
import type { TerminalStreamingServiceClient } from '../generated/service';
import type {
  CreateSessionResponse,
  CloseSessionResponse,
  GetSessionStatusResponse,
  ListSessionsResponse,
  SessionInfoItem,
} from '../generated/rpc_messages/session';
import type {
  SendInputResponse,
  SendResizeResponse,
  SendSignalResponse,
} from '../generated/rpc_messages/terminal';
import { SessionStatus, sessionStatusToJSON } from '../generated/common_types';

/**
 * Options for creating a terminal session
 */
export interface CreateSessionOptions {
  /** Session name for identification */
  name?: string;
  /** Shell to use (default: system shell) */
  shell?: string;
  /** Initial working directory */
  workingDir?: string;
  /** Terminal columns (default: 80) */
  cols?: number;
  /** Terminal rows (default: 24) */
  rows?: number;
  /** Environment variables */
  env?: Record<string, string>;
}

/**
 * Options for listing sessions
 */
export interface ListSessionsOptions {
  /** Filter by machine hostname */
  hostname?: string;
  /** Filter by status: "connected", "disconnected" */
  status?: string;
  /** Max sessions to return (default: 20) */
  limit?: number;
  /** Pagination offset */
  offset?: number;
}

/**
 * Session info returned from create/list operations
 */
export interface SessionInfo {
  sessionId: string;
  shell?: string;
  workingDir?: string;
  hostname?: string;
  machineName?: string;
  status: string;
  os?: string;
  agentVersion?: string;
  hasShell?: boolean;
  connectedAt?: Date;
}

/**
 * Session status response
 */
export interface SessionStatusInfo {
  exists: boolean;
  status: string;
  hostname: string;
  connectedAt?: Date;
  lastHeartbeat?: Date;
  commandsCount: number;
}

/**
 * Terminal service for managing terminal sessions
 */
export class TerminalService {
  constructor(private readonly client: TerminalStreamingServiceClient) {}

  /**
   * Create a new terminal session
   */
  async create(options: CreateSessionOptions = {}): Promise<SessionInfo> {
    const response = await this.client.createSession({
      userId: '', // Set by server from auth
      name: options.name ?? '',
      config: {
        sessionId: '', // Generated by agent
        shell: options.shell ?? '',
        workingDirectory: options.workingDir ?? '',
        env: options.env ?? {},
        size: {
          cols: options.cols ?? 80,
          rows: options.rows ?? 24,
          width: 0,
          height: 0,
        },
      },
    });

    if (!response.success) {
      throw new SessionError(response.error || 'Failed to create session');
    }

    return {
      sessionId: response.sessionId,
      shell: options.shell,
      workingDir: options.workingDir,
      status: 'connected',
    };
  }

  /**
   * Close a terminal session
   */
  async close(sessionId: string, options?: { reason?: string; force?: boolean }): Promise<void> {
    const response = await this.client.closeSession({
      sessionId,
      reason: options?.reason ?? '',
      force: options?.force ?? false,
    });

    if (!response.success) {
      throw new SessionError(response.error || 'Failed to close session', sessionId);
    }
  }

  /**
   * Get session status
   */
  async getStatus(sessionId: string): Promise<SessionStatusInfo> {
    const response = await this.client.getSessionStatus({ sessionId });

    return {
      exists: response.exists,
      status: sessionStatusToJSON(response.status),
      hostname: response.agentHostname,
      connectedAt: response.connectedAt ?? undefined,
      lastHeartbeat: response.lastHeartbeatAt ?? undefined,
      commandsCount: response.commandsCount,
    };
  }

  /**
   * List available sessions
   */
  async list(options: ListSessionsOptions = {}): Promise<{
    sessions: SessionInfo[];
    total: number;
    workspaceName: string;
  }> {
    const response = await this.client.listSessions({
      hostnameFilter: options.hostname ?? '',
      statusFilter: options.status ?? '',
      limit: options.limit ?? 20,
      offset: options.offset ?? 0,
    });

    if (response.error) {
      throw new SessionError(response.error);
    }

    return {
      sessions: response.sessions.map(mapSessionInfo),
      total: response.total,
      workspaceName: response.workspaceName,
    };
  }

  /**
   * List only active (connected) sessions
   */
  async listActive(options: Omit<ListSessionsOptions, 'status'> = {}): Promise<{
    sessions: SessionInfo[];
    total: number;
    workspaceName: string;
  }> {
    return this.list({ ...options, status: 'connected' });
  }

  /**
   * Send input to a terminal session
   */
  async sendInput(sessionId: string, data: string | Uint8Array): Promise<void> {
    const buffer = typeof data === 'string' ? Buffer.from(data) : Buffer.from(data);

    const response = await this.client.sendInput({
      sessionId,
      data: buffer,
    });

    if (!response.success) {
      throw new SessionError(response.error || 'Failed to send input', sessionId);
    }
  }

  /**
   * Resize a terminal session
   */
  async resize(sessionId: string, cols: number, rows: number): Promise<void> {
    const response = await this.client.sendResize({
      sessionId,
      cols,
      rows,
    });

    if (!response.success) {
      throw new SessionError(response.error || 'Failed to resize terminal', sessionId);
    }
  }

  /**
   * Send a signal to a terminal session
   */
  async signal(
    sessionId: string,
    signal: 'SIGINT' | 'SIGTERM' | 'SIGKILL' | number
  ): Promise<void> {
    const signalNum = typeof signal === 'number' ? signal : SIGNAL_MAP[signal];

    const response = await this.client.sendSignal({
      sessionId,
      signal: signalNum,
    });

    if (!response.success) {
      throw new SessionError(response.error || 'Failed to send signal', sessionId);
    }
  }

  /**
   * Get command history for a session
   */
  async getHistory(
    sessionId: string,
    options?: { limit?: number; offset?: number }
  ): Promise<{ commands: string[]; total: number }> {
    const response = await this.client.getHistory({
      sessionId,
      limit: options?.limit ?? 100,
      offset: options?.offset ?? 0,
    });

    return {
      commands: response.commands,
      total: response.total,
    };
  }
}

/**
 * Map proto session info to SDK session info
 */
function mapSessionInfo(item: SessionInfoItem): SessionInfo {
  return {
    sessionId: item.sessionId,
    hostname: item.machineHostname,
    machineName: item.machineName,
    status: item.status,
    os: item.os,
    agentVersion: item.agentVersion,
    hasShell: item.hasShell,
    shell: item.shell,
    workingDir: item.workingDirectory,
    connectedAt: item.connectedAt ?? undefined,
  };
}

/**
 * Signal name to number mapping
 */
const SIGNAL_MAP: Record<string, number> = {
  SIGINT: 2,
  SIGTERM: 15,
  SIGKILL: 9,
};
