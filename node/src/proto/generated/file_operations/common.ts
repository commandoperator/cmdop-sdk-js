// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: file_operations/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../google/protobuf/timestamp";

export const protobufPackage = "terminal";

export enum StreamFileType {
  STREAM_FILE_TYPE_UNSPECIFIED = 0,
  STREAM_FILE = 1,
  STREAM_DIRECTORY = 2,
  STREAM_SYMLINK = 3,
  UNRECOGNIZED = -1,
}

export function streamFileTypeFromJSON(object: any): StreamFileType {
  switch (object) {
    case 0:
    case "STREAM_FILE_TYPE_UNSPECIFIED":
      return StreamFileType.STREAM_FILE_TYPE_UNSPECIFIED;
    case 1:
    case "STREAM_FILE":
      return StreamFileType.STREAM_FILE;
    case 2:
    case "STREAM_DIRECTORY":
      return StreamFileType.STREAM_DIRECTORY;
    case 3:
    case "STREAM_SYMLINK":
      return StreamFileType.STREAM_SYMLINK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StreamFileType.UNRECOGNIZED;
  }
}

export function streamFileTypeToJSON(object: StreamFileType): string {
  switch (object) {
    case StreamFileType.STREAM_FILE_TYPE_UNSPECIFIED:
      return "STREAM_FILE_TYPE_UNSPECIFIED";
    case StreamFileType.STREAM_FILE:
      return "STREAM_FILE";
    case StreamFileType.STREAM_DIRECTORY:
      return "STREAM_DIRECTORY";
    case StreamFileType.STREAM_SYMLINK:
      return "STREAM_SYMLINK";
    case StreamFileType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Icon types for UI rendering (detected by backend based on path/name/OS) */
export enum FileIconType {
  ICON_UNSPECIFIED = 0,
  /** ICON_FILE - File types */
  ICON_FILE = 1,
  ICON_CODE = 2,
  ICON_TEXT = 3,
  ICON_IMAGE = 4,
  ICON_VIDEO = 5,
  ICON_AUDIO = 6,
  ICON_ARCHIVE = 7,
  ICON_DATA = 8,
  ICON_PDF = 9,
  /** ICON_FOLDER - Folder types */
  ICON_FOLDER = 10,
  ICON_FOLDER_HOME = 11,
  ICON_FOLDER_DESKTOP = 12,
  ICON_FOLDER_DOCUMENTS = 13,
  ICON_FOLDER_DOWNLOADS = 14,
  ICON_FOLDER_PICTURES = 15,
  ICON_FOLDER_MUSIC = 16,
  ICON_FOLDER_VIDEOS = 17,
  ICON_FOLDER_APPLICATIONS = 18,
  ICON_FOLDER_LIBRARY = 19,
  ICON_FOLDER_SYSTEM = 20,
  ICON_FOLDER_DRIVE = 21,
  ICON_FOLDER_CLOUD = 22,
  ICON_FOLDER_TRASH = 23,
  ICON_FOLDER_HIDDEN = 24,
  ICON_FOLDER_CODE = 25,
  ICON_FOLDER_SERVER = 26,
  ICON_FOLDER_DATABASE = 27,
  ICON_FOLDER_ARCHIVE = 28,
  UNRECOGNIZED = -1,
}

export function fileIconTypeFromJSON(object: any): FileIconType {
  switch (object) {
    case 0:
    case "ICON_UNSPECIFIED":
      return FileIconType.ICON_UNSPECIFIED;
    case 1:
    case "ICON_FILE":
      return FileIconType.ICON_FILE;
    case 2:
    case "ICON_CODE":
      return FileIconType.ICON_CODE;
    case 3:
    case "ICON_TEXT":
      return FileIconType.ICON_TEXT;
    case 4:
    case "ICON_IMAGE":
      return FileIconType.ICON_IMAGE;
    case 5:
    case "ICON_VIDEO":
      return FileIconType.ICON_VIDEO;
    case 6:
    case "ICON_AUDIO":
      return FileIconType.ICON_AUDIO;
    case 7:
    case "ICON_ARCHIVE":
      return FileIconType.ICON_ARCHIVE;
    case 8:
    case "ICON_DATA":
      return FileIconType.ICON_DATA;
    case 9:
    case "ICON_PDF":
      return FileIconType.ICON_PDF;
    case 10:
    case "ICON_FOLDER":
      return FileIconType.ICON_FOLDER;
    case 11:
    case "ICON_FOLDER_HOME":
      return FileIconType.ICON_FOLDER_HOME;
    case 12:
    case "ICON_FOLDER_DESKTOP":
      return FileIconType.ICON_FOLDER_DESKTOP;
    case 13:
    case "ICON_FOLDER_DOCUMENTS":
      return FileIconType.ICON_FOLDER_DOCUMENTS;
    case 14:
    case "ICON_FOLDER_DOWNLOADS":
      return FileIconType.ICON_FOLDER_DOWNLOADS;
    case 15:
    case "ICON_FOLDER_PICTURES":
      return FileIconType.ICON_FOLDER_PICTURES;
    case 16:
    case "ICON_FOLDER_MUSIC":
      return FileIconType.ICON_FOLDER_MUSIC;
    case 17:
    case "ICON_FOLDER_VIDEOS":
      return FileIconType.ICON_FOLDER_VIDEOS;
    case 18:
    case "ICON_FOLDER_APPLICATIONS":
      return FileIconType.ICON_FOLDER_APPLICATIONS;
    case 19:
    case "ICON_FOLDER_LIBRARY":
      return FileIconType.ICON_FOLDER_LIBRARY;
    case 20:
    case "ICON_FOLDER_SYSTEM":
      return FileIconType.ICON_FOLDER_SYSTEM;
    case 21:
    case "ICON_FOLDER_DRIVE":
      return FileIconType.ICON_FOLDER_DRIVE;
    case 22:
    case "ICON_FOLDER_CLOUD":
      return FileIconType.ICON_FOLDER_CLOUD;
    case 23:
    case "ICON_FOLDER_TRASH":
      return FileIconType.ICON_FOLDER_TRASH;
    case 24:
    case "ICON_FOLDER_HIDDEN":
      return FileIconType.ICON_FOLDER_HIDDEN;
    case 25:
    case "ICON_FOLDER_CODE":
      return FileIconType.ICON_FOLDER_CODE;
    case 26:
    case "ICON_FOLDER_SERVER":
      return FileIconType.ICON_FOLDER_SERVER;
    case 27:
    case "ICON_FOLDER_DATABASE":
      return FileIconType.ICON_FOLDER_DATABASE;
    case 28:
    case "ICON_FOLDER_ARCHIVE":
      return FileIconType.ICON_FOLDER_ARCHIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FileIconType.UNRECOGNIZED;
  }
}

export function fileIconTypeToJSON(object: FileIconType): string {
  switch (object) {
    case FileIconType.ICON_UNSPECIFIED:
      return "ICON_UNSPECIFIED";
    case FileIconType.ICON_FILE:
      return "ICON_FILE";
    case FileIconType.ICON_CODE:
      return "ICON_CODE";
    case FileIconType.ICON_TEXT:
      return "ICON_TEXT";
    case FileIconType.ICON_IMAGE:
      return "ICON_IMAGE";
    case FileIconType.ICON_VIDEO:
      return "ICON_VIDEO";
    case FileIconType.ICON_AUDIO:
      return "ICON_AUDIO";
    case FileIconType.ICON_ARCHIVE:
      return "ICON_ARCHIVE";
    case FileIconType.ICON_DATA:
      return "ICON_DATA";
    case FileIconType.ICON_PDF:
      return "ICON_PDF";
    case FileIconType.ICON_FOLDER:
      return "ICON_FOLDER";
    case FileIconType.ICON_FOLDER_HOME:
      return "ICON_FOLDER_HOME";
    case FileIconType.ICON_FOLDER_DESKTOP:
      return "ICON_FOLDER_DESKTOP";
    case FileIconType.ICON_FOLDER_DOCUMENTS:
      return "ICON_FOLDER_DOCUMENTS";
    case FileIconType.ICON_FOLDER_DOWNLOADS:
      return "ICON_FOLDER_DOWNLOADS";
    case FileIconType.ICON_FOLDER_PICTURES:
      return "ICON_FOLDER_PICTURES";
    case FileIconType.ICON_FOLDER_MUSIC:
      return "ICON_FOLDER_MUSIC";
    case FileIconType.ICON_FOLDER_VIDEOS:
      return "ICON_FOLDER_VIDEOS";
    case FileIconType.ICON_FOLDER_APPLICATIONS:
      return "ICON_FOLDER_APPLICATIONS";
    case FileIconType.ICON_FOLDER_LIBRARY:
      return "ICON_FOLDER_LIBRARY";
    case FileIconType.ICON_FOLDER_SYSTEM:
      return "ICON_FOLDER_SYSTEM";
    case FileIconType.ICON_FOLDER_DRIVE:
      return "ICON_FOLDER_DRIVE";
    case FileIconType.ICON_FOLDER_CLOUD:
      return "ICON_FOLDER_CLOUD";
    case FileIconType.ICON_FOLDER_TRASH:
      return "ICON_FOLDER_TRASH";
    case FileIconType.ICON_FOLDER_HIDDEN:
      return "ICON_FOLDER_HIDDEN";
    case FileIconType.ICON_FOLDER_CODE:
      return "ICON_FOLDER_CODE";
    case FileIconType.ICON_FOLDER_SERVER:
      return "ICON_FOLDER_SERVER";
    case FileIconType.ICON_FOLDER_DATABASE:
      return "ICON_FOLDER_DATABASE";
    case FileIconType.ICON_FOLDER_ARCHIVE:
      return "ICON_FOLDER_ARCHIVE";
    case FileIconType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Viewer types for file preview/editing (detected by backend)
 * Frontend maps these 1:1 to viewer components
 */
export enum ViewerType {
  VIEWER_UNKNOWN = 0,
  /** VIEWER_CODE - Monaco Editor (editable) */
  VIEWER_CODE = 1,
  /** VIEWER_TEXT - Plain text */
  VIEWER_TEXT = 2,
  /** VIEWER_IMAGE - Image viewer with zoom/pan */
  VIEWER_IMAGE = 3,
  /** VIEWER_VIDEO - Video player */
  VIEWER_VIDEO = 4,
  /** VIEWER_AUDIO - Audio player */
  VIEWER_AUDIO = 5,
  /** VIEWER_PDF - PDF viewer */
  VIEWER_PDF = 6,
  /** VIEWER_MARKDOWN - Markdown (editable) */
  VIEWER_MARKDOWN = 7,
  /** VIEWER_JSON - JSON tree viewer (editable) */
  VIEWER_JSON = 8,
  /** VIEWER_YAML - YAML viewer (editable) */
  VIEWER_YAML = 9,
  /** VIEWER_XML - XML viewer (editable) */
  VIEWER_XML = 10,
  /** VIEWER_ARCHIVE - Archive contents viewer */
  VIEWER_ARCHIVE = 11,
  /** VIEWER_HEX - Hex viewer for binary */
  VIEWER_HEX = 12,
  UNRECOGNIZED = -1,
}

export function viewerTypeFromJSON(object: any): ViewerType {
  switch (object) {
    case 0:
    case "VIEWER_UNKNOWN":
      return ViewerType.VIEWER_UNKNOWN;
    case 1:
    case "VIEWER_CODE":
      return ViewerType.VIEWER_CODE;
    case 2:
    case "VIEWER_TEXT":
      return ViewerType.VIEWER_TEXT;
    case 3:
    case "VIEWER_IMAGE":
      return ViewerType.VIEWER_IMAGE;
    case 4:
    case "VIEWER_VIDEO":
      return ViewerType.VIEWER_VIDEO;
    case 5:
    case "VIEWER_AUDIO":
      return ViewerType.VIEWER_AUDIO;
    case 6:
    case "VIEWER_PDF":
      return ViewerType.VIEWER_PDF;
    case 7:
    case "VIEWER_MARKDOWN":
      return ViewerType.VIEWER_MARKDOWN;
    case 8:
    case "VIEWER_JSON":
      return ViewerType.VIEWER_JSON;
    case 9:
    case "VIEWER_YAML":
      return ViewerType.VIEWER_YAML;
    case 10:
    case "VIEWER_XML":
      return ViewerType.VIEWER_XML;
    case 11:
    case "VIEWER_ARCHIVE":
      return ViewerType.VIEWER_ARCHIVE;
    case 12:
    case "VIEWER_HEX":
      return ViewerType.VIEWER_HEX;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ViewerType.UNRECOGNIZED;
  }
}

export function viewerTypeToJSON(object: ViewerType): string {
  switch (object) {
    case ViewerType.VIEWER_UNKNOWN:
      return "VIEWER_UNKNOWN";
    case ViewerType.VIEWER_CODE:
      return "VIEWER_CODE";
    case ViewerType.VIEWER_TEXT:
      return "VIEWER_TEXT";
    case ViewerType.VIEWER_IMAGE:
      return "VIEWER_IMAGE";
    case ViewerType.VIEWER_VIDEO:
      return "VIEWER_VIDEO";
    case ViewerType.VIEWER_AUDIO:
      return "VIEWER_AUDIO";
    case ViewerType.VIEWER_PDF:
      return "VIEWER_PDF";
    case ViewerType.VIEWER_MARKDOWN:
      return "VIEWER_MARKDOWN";
    case ViewerType.VIEWER_JSON:
      return "VIEWER_JSON";
    case ViewerType.VIEWER_YAML:
      return "VIEWER_YAML";
    case ViewerType.VIEWER_XML:
      return "VIEWER_XML";
    case ViewerType.VIEWER_ARCHIVE:
      return "VIEWER_ARCHIVE";
    case ViewerType.VIEWER_HEX:
      return "VIEWER_HEX";
    case ViewerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Load method for file content (added in v2.5.0)
 * Backend determines the best method based on file type and size
 */
export enum LoadMethod {
  /** LOAD_UNSPECIFIED - Let frontend decide (fallback) */
  LOAD_UNSPECIFIED = 0,
  /** LOAD_RPC - Load via Centrifugo RPC (small text/images) */
  LOAD_RPC = 1,
  /** LOAD_HTTP_STREAM - Use HTTP Range streaming (large video/audio) */
  LOAD_HTTP_STREAM = 2,
  /** LOAD_SKIP - Don't load content (directories, unsupported) */
  LOAD_SKIP = 3,
  /** LOAD_HTTP_TRANSCODE - Use HTTP streaming with real-time transcoding (v2.9.0) */
  LOAD_HTTP_TRANSCODE = 4,
  /** LOAD_HTTP_HLS - Use HLS adaptive streaming for long videos (v2.11.0) */
  LOAD_HTTP_HLS = 5,
  UNRECOGNIZED = -1,
}

export function loadMethodFromJSON(object: any): LoadMethod {
  switch (object) {
    case 0:
    case "LOAD_UNSPECIFIED":
      return LoadMethod.LOAD_UNSPECIFIED;
    case 1:
    case "LOAD_RPC":
      return LoadMethod.LOAD_RPC;
    case 2:
    case "LOAD_HTTP_STREAM":
      return LoadMethod.LOAD_HTTP_STREAM;
    case 3:
    case "LOAD_SKIP":
      return LoadMethod.LOAD_SKIP;
    case 4:
    case "LOAD_HTTP_TRANSCODE":
      return LoadMethod.LOAD_HTTP_TRANSCODE;
    case 5:
    case "LOAD_HTTP_HLS":
      return LoadMethod.LOAD_HTTP_HLS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoadMethod.UNRECOGNIZED;
  }
}

export function loadMethodToJSON(object: LoadMethod): string {
  switch (object) {
    case LoadMethod.LOAD_UNSPECIFIED:
      return "LOAD_UNSPECIFIED";
    case LoadMethod.LOAD_RPC:
      return "LOAD_RPC";
    case LoadMethod.LOAD_HTTP_STREAM:
      return "LOAD_HTTP_STREAM";
    case LoadMethod.LOAD_SKIP:
      return "LOAD_SKIP";
    case LoadMethod.LOAD_HTTP_TRANSCODE:
      return "LOAD_HTTP_TRANSCODE";
    case LoadMethod.LOAD_HTTP_HLS:
      return "LOAD_HTTP_HLS";
    case LoadMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * File visibility mode for smart filtering (added in v2.10.0)
 * Controls whether hidden files and system paths are shown based on context
 */
export enum FileVisibilityMode {
  /** VISIBILITY_AUTO - Auto-detect based on device type: servers show all, clients hide */
  VISIBILITY_AUTO = 0,
  /** VISIBILITY_USER - User-friendly mode: hide hidden files and system paths */
  VISIBILITY_USER = 1,
  /** VISIBILITY_ADMIN - Admin mode: show hidden files and system paths */
  VISIBILITY_ADMIN = 2,
  /** VISIBILITY_ALL - Show all files including hidden (respects security blocks for .ssh, .aws, etc.) */
  VISIBILITY_ALL = 3,
  UNRECOGNIZED = -1,
}

export function fileVisibilityModeFromJSON(object: any): FileVisibilityMode {
  switch (object) {
    case 0:
    case "VISIBILITY_AUTO":
      return FileVisibilityMode.VISIBILITY_AUTO;
    case 1:
    case "VISIBILITY_USER":
      return FileVisibilityMode.VISIBILITY_USER;
    case 2:
    case "VISIBILITY_ADMIN":
      return FileVisibilityMode.VISIBILITY_ADMIN;
    case 3:
    case "VISIBILITY_ALL":
      return FileVisibilityMode.VISIBILITY_ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FileVisibilityMode.UNRECOGNIZED;
  }
}

export function fileVisibilityModeToJSON(object: FileVisibilityMode): string {
  switch (object) {
    case FileVisibilityMode.VISIBILITY_AUTO:
      return "VISIBILITY_AUTO";
    case FileVisibilityMode.VISIBILITY_USER:
      return "VISIBILITY_USER";
    case FileVisibilityMode.VISIBILITY_ADMIN:
      return "VISIBILITY_ADMIN";
    case FileVisibilityMode.VISIBILITY_ALL:
      return "VISIBILITY_ALL";
    case FileVisibilityMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Media metadata for audio/video files (added in v2.8.0)
 * Extracted from MP3/FLAC/M4A/OGG/MP4/MKV/WebM files
 */
export interface MediaMetadata {
  /** Common properties */
  durationSeconds: number;
  /** Bitrate in kbps */
  bitrateKbps: number;
  /** Audio properties */
  sampleRateHz: number;
  /** 1=mono, 2=stereo, 6=5.1 */
  audioChannels: number;
  /** mp3, aac, flac, vorbis, opus */
  audioCodec: string;
  /** Video properties */
  width: number;
  /** Video height in pixels */
  height: number;
  /** FPS (29.97, 60.0, etc.) */
  frameRate: number;
  /** h264, h265, vp9, av1 */
  videoCodec: string;
  /** Music tags (ID3, Vorbis Comments, MP4 atoms) */
  title: string;
  artist: string;
  album: string;
  albumArtist: string;
  genre: string;
  year: number;
  trackNumber: number;
  discNumber: number;
  comment: string;
  composer: string;
  /** Cover art (embedded album art) */
  coverArt: Buffer;
  /** image/jpeg, image/png */
  coverArtMimeType: string;
  /** Format info */
  containerFormat: string;
  /** Contains video stream */
  hasVideo: boolean;
  /** Contains audio stream */
  hasAudio: boolean;
  /** Transcoding info (added in v2.9.0) */
  needsTranscode: boolean;
  /** Reason for transcoding (e.g., "unsupported container: avi") */
  transcodeReason: string;
}

export interface StreamFileEntry {
  name: string;
  path: string;
  type: StreamFileType;
  size: string;
  /** e.g., "rwxr-xr-x" */
  permissions: string;
  owner: string;
  modifiedAt:
    | Date
    | undefined;
  /** Hidden file (dot prefix on Unix, hidden attr on Windows) */
  isHidden: boolean;
  isReadable: boolean;
  isWritable: boolean;
  mimeType: string;
  symlinkTarget: string;
  /** Icon type for UI rendering (added in v2.1.0) */
  iconType: FileIconType;
  /** System/protected path (OS-specific, added in v2.2.0) */
  isSystem: boolean;
  /** Viewer type for file preview (added in v2.3.0) */
  viewerType: ViewerType;
  /** Recommended content load method (added in v2.5.0) */
  loadMethod: LoadMethod;
  /** Audio/video metadata (added in v2.8.0) */
  mediaMetadata: MediaMetadata | undefined;
}

function createBaseMediaMetadata(): MediaMetadata {
  return {
    durationSeconds: 0,
    bitrateKbps: 0,
    sampleRateHz: 0,
    audioChannels: 0,
    audioCodec: "",
    width: 0,
    height: 0,
    frameRate: 0,
    videoCodec: "",
    title: "",
    artist: "",
    album: "",
    albumArtist: "",
    genre: "",
    year: 0,
    trackNumber: 0,
    discNumber: 0,
    comment: "",
    composer: "",
    coverArt: Buffer.alloc(0),
    coverArtMimeType: "",
    containerFormat: "",
    hasVideo: false,
    hasAudio: false,
    needsTranscode: false,
    transcodeReason: "",
  };
}

export const MediaMetadata: MessageFns<MediaMetadata> = {
  encode(message: MediaMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.durationSeconds !== 0) {
      writer.uint32(8).int32(message.durationSeconds);
    }
    if (message.bitrateKbps !== 0) {
      writer.uint32(16).int32(message.bitrateKbps);
    }
    if (message.sampleRateHz !== 0) {
      writer.uint32(24).int32(message.sampleRateHz);
    }
    if (message.audioChannels !== 0) {
      writer.uint32(32).int32(message.audioChannels);
    }
    if (message.audioCodec !== "") {
      writer.uint32(42).string(message.audioCodec);
    }
    if (message.width !== 0) {
      writer.uint32(48).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(56).int32(message.height);
    }
    if (message.frameRate !== 0) {
      writer.uint32(69).float(message.frameRate);
    }
    if (message.videoCodec !== "") {
      writer.uint32(74).string(message.videoCodec);
    }
    if (message.title !== "") {
      writer.uint32(82).string(message.title);
    }
    if (message.artist !== "") {
      writer.uint32(90).string(message.artist);
    }
    if (message.album !== "") {
      writer.uint32(98).string(message.album);
    }
    if (message.albumArtist !== "") {
      writer.uint32(106).string(message.albumArtist);
    }
    if (message.genre !== "") {
      writer.uint32(114).string(message.genre);
    }
    if (message.year !== 0) {
      writer.uint32(120).int32(message.year);
    }
    if (message.trackNumber !== 0) {
      writer.uint32(128).int32(message.trackNumber);
    }
    if (message.discNumber !== 0) {
      writer.uint32(136).int32(message.discNumber);
    }
    if (message.comment !== "") {
      writer.uint32(146).string(message.comment);
    }
    if (message.composer !== "") {
      writer.uint32(154).string(message.composer);
    }
    if (message.coverArt.length !== 0) {
      writer.uint32(162).bytes(message.coverArt);
    }
    if (message.coverArtMimeType !== "") {
      writer.uint32(170).string(message.coverArtMimeType);
    }
    if (message.containerFormat !== "") {
      writer.uint32(178).string(message.containerFormat);
    }
    if (message.hasVideo !== false) {
      writer.uint32(184).bool(message.hasVideo);
    }
    if (message.hasAudio !== false) {
      writer.uint32(192).bool(message.hasAudio);
    }
    if (message.needsTranscode !== false) {
      writer.uint32(200).bool(message.needsTranscode);
    }
    if (message.transcodeReason !== "") {
      writer.uint32(210).string(message.transcodeReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MediaMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMediaMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.durationSeconds = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bitrateKbps = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sampleRateHz = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.audioChannels = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.audioCodec = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.frameRate = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.videoCodec = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.artist = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.album = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.albumArtist = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.genre = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.year = reader.int32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.trackNumber = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.discNumber = reader.int32();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.composer = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.coverArt = Buffer.from(reader.bytes());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.coverArtMimeType = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.containerFormat = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.hasVideo = reader.bool();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.hasAudio = reader.bool();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.needsTranscode = reader.bool();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.transcodeReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MediaMetadata {
    return {
      durationSeconds: isSet(object.durationSeconds)
        ? globalThis.Number(object.durationSeconds)
        : isSet(object.duration_seconds)
        ? globalThis.Number(object.duration_seconds)
        : 0,
      bitrateKbps: isSet(object.bitrateKbps)
        ? globalThis.Number(object.bitrateKbps)
        : isSet(object.bitrate_kbps)
        ? globalThis.Number(object.bitrate_kbps)
        : 0,
      sampleRateHz: isSet(object.sampleRateHz)
        ? globalThis.Number(object.sampleRateHz)
        : isSet(object.sample_rate_hz)
        ? globalThis.Number(object.sample_rate_hz)
        : 0,
      audioChannels: isSet(object.audioChannels)
        ? globalThis.Number(object.audioChannels)
        : isSet(object.audio_channels)
        ? globalThis.Number(object.audio_channels)
        : 0,
      audioCodec: isSet(object.audioCodec)
        ? globalThis.String(object.audioCodec)
        : isSet(object.audio_codec)
        ? globalThis.String(object.audio_codec)
        : "",
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      frameRate: isSet(object.frameRate)
        ? globalThis.Number(object.frameRate)
        : isSet(object.frame_rate)
        ? globalThis.Number(object.frame_rate)
        : 0,
      videoCodec: isSet(object.videoCodec)
        ? globalThis.String(object.videoCodec)
        : isSet(object.video_codec)
        ? globalThis.String(object.video_codec)
        : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      artist: isSet(object.artist) ? globalThis.String(object.artist) : "",
      album: isSet(object.album) ? globalThis.String(object.album) : "",
      albumArtist: isSet(object.albumArtist)
        ? globalThis.String(object.albumArtist)
        : isSet(object.album_artist)
        ? globalThis.String(object.album_artist)
        : "",
      genre: isSet(object.genre) ? globalThis.String(object.genre) : "",
      year: isSet(object.year) ? globalThis.Number(object.year) : 0,
      trackNumber: isSet(object.trackNumber)
        ? globalThis.Number(object.trackNumber)
        : isSet(object.track_number)
        ? globalThis.Number(object.track_number)
        : 0,
      discNumber: isSet(object.discNumber)
        ? globalThis.Number(object.discNumber)
        : isSet(object.disc_number)
        ? globalThis.Number(object.disc_number)
        : 0,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      composer: isSet(object.composer) ? globalThis.String(object.composer) : "",
      coverArt: isSet(object.coverArt)
        ? Buffer.from(bytesFromBase64(object.coverArt))
        : isSet(object.cover_art)
        ? Buffer.from(bytesFromBase64(object.cover_art))
        : Buffer.alloc(0),
      coverArtMimeType: isSet(object.coverArtMimeType)
        ? globalThis.String(object.coverArtMimeType)
        : isSet(object.cover_art_mime_type)
        ? globalThis.String(object.cover_art_mime_type)
        : "",
      containerFormat: isSet(object.containerFormat)
        ? globalThis.String(object.containerFormat)
        : isSet(object.container_format)
        ? globalThis.String(object.container_format)
        : "",
      hasVideo: isSet(object.hasVideo)
        ? globalThis.Boolean(object.hasVideo)
        : isSet(object.has_video)
        ? globalThis.Boolean(object.has_video)
        : false,
      hasAudio: isSet(object.hasAudio)
        ? globalThis.Boolean(object.hasAudio)
        : isSet(object.has_audio)
        ? globalThis.Boolean(object.has_audio)
        : false,
      needsTranscode: isSet(object.needsTranscode)
        ? globalThis.Boolean(object.needsTranscode)
        : isSet(object.needs_transcode)
        ? globalThis.Boolean(object.needs_transcode)
        : false,
      transcodeReason: isSet(object.transcodeReason)
        ? globalThis.String(object.transcodeReason)
        : isSet(object.transcode_reason)
        ? globalThis.String(object.transcode_reason)
        : "",
    };
  },

  toJSON(message: MediaMetadata): unknown {
    const obj: any = {};
    if (message.durationSeconds !== 0) {
      obj.durationSeconds = Math.round(message.durationSeconds);
    }
    if (message.bitrateKbps !== 0) {
      obj.bitrateKbps = Math.round(message.bitrateKbps);
    }
    if (message.sampleRateHz !== 0) {
      obj.sampleRateHz = Math.round(message.sampleRateHz);
    }
    if (message.audioChannels !== 0) {
      obj.audioChannels = Math.round(message.audioChannels);
    }
    if (message.audioCodec !== "") {
      obj.audioCodec = message.audioCodec;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.frameRate !== 0) {
      obj.frameRate = message.frameRate;
    }
    if (message.videoCodec !== "") {
      obj.videoCodec = message.videoCodec;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.artist !== "") {
      obj.artist = message.artist;
    }
    if (message.album !== "") {
      obj.album = message.album;
    }
    if (message.albumArtist !== "") {
      obj.albumArtist = message.albumArtist;
    }
    if (message.genre !== "") {
      obj.genre = message.genre;
    }
    if (message.year !== 0) {
      obj.year = Math.round(message.year);
    }
    if (message.trackNumber !== 0) {
      obj.trackNumber = Math.round(message.trackNumber);
    }
    if (message.discNumber !== 0) {
      obj.discNumber = Math.round(message.discNumber);
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.composer !== "") {
      obj.composer = message.composer;
    }
    if (message.coverArt.length !== 0) {
      obj.coverArt = base64FromBytes(message.coverArt);
    }
    if (message.coverArtMimeType !== "") {
      obj.coverArtMimeType = message.coverArtMimeType;
    }
    if (message.containerFormat !== "") {
      obj.containerFormat = message.containerFormat;
    }
    if (message.hasVideo !== false) {
      obj.hasVideo = message.hasVideo;
    }
    if (message.hasAudio !== false) {
      obj.hasAudio = message.hasAudio;
    }
    if (message.needsTranscode !== false) {
      obj.needsTranscode = message.needsTranscode;
    }
    if (message.transcodeReason !== "") {
      obj.transcodeReason = message.transcodeReason;
    }
    return obj;
  },

  create(base?: DeepPartial<MediaMetadata>): MediaMetadata {
    return MediaMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MediaMetadata>): MediaMetadata {
    const message = createBaseMediaMetadata();
    message.durationSeconds = object.durationSeconds ?? 0;
    message.bitrateKbps = object.bitrateKbps ?? 0;
    message.sampleRateHz = object.sampleRateHz ?? 0;
    message.audioChannels = object.audioChannels ?? 0;
    message.audioCodec = object.audioCodec ?? "";
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.frameRate = object.frameRate ?? 0;
    message.videoCodec = object.videoCodec ?? "";
    message.title = object.title ?? "";
    message.artist = object.artist ?? "";
    message.album = object.album ?? "";
    message.albumArtist = object.albumArtist ?? "";
    message.genre = object.genre ?? "";
    message.year = object.year ?? 0;
    message.trackNumber = object.trackNumber ?? 0;
    message.discNumber = object.discNumber ?? 0;
    message.comment = object.comment ?? "";
    message.composer = object.composer ?? "";
    message.coverArt = object.coverArt ?? Buffer.alloc(0);
    message.coverArtMimeType = object.coverArtMimeType ?? "";
    message.containerFormat = object.containerFormat ?? "";
    message.hasVideo = object.hasVideo ?? false;
    message.hasAudio = object.hasAudio ?? false;
    message.needsTranscode = object.needsTranscode ?? false;
    message.transcodeReason = object.transcodeReason ?? "";
    return message;
  },
};

function createBaseStreamFileEntry(): StreamFileEntry {
  return {
    name: "",
    path: "",
    type: 0,
    size: "0",
    permissions: "",
    owner: "",
    modifiedAt: undefined,
    isHidden: false,
    isReadable: false,
    isWritable: false,
    mimeType: "",
    symlinkTarget: "",
    iconType: 0,
    isSystem: false,
    viewerType: 0,
    loadMethod: 0,
    mediaMetadata: undefined,
  };
}

export const StreamFileEntry: MessageFns<StreamFileEntry> = {
  encode(message: StreamFileEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.size !== "0") {
      writer.uint32(32).int64(message.size);
    }
    if (message.permissions !== "") {
      writer.uint32(42).string(message.permissions);
    }
    if (message.owner !== "") {
      writer.uint32(50).string(message.owner);
    }
    if (message.modifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.modifiedAt), writer.uint32(58).fork()).join();
    }
    if (message.isHidden !== false) {
      writer.uint32(64).bool(message.isHidden);
    }
    if (message.isReadable !== false) {
      writer.uint32(72).bool(message.isReadable);
    }
    if (message.isWritable !== false) {
      writer.uint32(80).bool(message.isWritable);
    }
    if (message.mimeType !== "") {
      writer.uint32(90).string(message.mimeType);
    }
    if (message.symlinkTarget !== "") {
      writer.uint32(98).string(message.symlinkTarget);
    }
    if (message.iconType !== 0) {
      writer.uint32(104).int32(message.iconType);
    }
    if (message.isSystem !== false) {
      writer.uint32(112).bool(message.isSystem);
    }
    if (message.viewerType !== 0) {
      writer.uint32(120).int32(message.viewerType);
    }
    if (message.loadMethod !== 0) {
      writer.uint32(128).int32(message.loadMethod);
    }
    if (message.mediaMetadata !== undefined) {
      MediaMetadata.encode(message.mediaMetadata, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamFileEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamFileEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.size = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.permissions = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.modifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isHidden = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isReadable = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isWritable = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.symlinkTarget = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.iconType = reader.int32() as any;
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.isSystem = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.viewerType = reader.int32() as any;
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.loadMethod = reader.int32() as any;
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.mediaMetadata = MediaMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamFileEntry {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      type: isSet(object.type) ? streamFileTypeFromJSON(object.type) : 0,
      size: isSet(object.size) ? globalThis.String(object.size) : "0",
      permissions: isSet(object.permissions) ? globalThis.String(object.permissions) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      modifiedAt: isSet(object.modifiedAt)
        ? fromJsonTimestamp(object.modifiedAt)
        : isSet(object.modified_at)
        ? fromJsonTimestamp(object.modified_at)
        : undefined,
      isHidden: isSet(object.isHidden)
        ? globalThis.Boolean(object.isHidden)
        : isSet(object.is_hidden)
        ? globalThis.Boolean(object.is_hidden)
        : false,
      isReadable: isSet(object.isReadable)
        ? globalThis.Boolean(object.isReadable)
        : isSet(object.is_readable)
        ? globalThis.Boolean(object.is_readable)
        : false,
      isWritable: isSet(object.isWritable)
        ? globalThis.Boolean(object.isWritable)
        : isSet(object.is_writable)
        ? globalThis.Boolean(object.is_writable)
        : false,
      mimeType: isSet(object.mimeType)
        ? globalThis.String(object.mimeType)
        : isSet(object.mime_type)
        ? globalThis.String(object.mime_type)
        : "",
      symlinkTarget: isSet(object.symlinkTarget)
        ? globalThis.String(object.symlinkTarget)
        : isSet(object.symlink_target)
        ? globalThis.String(object.symlink_target)
        : "",
      iconType: isSet(object.iconType)
        ? fileIconTypeFromJSON(object.iconType)
        : isSet(object.icon_type)
        ? fileIconTypeFromJSON(object.icon_type)
        : 0,
      isSystem: isSet(object.isSystem)
        ? globalThis.Boolean(object.isSystem)
        : isSet(object.is_system)
        ? globalThis.Boolean(object.is_system)
        : false,
      viewerType: isSet(object.viewerType)
        ? viewerTypeFromJSON(object.viewerType)
        : isSet(object.viewer_type)
        ? viewerTypeFromJSON(object.viewer_type)
        : 0,
      loadMethod: isSet(object.loadMethod)
        ? loadMethodFromJSON(object.loadMethod)
        : isSet(object.load_method)
        ? loadMethodFromJSON(object.load_method)
        : 0,
      mediaMetadata: isSet(object.mediaMetadata)
        ? MediaMetadata.fromJSON(object.mediaMetadata)
        : isSet(object.media_metadata)
        ? MediaMetadata.fromJSON(object.media_metadata)
        : undefined,
    };
  },

  toJSON(message: StreamFileEntry): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.type !== 0) {
      obj.type = streamFileTypeToJSON(message.type);
    }
    if (message.size !== "0") {
      obj.size = message.size;
    }
    if (message.permissions !== "") {
      obj.permissions = message.permissions;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.modifiedAt !== undefined) {
      obj.modifiedAt = message.modifiedAt.toISOString();
    }
    if (message.isHidden !== false) {
      obj.isHidden = message.isHidden;
    }
    if (message.isReadable !== false) {
      obj.isReadable = message.isReadable;
    }
    if (message.isWritable !== false) {
      obj.isWritable = message.isWritable;
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.symlinkTarget !== "") {
      obj.symlinkTarget = message.symlinkTarget;
    }
    if (message.iconType !== 0) {
      obj.iconType = fileIconTypeToJSON(message.iconType);
    }
    if (message.isSystem !== false) {
      obj.isSystem = message.isSystem;
    }
    if (message.viewerType !== 0) {
      obj.viewerType = viewerTypeToJSON(message.viewerType);
    }
    if (message.loadMethod !== 0) {
      obj.loadMethod = loadMethodToJSON(message.loadMethod);
    }
    if (message.mediaMetadata !== undefined) {
      obj.mediaMetadata = MediaMetadata.toJSON(message.mediaMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamFileEntry>): StreamFileEntry {
    return StreamFileEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamFileEntry>): StreamFileEntry {
    const message = createBaseStreamFileEntry();
    message.name = object.name ?? "";
    message.path = object.path ?? "";
    message.type = object.type ?? 0;
    message.size = object.size ?? "0";
    message.permissions = object.permissions ?? "";
    message.owner = object.owner ?? "";
    message.modifiedAt = object.modifiedAt ?? undefined;
    message.isHidden = object.isHidden ?? false;
    message.isReadable = object.isReadable ?? false;
    message.isWritable = object.isWritable ?? false;
    message.mimeType = object.mimeType ?? "";
    message.symlinkTarget = object.symlinkTarget ?? "";
    message.iconType = object.iconType ?? 0;
    message.isSystem = object.isSystem ?? false;
    message.viewerType = object.viewerType ?? 0;
    message.loadMethod = object.loadMethod ?? 0;
    message.mediaMetadata = (object.mediaMetadata !== undefined && object.mediaMetadata !== null)
      ? MediaMetadata.fromPartial(object.mediaMetadata)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
