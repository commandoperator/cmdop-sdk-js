// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.4
//   protoc               unknown
// source: agent_messages.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { SessionStatus, sessionStatusFromJSON, sessionStatusToJSON, SystemMetrics, TerminalSize } from "./common_types";
import { FileOperationResult } from "./file_operations/requests";
import { Timestamp } from "./google/protobuf/timestamp";
import { TunnelClosed, TunnelCreated, TunnelData, TunnelError } from "./tunnel";

export const protobufPackage = "terminal";

/** Permission access status enum */
export enum PermissionAccessStatus {
  /** PERMISSION_GRANTED - Access is granted */
  PERMISSION_GRANTED = 0,
  /** PERMISSION_DENIED - Access is denied (TCC, UAC, etc.) */
  PERMISSION_DENIED = 1,
  /** PERMISSION_PENDING - OS is showing permission dialog */
  PERMISSION_PENDING = 2,
  /** PERMISSION_UNKNOWN - Status could not be determined */
  PERMISSION_UNKNOWN = 3,
  UNRECOGNIZED = -1,
}

export function permissionAccessStatusFromJSON(object: any): PermissionAccessStatus {
  switch (object) {
    case 0:
    case "PERMISSION_GRANTED":
      return PermissionAccessStatus.PERMISSION_GRANTED;
    case 1:
    case "PERMISSION_DENIED":
      return PermissionAccessStatus.PERMISSION_DENIED;
    case 2:
    case "PERMISSION_PENDING":
      return PermissionAccessStatus.PERMISSION_PENDING;
    case 3:
    case "PERMISSION_UNKNOWN":
      return PermissionAccessStatus.PERMISSION_UNKNOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PermissionAccessStatus.UNRECOGNIZED;
  }
}

export function permissionAccessStatusToJSON(object: PermissionAccessStatus): string {
  switch (object) {
    case PermissionAccessStatus.PERMISSION_GRANTED:
      return "PERMISSION_GRANTED";
    case PermissionAccessStatus.PERMISSION_DENIED:
      return "PERMISSION_DENIED";
    case PermissionAccessStatus.PERMISSION_PENDING:
      return "PERMISSION_PENDING";
    case PermissionAccessStatus.PERMISSION_UNKNOWN:
      return "PERMISSION_UNKNOWN";
    case PermissionAccessStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Agent event types */
export enum AgentEventType {
  /** AGENT_EVENT_TOKEN - Token generated (payload: token string) */
  AGENT_EVENT_TOKEN = 0,
  /** AGENT_EVENT_TOOL_START - Tool execution started */
  AGENT_EVENT_TOOL_START = 1,
  /** AGENT_EVENT_TOOL_END - Tool execution completed */
  AGENT_EVENT_TOOL_END = 2,
  /** AGENT_EVENT_THINKING - Agent is thinking/processing */
  AGENT_EVENT_THINKING = 3,
  /** AGENT_EVENT_ERROR - Error occurred */
  AGENT_EVENT_ERROR = 4,
  /** AGENT_EVENT_HANDOFF - Handoff to another agent */
  AGENT_EVENT_HANDOFF = 5,
  /** AGENT_EVENT_CANCELLED - Agent run cancelled (v2.15.0) */
  AGENT_EVENT_CANCELLED = 6,
  /** AGENT_EVENT_BROWSER_NAVIGATE - Browser-specific events (v2.13.0) */
  AGENT_EVENT_BROWSER_NAVIGATE = 10,
  /** AGENT_EVENT_BROWSER_CLICK - Element clicked */
  AGENT_EVENT_BROWSER_CLICK = 11,
  /** AGENT_EVENT_BROWSER_TYPE - Text typed */
  AGENT_EVENT_BROWSER_TYPE = 12,
  /** AGENT_EVENT_BROWSER_STATE - Page state captured */
  AGENT_EVENT_BROWSER_STATE = 13,
  /** AGENT_EVENT_BROWSER_SCREENSHOT - Screenshot taken */
  AGENT_EVENT_BROWSER_SCREENSHOT = 14,
  /** AGENT_EVENT_BROWSER_ERROR - Browser error occurred */
  AGENT_EVENT_BROWSER_ERROR = 15,
  /** AGENT_EVENT_BROWSER_DETECTION - Bot detection suspected */
  AGENT_EVENT_BROWSER_DETECTION = 16,
  /** AGENT_EVENT_BROWSER_ESCALATION - Stealth escalation triggered */
  AGENT_EVENT_BROWSER_ESCALATION = 17,
  /** AGENT_EVENT_BROWSER_SESSION - Session start/end */
  AGENT_EVENT_BROWSER_SESSION = 18,
  UNRECOGNIZED = -1,
}

export function agentEventTypeFromJSON(object: any): AgentEventType {
  switch (object) {
    case 0:
    case "AGENT_EVENT_TOKEN":
      return AgentEventType.AGENT_EVENT_TOKEN;
    case 1:
    case "AGENT_EVENT_TOOL_START":
      return AgentEventType.AGENT_EVENT_TOOL_START;
    case 2:
    case "AGENT_EVENT_TOOL_END":
      return AgentEventType.AGENT_EVENT_TOOL_END;
    case 3:
    case "AGENT_EVENT_THINKING":
      return AgentEventType.AGENT_EVENT_THINKING;
    case 4:
    case "AGENT_EVENT_ERROR":
      return AgentEventType.AGENT_EVENT_ERROR;
    case 5:
    case "AGENT_EVENT_HANDOFF":
      return AgentEventType.AGENT_EVENT_HANDOFF;
    case 6:
    case "AGENT_EVENT_CANCELLED":
      return AgentEventType.AGENT_EVENT_CANCELLED;
    case 10:
    case "AGENT_EVENT_BROWSER_NAVIGATE":
      return AgentEventType.AGENT_EVENT_BROWSER_NAVIGATE;
    case 11:
    case "AGENT_EVENT_BROWSER_CLICK":
      return AgentEventType.AGENT_EVENT_BROWSER_CLICK;
    case 12:
    case "AGENT_EVENT_BROWSER_TYPE":
      return AgentEventType.AGENT_EVENT_BROWSER_TYPE;
    case 13:
    case "AGENT_EVENT_BROWSER_STATE":
      return AgentEventType.AGENT_EVENT_BROWSER_STATE;
    case 14:
    case "AGENT_EVENT_BROWSER_SCREENSHOT":
      return AgentEventType.AGENT_EVENT_BROWSER_SCREENSHOT;
    case 15:
    case "AGENT_EVENT_BROWSER_ERROR":
      return AgentEventType.AGENT_EVENT_BROWSER_ERROR;
    case 16:
    case "AGENT_EVENT_BROWSER_DETECTION":
      return AgentEventType.AGENT_EVENT_BROWSER_DETECTION;
    case 17:
    case "AGENT_EVENT_BROWSER_ESCALATION":
      return AgentEventType.AGENT_EVENT_BROWSER_ESCALATION;
    case 18:
    case "AGENT_EVENT_BROWSER_SESSION":
      return AgentEventType.AGENT_EVENT_BROWSER_SESSION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AgentEventType.UNRECOGNIZED;
  }
}

export function agentEventTypeToJSON(object: AgentEventType): string {
  switch (object) {
    case AgentEventType.AGENT_EVENT_TOKEN:
      return "AGENT_EVENT_TOKEN";
    case AgentEventType.AGENT_EVENT_TOOL_START:
      return "AGENT_EVENT_TOOL_START";
    case AgentEventType.AGENT_EVENT_TOOL_END:
      return "AGENT_EVENT_TOOL_END";
    case AgentEventType.AGENT_EVENT_THINKING:
      return "AGENT_EVENT_THINKING";
    case AgentEventType.AGENT_EVENT_ERROR:
      return "AGENT_EVENT_ERROR";
    case AgentEventType.AGENT_EVENT_HANDOFF:
      return "AGENT_EVENT_HANDOFF";
    case AgentEventType.AGENT_EVENT_CANCELLED:
      return "AGENT_EVENT_CANCELLED";
    case AgentEventType.AGENT_EVENT_BROWSER_NAVIGATE:
      return "AGENT_EVENT_BROWSER_NAVIGATE";
    case AgentEventType.AGENT_EVENT_BROWSER_CLICK:
      return "AGENT_EVENT_BROWSER_CLICK";
    case AgentEventType.AGENT_EVENT_BROWSER_TYPE:
      return "AGENT_EVENT_BROWSER_TYPE";
    case AgentEventType.AGENT_EVENT_BROWSER_STATE:
      return "AGENT_EVENT_BROWSER_STATE";
    case AgentEventType.AGENT_EVENT_BROWSER_SCREENSHOT:
      return "AGENT_EVENT_BROWSER_SCREENSHOT";
    case AgentEventType.AGENT_EVENT_BROWSER_ERROR:
      return "AGENT_EVENT_BROWSER_ERROR";
    case AgentEventType.AGENT_EVENT_BROWSER_DETECTION:
      return "AGENT_EVENT_BROWSER_DETECTION";
    case AgentEventType.AGENT_EVENT_BROWSER_ESCALATION:
      return "AGENT_EVENT_BROWSER_ESCALATION";
    case AgentEventType.AGENT_EVENT_BROWSER_SESSION:
      return "AGENT_EVENT_BROWSER_SESSION";
    case AgentEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message from Agent to Django */
export interface AgentMessage {
  /** Session UUID */
  sessionId: string;
  /** Unique message ID */
  messageId: string;
  timestamp: Date | undefined;
  payload:
    | //
    /** Connection lifecycle */
    { $case: "register"; register: RegisterRequest }
    | //
    /** Keepalive */
    { $case: "heartbeat"; heartbeat: HeartbeatUpdate }
    | //
    /** Terminal output */
    { $case: "output"; output: TerminalOutput }
    | //
    /** Command finished */
    { $case: "commandComplete"; commandComplete: CommandComplete }
    | //
    /** Status updates */
    { $case: "status"; status: StatusUpdate }
    | //
    /** Error notification */
    { $case: "error"; error: ErrorReport }
    | //
    /** Acknowledgements */
    { $case: "ack"; ack: CommandAck }
    | //
    /** History response */
    { $case: "history"; history: HistoryResult }
    | //
    /** File operation result */
    { $case: "fileOperationResult"; fileOperationResult: FileOperationResult }
    | //
    /** Tunnel responses */
    { $case: "tunnelCreated"; tunnelCreated: TunnelCreated }
    | //
    /** Tunnel data packet (response) */
    { $case: "tunnelData"; tunnelData: TunnelData }
    | //
    /** Tunnel closed ack */
    { $case: "tunnelClosed"; tunnelClosed: TunnelClosed }
    | //
    /** Tunnel error report */
    { $case: "tunnelError"; tunnelError: TunnelError }
    | //
    /** Permission status (added in v2.3.0) */
    { $case: "permissionStatus"; permissionStatus: PermissionStatus }
    | //
    /** AI Agent responses (v2.12.0) */
    { $case: "agentResult"; agentResult: AgentResult }
    | //
    /** Streaming event (token, tool) */
    { $case: "agentEvent"; agentEvent: AgentStreamEvent }
    | //
    /**
     * Browser Direct Control result (v2.16.0)
     * Response to BrowserCommand from control_messages.proto
     */
    { $case: "browserResult"; browserResult: BrowserCommandResult }
    | //
    /** Skills relay results (v2.24.0) */
    { $case: "skillListResult"; skillListResult: SkillListResult }
    | //
    /** Skill show result */
    { $case: "skillShowResult"; skillShowResult: SkillShowResult }
    | //
    /** Skill run result */
    { $case: "skillRunResult"; skillRunResult: SkillRunResult }
    | undefined;
}

/**
 * Result of BrowserCommand execution
 * Sent from Agent to Django as response to BrowserCommand
 */
export interface BrowserCommandResult {
  /** Correlates with BrowserCommand.request_id */
  requestId: string;
  /** Whether command succeeded */
  success: boolean;
  /** JSON-encoded result (BrowserNavigateResponse, etc.) */
  resultJson: string;
  /** Error message if !success */
  error: string;
  /** Command execution time */
  durationMs: string;
}

/** Registration request from Agent */
export interface RegisterRequest {
  /** Agent version */
  version: string;
  /** Machine hostname */
  hostname: string;
  /** OS platform (darwin, win32, linux, ios, android) */
  platform: string;
  /** Available shells (empty for mobile) */
  supportedShells: string[];
  /** Initial terminal size */
  initialSize:
    | TerminalSize
    | undefined;
  /** Mobile device support (added in v2.1.0) */
  architecture: string;
  /** Unique device ID (UDID for iOS, Android ID) */
  deviceId: string;
  /** Device type: desktop, ios, android */
  deviceType: string;
  /** Whether device has shell access (false for mobile) */
  hasShell: boolean;
  /** Device model (iPhone 14 Pro, Pixel 8, etc.) */
  deviceModel: string;
  /** Extended system info (added in v2.2.0) */
  publicIp: string;
  /** Local IP addresses */
  localIps: string[];
  /** Current username */
  username: string;
  /** User ID (Unix) */
  uid: number;
  /** Running as root/admin */
  isRoot: boolean;
  /** User home directory */
  homeDir: string;
  /** OS version (e.g., "Ubuntu 22.04", "macOS 14.2") */
  osVersion: string;
  /** Kernel version */
  kernelVersion: string;
  /** CPU model name */
  cpuModel: string;
  /** Number of CPU cores */
  cpuCount: number;
  /** Total RAM in bytes */
  totalRam: string;
  /** System uptime in seconds */
  uptimeSeconds: string;
}

/**
 * Heartbeat with optional system metrics
 * Sent every 30 seconds to keep connection alive and report machine status
 */
export interface HeartbeatUpdate {
  /** System metrics (optional, for monitoring) */
  metrics: SystemMetrics | undefined;
}

/** Terminal output chunk (stdout/stderr from PTY) */
export interface TerminalOutput {
  /** Raw output bytes */
  data: Buffer;
  /** True if from stderr */
  isStderr: boolean;
  /** Sequence number for ordering */
  sequence: string;
}

/** Command completed notification */
export interface CommandComplete {
  /** Command that completed */
  commandId: string;
  /** Exit code */
  exitCode: number;
  /** Execution time in ms */
  durationMs: string;
}

/** Status update from Agent */
export interface StatusUpdate {
  oldStatus: SessionStatus;
  newStatus: SessionStatus;
  /** Reason for status change */
  reason: string;
  /** Current working directory */
  workingDirectory: string;
}

/** Error report with user-friendly suggestions */
export interface ErrorReport {
  /** Error code */
  errorCode: string;
  /** Error message */
  message: string;
  /** Optional stack trace */
  stackTrace: string;
  /** If true, session will close */
  isFatal: boolean;
  /** User-friendly suggestions for resolution */
  suggestions: string[];
  /** Whether the operation can be retried */
  canRetry: boolean;
}

/** Command acknowledgement */
export interface CommandAck {
  /** ID of acknowledged command */
  commandId: string;
  /** Successful? */
  success: boolean;
  /** Optional message */
  message: string;
}

/** History result from agent (shell history file content) */
export interface HistoryResult {
  /** Correlates with GetHistoryCommand */
  commandId: string;
  /** List of commands from history */
  commands: string[];
  /** Total count in history file */
  total: number;
  /** Source: "bash_history", "zsh_history", etc. */
  source: string;
  /** Error message if failed */
  error: string;
}

/**
 * Permission status for directories
 * Sent after warm-up to inform Django about accessible directories
 */
export interface PermissionStatus {
  /** List of checked directories */
  directories: DirectoryPermission[];
  /** Platform (darwin, windows, linux) */
  platform: string;
  /** Unix timestamp when checked */
  checkedAt: string;
}

/** Permission status for a single directory */
export interface DirectoryPermission {
  /** Directory path */
  path: string;
  /** Access status */
  status: PermissionAccessStatus;
  /** Error message if denied */
  errorMessage: string;
  /** True for protected directories (Desktop, Documents, etc.) */
  isSensitive: boolean;
}

/** Final result from AI agent execution */
export interface AgentResult {
  /** Correlates with AgentRunCommand.request_id */
  requestId: string;
  /** Whether execution succeeded */
  success: boolean;
  /** Response text from agent */
  text: string;
  /** Error message if failed */
  error: string;
  /** Tool execution results */
  toolResults: AgentToolResult[];
  /** Token usage stats */
  usage:
    | AgentUsage
    | undefined;
  /** Execution duration in milliseconds */
  durationMs: string;
  /** Structured output JSON (if output_schema was provided) */
  outputJson: string;
}

/** Tool execution result */
export interface AgentToolResult {
  /** Name of the tool */
  toolName: string;
  /** Tool call ID */
  toolCallId: string;
  /** Whether tool succeeded */
  success: boolean;
  /** Tool result (JSON string) */
  result: string;
  /** Error if failed */
  error: string;
  /** Tool execution time */
  durationMs: string;
}

/** Token usage statistics */
export interface AgentUsage {
  /** Input tokens */
  promptTokens: number;
  /** Output tokens */
  completionTokens: number;
  /** Total tokens */
  totalTokens: number;
}

/** Streaming event from agent (tokens, tool calls) */
export interface AgentStreamEvent {
  /** Correlates with AgentRunCommand.request_id */
  requestId: string;
  /** Event type */
  type: AgentEventType;
  /** Event-specific payload (JSON) */
  payload: string;
  /** Unix timestamp in milliseconds */
  timestamp: string;
}

/** Browser page state (sent with AGENT_EVENT_BROWSER_STATE) */
export interface BrowserPageState {
  /** Current URL */
  url: string;
  /** Page title */
  title: string;
  /** Semantic markdown content */
  content: string;
  /** Token count of content */
  tokenCount: number;
  /** Number of interactive elements */
  elementCount: number;
  /** True if content is differential */
  isDiff: boolean;
  /** Number of changes (if is_diff) */
  changesCount: number;
  /** Reified links map */
  links: BrowserLink[];
}

/** Link reference for URL reification */
export interface BrowserLink {
  /** Link index [1], [2], etc. */
  index: number;
  /** Full URL */
  url: string;
  /** Link text */
  text: string;
}

/** Browser navigation result (sent with AGENT_EVENT_BROWSER_NAVIGATE) */
export interface BrowserNavigateResult {
  /** Target URL */
  url: string;
  /** Previous URL */
  fromUrl: string;
  /** Navigation time */
  durationMs: string;
  /** Success status */
  success: boolean;
  /** HTTP status code */
  statusCode: number;
  /** Page title */
  title: string;
}

/** Browser action result (click, type, etc.) */
export interface BrowserActionResult {
  /** Action type: click, type, scroll */
  action: string;
  /** Target selector */
  selector: string;
  /** Text typed or element text */
  text: string;
  /** Action time */
  durationMs: string;
  /** Success status */
  success: boolean;
  /** Error if !success */
  error: string;
}

/** Browser screenshot result */
export interface BrowserScreenshotResult {
  /** Full page or viewport */
  fullpage: boolean;
  /** Element selector if element shot */
  selector: string;
  /** Image format: png, jpeg */
  format: string;
  /** Image size */
  sizeBytes: number;
  /** Image data (base64 in JSON) */
  data: Buffer;
}

/** Browser detection event (bot detection) */
export interface BrowserDetectionEvent {
  /** Detection type: captcha, block, rate_limit, challenge */
  type: string;
  /** URL where detected */
  url: string;
  /** Detection confidence 0-1 */
  confidence: number;
  /** Additional details */
  details: string;
}

/** Browser escalation event (stealth escalation) */
export interface BrowserEscalationEvent {
  /** Previous level */
  fromLevel: string;
  /** New level */
  toLevel: string;
  /** Escalation reason */
  reason: string;
  /** Escalation success */
  success: boolean;
}

/** Browser session event */
export interface BrowserSessionEvent {
  /** Session UUID */
  sessionId: string;
  /** Browser profile ID */
  profileId: string;
  /** ephemeral, persistent, long_lived */
  sessionType: string;
  /** True=start, False=end */
  isStart: boolean;
  /** Current/final URL */
  url: string;
}

/**
 * Lightweight skill info for streaming messages.
 * Avoids circular import with rpc_messages/skills.proto which imports agent_messages.proto.
 */
export interface SkillInfoItem {
  /** Skill name (e.g. "code-review") */
  name: string;
  /** Human-readable description */
  description: string;
  /** Skill author */
  author: string;
  /** Semantic version */
  version: string;
  /** LLM model override */
  model: string;
  /** Where loaded from: builtin, global, workspace */
  origin: string;
  /** Required system binaries */
  requiredBins: string[];
  /** Required environment variables */
  requiredEnv: string[];
}

/** Result of SkillListCommand */
export interface SkillListResult {
  /** Correlates with SkillListCommand.request_id */
  requestId: string;
  /** All installed skills */
  skills: SkillInfoItem[];
}

/** Result of SkillShowCommand */
export interface SkillShowResult {
  /** Correlates with SkillShowCommand.request_id */
  requestId: string;
  /** Whether the skill was found */
  found: boolean;
  /** Skill metadata (only set if found=true) */
  info:
    | SkillInfoItem
    | undefined;
  /** System prompt body (markdown) */
  content: string;
  /** Source file path on the machine */
  source: string;
  /** Error message if lookup failed */
  error: string;
}

/** Result of SkillRunCommand */
export interface SkillRunResult {
  /** Correlates with SkillRunCommand.request_id */
  requestId: string;
  /** Whether execution succeeded */
  success: boolean;
  /** Skill's response text */
  text: string;
  /** Error message if !success */
  error: string;
  /** Tool execution results */
  toolResults: AgentToolResult[];
  /** Token usage stats */
  usage:
    | AgentUsage
    | undefined;
  /** Execution duration in ms */
  durationMs: string;
  /** Structured output JSON (if schema provided) */
  outputJson: string;
}

function createBaseAgentMessage(): AgentMessage {
  return { sessionId: "", messageId: "", timestamp: undefined, payload: undefined };
}

export const AgentMessage: MessageFns<AgentMessage> = {
  encode(message: AgentMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.messageId !== "") {
      writer.uint32(18).string(message.messageId);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).join();
    }
    switch (message.payload?.$case) {
      case "register":
        RegisterRequest.encode(message.payload.register, writer.uint32(82).fork()).join();
        break;
      case "heartbeat":
        HeartbeatUpdate.encode(message.payload.heartbeat, writer.uint32(90).fork()).join();
        break;
      case "output":
        TerminalOutput.encode(message.payload.output, writer.uint32(162).fork()).join();
        break;
      case "commandComplete":
        CommandComplete.encode(message.payload.commandComplete, writer.uint32(170).fork()).join();
        break;
      case "status":
        StatusUpdate.encode(message.payload.status, writer.uint32(242).fork()).join();
        break;
      case "error":
        ErrorReport.encode(message.payload.error, writer.uint32(250).fork()).join();
        break;
      case "ack":
        CommandAck.encode(message.payload.ack, writer.uint32(322).fork()).join();
        break;
      case "history":
        HistoryResult.encode(message.payload.history, writer.uint32(402).fork()).join();
        break;
      case "fileOperationResult":
        FileOperationResult.encode(message.payload.fileOperationResult, writer.uint32(482).fork()).join();
        break;
      case "tunnelCreated":
        TunnelCreated.encode(message.payload.tunnelCreated, writer.uint32(562).fork()).join();
        break;
      case "tunnelData":
        TunnelData.encode(message.payload.tunnelData, writer.uint32(570).fork()).join();
        break;
      case "tunnelClosed":
        TunnelClosed.encode(message.payload.tunnelClosed, writer.uint32(578).fork()).join();
        break;
      case "tunnelError":
        TunnelError.encode(message.payload.tunnelError, writer.uint32(586).fork()).join();
        break;
      case "permissionStatus":
        PermissionStatus.encode(message.payload.permissionStatus, writer.uint32(642).fork()).join();
        break;
      case "agentResult":
        AgentResult.encode(message.payload.agentResult, writer.uint32(722).fork()).join();
        break;
      case "agentEvent":
        AgentStreamEvent.encode(message.payload.agentEvent, writer.uint32(730).fork()).join();
        break;
      case "browserResult":
        BrowserCommandResult.encode(message.payload.browserResult, writer.uint32(802).fork()).join();
        break;
      case "skillListResult":
        SkillListResult.encode(message.payload.skillListResult, writer.uint32(882).fork()).join();
        break;
      case "skillShowResult":
        SkillShowResult.encode(message.payload.skillShowResult, writer.uint32(890).fork()).join();
        break;
      case "skillRunResult":
        SkillRunResult.encode(message.payload.skillRunResult, writer.uint32(898).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.payload = { $case: "register", register: RegisterRequest.decode(reader, reader.uint32()) };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.payload = { $case: "heartbeat", heartbeat: HeartbeatUpdate.decode(reader, reader.uint32()) };
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.payload = { $case: "output", output: TerminalOutput.decode(reader, reader.uint32()) };
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.payload = {
            $case: "commandComplete",
            commandComplete: CommandComplete.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.payload = { $case: "status", status: StatusUpdate.decode(reader, reader.uint32()) };
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.payload = { $case: "error", error: ErrorReport.decode(reader, reader.uint32()) };
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.payload = { $case: "ack", ack: CommandAck.decode(reader, reader.uint32()) };
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.payload = { $case: "history", history: HistoryResult.decode(reader, reader.uint32()) };
          continue;
        }
        case 60: {
          if (tag !== 482) {
            break;
          }

          message.payload = {
            $case: "fileOperationResult",
            fileOperationResult: FileOperationResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 70: {
          if (tag !== 562) {
            break;
          }

          message.payload = { $case: "tunnelCreated", tunnelCreated: TunnelCreated.decode(reader, reader.uint32()) };
          continue;
        }
        case 71: {
          if (tag !== 570) {
            break;
          }

          message.payload = { $case: "tunnelData", tunnelData: TunnelData.decode(reader, reader.uint32()) };
          continue;
        }
        case 72: {
          if (tag !== 578) {
            break;
          }

          message.payload = { $case: "tunnelClosed", tunnelClosed: TunnelClosed.decode(reader, reader.uint32()) };
          continue;
        }
        case 73: {
          if (tag !== 586) {
            break;
          }

          message.payload = { $case: "tunnelError", tunnelError: TunnelError.decode(reader, reader.uint32()) };
          continue;
        }
        case 80: {
          if (tag !== 642) {
            break;
          }

          message.payload = {
            $case: "permissionStatus",
            permissionStatus: PermissionStatus.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 90: {
          if (tag !== 722) {
            break;
          }

          message.payload = { $case: "agentResult", agentResult: AgentResult.decode(reader, reader.uint32()) };
          continue;
        }
        case 91: {
          if (tag !== 730) {
            break;
          }

          message.payload = { $case: "agentEvent", agentEvent: AgentStreamEvent.decode(reader, reader.uint32()) };
          continue;
        }
        case 100: {
          if (tag !== 802) {
            break;
          }

          message.payload = {
            $case: "browserResult",
            browserResult: BrowserCommandResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 110: {
          if (tag !== 882) {
            break;
          }

          message.payload = {
            $case: "skillListResult",
            skillListResult: SkillListResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 111: {
          if (tag !== 890) {
            break;
          }

          message.payload = {
            $case: "skillShowResult",
            skillShowResult: SkillShowResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 112: {
          if (tag !== 898) {
            break;
          }

          message.payload = { $case: "skillRunResult", skillRunResult: SkillRunResult.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentMessage {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      messageId: isSet(object.messageId)
        ? globalThis.String(object.messageId)
        : isSet(object.message_id)
        ? globalThis.String(object.message_id)
        : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      payload: isSet(object.register)
        ? { $case: "register", register: RegisterRequest.fromJSON(object.register) }
        : isSet(object.heartbeat)
        ? { $case: "heartbeat", heartbeat: HeartbeatUpdate.fromJSON(object.heartbeat) }
        : isSet(object.output)
        ? { $case: "output", output: TerminalOutput.fromJSON(object.output) }
        : isSet(object.commandComplete)
        ? { $case: "commandComplete", commandComplete: CommandComplete.fromJSON(object.commandComplete) }
        : isSet(object.command_complete)
        ? { $case: "commandComplete", commandComplete: CommandComplete.fromJSON(object.command_complete) }
        : isSet(object.status)
        ? { $case: "status", status: StatusUpdate.fromJSON(object.status) }
        : isSet(object.error)
        ? { $case: "error", error: ErrorReport.fromJSON(object.error) }
        : isSet(object.ack)
        ? { $case: "ack", ack: CommandAck.fromJSON(object.ack) }
        : isSet(object.history)
        ? { $case: "history", history: HistoryResult.fromJSON(object.history) }
        : isSet(object.fileOperationResult)
        ? {
          $case: "fileOperationResult",
          fileOperationResult: FileOperationResult.fromJSON(object.fileOperationResult),
        }
        : isSet(object.file_operation_result)
        ? {
          $case: "fileOperationResult",
          fileOperationResult: FileOperationResult.fromJSON(object.file_operation_result),
        }
        : isSet(object.tunnelCreated)
        ? { $case: "tunnelCreated", tunnelCreated: TunnelCreated.fromJSON(object.tunnelCreated) }
        : isSet(object.tunnel_created)
        ? { $case: "tunnelCreated", tunnelCreated: TunnelCreated.fromJSON(object.tunnel_created) }
        : isSet(object.tunnelData)
        ? { $case: "tunnelData", tunnelData: TunnelData.fromJSON(object.tunnelData) }
        : isSet(object.tunnel_data)
        ? { $case: "tunnelData", tunnelData: TunnelData.fromJSON(object.tunnel_data) }
        : isSet(object.tunnelClosed)
        ? { $case: "tunnelClosed", tunnelClosed: TunnelClosed.fromJSON(object.tunnelClosed) }
        : isSet(object.tunnel_closed)
        ? { $case: "tunnelClosed", tunnelClosed: TunnelClosed.fromJSON(object.tunnel_closed) }
        : isSet(object.tunnelError)
        ? { $case: "tunnelError", tunnelError: TunnelError.fromJSON(object.tunnelError) }
        : isSet(object.tunnel_error)
        ? { $case: "tunnelError", tunnelError: TunnelError.fromJSON(object.tunnel_error) }
        : isSet(object.permissionStatus)
        ? { $case: "permissionStatus", permissionStatus: PermissionStatus.fromJSON(object.permissionStatus) }
        : isSet(object.permission_status)
        ? { $case: "permissionStatus", permissionStatus: PermissionStatus.fromJSON(object.permission_status) }
        : isSet(object.agentResult)
        ? { $case: "agentResult", agentResult: AgentResult.fromJSON(object.agentResult) }
        : isSet(object.agent_result)
        ? { $case: "agentResult", agentResult: AgentResult.fromJSON(object.agent_result) }
        : isSet(object.agentEvent)
        ? { $case: "agentEvent", agentEvent: AgentStreamEvent.fromJSON(object.agentEvent) }
        : isSet(object.agent_event)
        ? { $case: "agentEvent", agentEvent: AgentStreamEvent.fromJSON(object.agent_event) }
        : isSet(object.browserResult)
        ? { $case: "browserResult", browserResult: BrowserCommandResult.fromJSON(object.browserResult) }
        : isSet(object.browser_result)
        ? { $case: "browserResult", browserResult: BrowserCommandResult.fromJSON(object.browser_result) }
        : isSet(object.skillListResult)
        ? { $case: "skillListResult", skillListResult: SkillListResult.fromJSON(object.skillListResult) }
        : isSet(object.skill_list_result)
        ? { $case: "skillListResult", skillListResult: SkillListResult.fromJSON(object.skill_list_result) }
        : isSet(object.skillShowResult)
        ? { $case: "skillShowResult", skillShowResult: SkillShowResult.fromJSON(object.skillShowResult) }
        : isSet(object.skill_show_result)
        ? { $case: "skillShowResult", skillShowResult: SkillShowResult.fromJSON(object.skill_show_result) }
        : isSet(object.skillRunResult)
        ? { $case: "skillRunResult", skillRunResult: SkillRunResult.fromJSON(object.skillRunResult) }
        : isSet(object.skill_run_result)
        ? { $case: "skillRunResult", skillRunResult: SkillRunResult.fromJSON(object.skill_run_result) }
        : undefined,
    };
  },

  toJSON(message: AgentMessage): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.payload?.$case === "register") {
      obj.register = RegisterRequest.toJSON(message.payload.register);
    } else if (message.payload?.$case === "heartbeat") {
      obj.heartbeat = HeartbeatUpdate.toJSON(message.payload.heartbeat);
    } else if (message.payload?.$case === "output") {
      obj.output = TerminalOutput.toJSON(message.payload.output);
    } else if (message.payload?.$case === "commandComplete") {
      obj.commandComplete = CommandComplete.toJSON(message.payload.commandComplete);
    } else if (message.payload?.$case === "status") {
      obj.status = StatusUpdate.toJSON(message.payload.status);
    } else if (message.payload?.$case === "error") {
      obj.error = ErrorReport.toJSON(message.payload.error);
    } else if (message.payload?.$case === "ack") {
      obj.ack = CommandAck.toJSON(message.payload.ack);
    } else if (message.payload?.$case === "history") {
      obj.history = HistoryResult.toJSON(message.payload.history);
    } else if (message.payload?.$case === "fileOperationResult") {
      obj.fileOperationResult = FileOperationResult.toJSON(message.payload.fileOperationResult);
    } else if (message.payload?.$case === "tunnelCreated") {
      obj.tunnelCreated = TunnelCreated.toJSON(message.payload.tunnelCreated);
    } else if (message.payload?.$case === "tunnelData") {
      obj.tunnelData = TunnelData.toJSON(message.payload.tunnelData);
    } else if (message.payload?.$case === "tunnelClosed") {
      obj.tunnelClosed = TunnelClosed.toJSON(message.payload.tunnelClosed);
    } else if (message.payload?.$case === "tunnelError") {
      obj.tunnelError = TunnelError.toJSON(message.payload.tunnelError);
    } else if (message.payload?.$case === "permissionStatus") {
      obj.permissionStatus = PermissionStatus.toJSON(message.payload.permissionStatus);
    } else if (message.payload?.$case === "agentResult") {
      obj.agentResult = AgentResult.toJSON(message.payload.agentResult);
    } else if (message.payload?.$case === "agentEvent") {
      obj.agentEvent = AgentStreamEvent.toJSON(message.payload.agentEvent);
    } else if (message.payload?.$case === "browserResult") {
      obj.browserResult = BrowserCommandResult.toJSON(message.payload.browserResult);
    } else if (message.payload?.$case === "skillListResult") {
      obj.skillListResult = SkillListResult.toJSON(message.payload.skillListResult);
    } else if (message.payload?.$case === "skillShowResult") {
      obj.skillShowResult = SkillShowResult.toJSON(message.payload.skillShowResult);
    } else if (message.payload?.$case === "skillRunResult") {
      obj.skillRunResult = SkillRunResult.toJSON(message.payload.skillRunResult);
    }
    return obj;
  },

  create(base?: DeepPartial<AgentMessage>): AgentMessage {
    return AgentMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgentMessage>): AgentMessage {
    const message = createBaseAgentMessage();
    message.sessionId = object.sessionId ?? "";
    message.messageId = object.messageId ?? "";
    message.timestamp = object.timestamp ?? undefined;
    switch (object.payload?.$case) {
      case "register": {
        if (object.payload?.register !== undefined && object.payload?.register !== null) {
          message.payload = { $case: "register", register: RegisterRequest.fromPartial(object.payload.register) };
        }
        break;
      }
      case "heartbeat": {
        if (object.payload?.heartbeat !== undefined && object.payload?.heartbeat !== null) {
          message.payload = { $case: "heartbeat", heartbeat: HeartbeatUpdate.fromPartial(object.payload.heartbeat) };
        }
        break;
      }
      case "output": {
        if (object.payload?.output !== undefined && object.payload?.output !== null) {
          message.payload = { $case: "output", output: TerminalOutput.fromPartial(object.payload.output) };
        }
        break;
      }
      case "commandComplete": {
        if (object.payload?.commandComplete !== undefined && object.payload?.commandComplete !== null) {
          message.payload = {
            $case: "commandComplete",
            commandComplete: CommandComplete.fromPartial(object.payload.commandComplete),
          };
        }
        break;
      }
      case "status": {
        if (object.payload?.status !== undefined && object.payload?.status !== null) {
          message.payload = { $case: "status", status: StatusUpdate.fromPartial(object.payload.status) };
        }
        break;
      }
      case "error": {
        if (object.payload?.error !== undefined && object.payload?.error !== null) {
          message.payload = { $case: "error", error: ErrorReport.fromPartial(object.payload.error) };
        }
        break;
      }
      case "ack": {
        if (object.payload?.ack !== undefined && object.payload?.ack !== null) {
          message.payload = { $case: "ack", ack: CommandAck.fromPartial(object.payload.ack) };
        }
        break;
      }
      case "history": {
        if (object.payload?.history !== undefined && object.payload?.history !== null) {
          message.payload = { $case: "history", history: HistoryResult.fromPartial(object.payload.history) };
        }
        break;
      }
      case "fileOperationResult": {
        if (object.payload?.fileOperationResult !== undefined && object.payload?.fileOperationResult !== null) {
          message.payload = {
            $case: "fileOperationResult",
            fileOperationResult: FileOperationResult.fromPartial(object.payload.fileOperationResult),
          };
        }
        break;
      }
      case "tunnelCreated": {
        if (object.payload?.tunnelCreated !== undefined && object.payload?.tunnelCreated !== null) {
          message.payload = {
            $case: "tunnelCreated",
            tunnelCreated: TunnelCreated.fromPartial(object.payload.tunnelCreated),
          };
        }
        break;
      }
      case "tunnelData": {
        if (object.payload?.tunnelData !== undefined && object.payload?.tunnelData !== null) {
          message.payload = { $case: "tunnelData", tunnelData: TunnelData.fromPartial(object.payload.tunnelData) };
        }
        break;
      }
      case "tunnelClosed": {
        if (object.payload?.tunnelClosed !== undefined && object.payload?.tunnelClosed !== null) {
          message.payload = {
            $case: "tunnelClosed",
            tunnelClosed: TunnelClosed.fromPartial(object.payload.tunnelClosed),
          };
        }
        break;
      }
      case "tunnelError": {
        if (object.payload?.tunnelError !== undefined && object.payload?.tunnelError !== null) {
          message.payload = { $case: "tunnelError", tunnelError: TunnelError.fromPartial(object.payload.tunnelError) };
        }
        break;
      }
      case "permissionStatus": {
        if (object.payload?.permissionStatus !== undefined && object.payload?.permissionStatus !== null) {
          message.payload = {
            $case: "permissionStatus",
            permissionStatus: PermissionStatus.fromPartial(object.payload.permissionStatus),
          };
        }
        break;
      }
      case "agentResult": {
        if (object.payload?.agentResult !== undefined && object.payload?.agentResult !== null) {
          message.payload = { $case: "agentResult", agentResult: AgentResult.fromPartial(object.payload.agentResult) };
        }
        break;
      }
      case "agentEvent": {
        if (object.payload?.agentEvent !== undefined && object.payload?.agentEvent !== null) {
          message.payload = {
            $case: "agentEvent",
            agentEvent: AgentStreamEvent.fromPartial(object.payload.agentEvent),
          };
        }
        break;
      }
      case "browserResult": {
        if (object.payload?.browserResult !== undefined && object.payload?.browserResult !== null) {
          message.payload = {
            $case: "browserResult",
            browserResult: BrowserCommandResult.fromPartial(object.payload.browserResult),
          };
        }
        break;
      }
      case "skillListResult": {
        if (object.payload?.skillListResult !== undefined && object.payload?.skillListResult !== null) {
          message.payload = {
            $case: "skillListResult",
            skillListResult: SkillListResult.fromPartial(object.payload.skillListResult),
          };
        }
        break;
      }
      case "skillShowResult": {
        if (object.payload?.skillShowResult !== undefined && object.payload?.skillShowResult !== null) {
          message.payload = {
            $case: "skillShowResult",
            skillShowResult: SkillShowResult.fromPartial(object.payload.skillShowResult),
          };
        }
        break;
      }
      case "skillRunResult": {
        if (object.payload?.skillRunResult !== undefined && object.payload?.skillRunResult !== null) {
          message.payload = {
            $case: "skillRunResult",
            skillRunResult: SkillRunResult.fromPartial(object.payload.skillRunResult),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseBrowserCommandResult(): BrowserCommandResult {
  return { requestId: "", success: false, resultJson: "", error: "", durationMs: "0" };
}

export const BrowserCommandResult: MessageFns<BrowserCommandResult> = {
  encode(message: BrowserCommandResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.resultJson !== "") {
      writer.uint32(26).string(message.resultJson);
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    if (message.durationMs !== "0") {
      writer.uint32(40).int64(message.durationMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrowserCommandResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrowserCommandResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resultJson = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.durationMs = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrowserCommandResult {
    return {
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      resultJson: isSet(object.resultJson)
        ? globalThis.String(object.resultJson)
        : isSet(object.result_json)
        ? globalThis.String(object.result_json)
        : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      durationMs: isSet(object.durationMs)
        ? globalThis.String(object.durationMs)
        : isSet(object.duration_ms)
        ? globalThis.String(object.duration_ms)
        : "0",
    };
  },

  toJSON(message: BrowserCommandResult): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.resultJson !== "") {
      obj.resultJson = message.resultJson;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.durationMs !== "0") {
      obj.durationMs = message.durationMs;
    }
    return obj;
  },

  create(base?: DeepPartial<BrowserCommandResult>): BrowserCommandResult {
    return BrowserCommandResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BrowserCommandResult>): BrowserCommandResult {
    const message = createBaseBrowserCommandResult();
    message.requestId = object.requestId ?? "";
    message.success = object.success ?? false;
    message.resultJson = object.resultJson ?? "";
    message.error = object.error ?? "";
    message.durationMs = object.durationMs ?? "0";
    return message;
  },
};

function createBaseRegisterRequest(): RegisterRequest {
  return {
    version: "",
    hostname: "",
    platform: "",
    supportedShells: [],
    initialSize: undefined,
    architecture: "",
    deviceId: "",
    deviceType: "",
    hasShell: false,
    deviceModel: "",
    publicIp: "",
    localIps: [],
    username: "",
    uid: 0,
    isRoot: false,
    homeDir: "",
    osVersion: "",
    kernelVersion: "",
    cpuModel: "",
    cpuCount: 0,
    totalRam: "0",
    uptimeSeconds: "0",
  };
}

export const RegisterRequest: MessageFns<RegisterRequest> = {
  encode(message: RegisterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.hostname !== "") {
      writer.uint32(18).string(message.hostname);
    }
    if (message.platform !== "") {
      writer.uint32(26).string(message.platform);
    }
    for (const v of message.supportedShells) {
      writer.uint32(34).string(v!);
    }
    if (message.initialSize !== undefined) {
      TerminalSize.encode(message.initialSize, writer.uint32(42).fork()).join();
    }
    if (message.architecture !== "") {
      writer.uint32(50).string(message.architecture);
    }
    if (message.deviceId !== "") {
      writer.uint32(58).string(message.deviceId);
    }
    if (message.deviceType !== "") {
      writer.uint32(66).string(message.deviceType);
    }
    if (message.hasShell !== false) {
      writer.uint32(72).bool(message.hasShell);
    }
    if (message.deviceModel !== "") {
      writer.uint32(82).string(message.deviceModel);
    }
    if (message.publicIp !== "") {
      writer.uint32(90).string(message.publicIp);
    }
    for (const v of message.localIps) {
      writer.uint32(98).string(v!);
    }
    if (message.username !== "") {
      writer.uint32(106).string(message.username);
    }
    if (message.uid !== 0) {
      writer.uint32(112).uint32(message.uid);
    }
    if (message.isRoot !== false) {
      writer.uint32(120).bool(message.isRoot);
    }
    if (message.homeDir !== "") {
      writer.uint32(130).string(message.homeDir);
    }
    if (message.osVersion !== "") {
      writer.uint32(138).string(message.osVersion);
    }
    if (message.kernelVersion !== "") {
      writer.uint32(146).string(message.kernelVersion);
    }
    if (message.cpuModel !== "") {
      writer.uint32(154).string(message.cpuModel);
    }
    if (message.cpuCount !== 0) {
      writer.uint32(160).uint32(message.cpuCount);
    }
    if (message.totalRam !== "0") {
      writer.uint32(168).uint64(message.totalRam);
    }
    if (message.uptimeSeconds !== "0") {
      writer.uint32(176).uint64(message.uptimeSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.platform = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.supportedShells.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.initialSize = TerminalSize.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.architecture = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.deviceType = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.hasShell = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.deviceModel = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.publicIp = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.localIps.push(reader.string());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.uid = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.isRoot = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.homeDir = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.osVersion = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.kernelVersion = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.cpuModel = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.cpuCount = reader.uint32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.totalRam = reader.uint64().toString();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.uptimeSeconds = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterRequest {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      platform: isSet(object.platform) ? globalThis.String(object.platform) : "",
      supportedShells: globalThis.Array.isArray(object?.supportedShells)
        ? object.supportedShells.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.supported_shells)
        ? object.supported_shells.map((e: any) => globalThis.String(e))
        : [],
      initialSize: isSet(object.initialSize)
        ? TerminalSize.fromJSON(object.initialSize)
        : isSet(object.initial_size)
        ? TerminalSize.fromJSON(object.initial_size)
        : undefined,
      architecture: isSet(object.architecture) ? globalThis.String(object.architecture) : "",
      deviceId: isSet(object.deviceId)
        ? globalThis.String(object.deviceId)
        : isSet(object.device_id)
        ? globalThis.String(object.device_id)
        : "",
      deviceType: isSet(object.deviceType)
        ? globalThis.String(object.deviceType)
        : isSet(object.device_type)
        ? globalThis.String(object.device_type)
        : "",
      hasShell: isSet(object.hasShell)
        ? globalThis.Boolean(object.hasShell)
        : isSet(object.has_shell)
        ? globalThis.Boolean(object.has_shell)
        : false,
      deviceModel: isSet(object.deviceModel)
        ? globalThis.String(object.deviceModel)
        : isSet(object.device_model)
        ? globalThis.String(object.device_model)
        : "",
      publicIp: isSet(object.publicIp)
        ? globalThis.String(object.publicIp)
        : isSet(object.public_ip)
        ? globalThis.String(object.public_ip)
        : "",
      localIps: globalThis.Array.isArray(object?.localIps)
        ? object.localIps.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.local_ips)
        ? object.local_ips.map((e: any) => globalThis.String(e))
        : [],
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      uid: isSet(object.uid) ? globalThis.Number(object.uid) : 0,
      isRoot: isSet(object.isRoot)
        ? globalThis.Boolean(object.isRoot)
        : isSet(object.is_root)
        ? globalThis.Boolean(object.is_root)
        : false,
      homeDir: isSet(object.homeDir)
        ? globalThis.String(object.homeDir)
        : isSet(object.home_dir)
        ? globalThis.String(object.home_dir)
        : "",
      osVersion: isSet(object.osVersion)
        ? globalThis.String(object.osVersion)
        : isSet(object.os_version)
        ? globalThis.String(object.os_version)
        : "",
      kernelVersion: isSet(object.kernelVersion)
        ? globalThis.String(object.kernelVersion)
        : isSet(object.kernel_version)
        ? globalThis.String(object.kernel_version)
        : "",
      cpuModel: isSet(object.cpuModel)
        ? globalThis.String(object.cpuModel)
        : isSet(object.cpu_model)
        ? globalThis.String(object.cpu_model)
        : "",
      cpuCount: isSet(object.cpuCount)
        ? globalThis.Number(object.cpuCount)
        : isSet(object.cpu_count)
        ? globalThis.Number(object.cpu_count)
        : 0,
      totalRam: isSet(object.totalRam)
        ? globalThis.String(object.totalRam)
        : isSet(object.total_ram)
        ? globalThis.String(object.total_ram)
        : "0",
      uptimeSeconds: isSet(object.uptimeSeconds)
        ? globalThis.String(object.uptimeSeconds)
        : isSet(object.uptime_seconds)
        ? globalThis.String(object.uptime_seconds)
        : "0",
    };
  },

  toJSON(message: RegisterRequest): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.platform !== "") {
      obj.platform = message.platform;
    }
    if (message.supportedShells?.length) {
      obj.supportedShells = message.supportedShells;
    }
    if (message.initialSize !== undefined) {
      obj.initialSize = TerminalSize.toJSON(message.initialSize);
    }
    if (message.architecture !== "") {
      obj.architecture = message.architecture;
    }
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.deviceType !== "") {
      obj.deviceType = message.deviceType;
    }
    if (message.hasShell !== false) {
      obj.hasShell = message.hasShell;
    }
    if (message.deviceModel !== "") {
      obj.deviceModel = message.deviceModel;
    }
    if (message.publicIp !== "") {
      obj.publicIp = message.publicIp;
    }
    if (message.localIps?.length) {
      obj.localIps = message.localIps;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.uid !== 0) {
      obj.uid = Math.round(message.uid);
    }
    if (message.isRoot !== false) {
      obj.isRoot = message.isRoot;
    }
    if (message.homeDir !== "") {
      obj.homeDir = message.homeDir;
    }
    if (message.osVersion !== "") {
      obj.osVersion = message.osVersion;
    }
    if (message.kernelVersion !== "") {
      obj.kernelVersion = message.kernelVersion;
    }
    if (message.cpuModel !== "") {
      obj.cpuModel = message.cpuModel;
    }
    if (message.cpuCount !== 0) {
      obj.cpuCount = Math.round(message.cpuCount);
    }
    if (message.totalRam !== "0") {
      obj.totalRam = message.totalRam;
    }
    if (message.uptimeSeconds !== "0") {
      obj.uptimeSeconds = message.uptimeSeconds;
    }
    return obj;
  },

  create(base?: DeepPartial<RegisterRequest>): RegisterRequest {
    return RegisterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegisterRequest>): RegisterRequest {
    const message = createBaseRegisterRequest();
    message.version = object.version ?? "";
    message.hostname = object.hostname ?? "";
    message.platform = object.platform ?? "";
    message.supportedShells = object.supportedShells?.map((e) => e) || [];
    message.initialSize = (object.initialSize !== undefined && object.initialSize !== null)
      ? TerminalSize.fromPartial(object.initialSize)
      : undefined;
    message.architecture = object.architecture ?? "";
    message.deviceId = object.deviceId ?? "";
    message.deviceType = object.deviceType ?? "";
    message.hasShell = object.hasShell ?? false;
    message.deviceModel = object.deviceModel ?? "";
    message.publicIp = object.publicIp ?? "";
    message.localIps = object.localIps?.map((e) => e) || [];
    message.username = object.username ?? "";
    message.uid = object.uid ?? 0;
    message.isRoot = object.isRoot ?? false;
    message.homeDir = object.homeDir ?? "";
    message.osVersion = object.osVersion ?? "";
    message.kernelVersion = object.kernelVersion ?? "";
    message.cpuModel = object.cpuModel ?? "";
    message.cpuCount = object.cpuCount ?? 0;
    message.totalRam = object.totalRam ?? "0";
    message.uptimeSeconds = object.uptimeSeconds ?? "0";
    return message;
  },
};

function createBaseHeartbeatUpdate(): HeartbeatUpdate {
  return { metrics: undefined };
}

export const HeartbeatUpdate: MessageFns<HeartbeatUpdate> = {
  encode(message: HeartbeatUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metrics !== undefined) {
      SystemMetrics.encode(message.metrics, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metrics = SystemMetrics.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartbeatUpdate {
    return { metrics: isSet(object.metrics) ? SystemMetrics.fromJSON(object.metrics) : undefined };
  },

  toJSON(message: HeartbeatUpdate): unknown {
    const obj: any = {};
    if (message.metrics !== undefined) {
      obj.metrics = SystemMetrics.toJSON(message.metrics);
    }
    return obj;
  },

  create(base?: DeepPartial<HeartbeatUpdate>): HeartbeatUpdate {
    return HeartbeatUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HeartbeatUpdate>): HeartbeatUpdate {
    const message = createBaseHeartbeatUpdate();
    message.metrics = (object.metrics !== undefined && object.metrics !== null)
      ? SystemMetrics.fromPartial(object.metrics)
      : undefined;
    return message;
  },
};

function createBaseTerminalOutput(): TerminalOutput {
  return { data: Buffer.alloc(0), isStderr: false, sequence: "0" };
}

export const TerminalOutput: MessageFns<TerminalOutput> = {
  encode(message: TerminalOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.isStderr !== false) {
      writer.uint32(16).bool(message.isStderr);
    }
    if (message.sequence !== "0") {
      writer.uint32(24).int64(message.sequence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TerminalOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTerminalOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isStderr = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sequence = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TerminalOutput {
    return {
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      isStderr: isSet(object.isStderr)
        ? globalThis.Boolean(object.isStderr)
        : isSet(object.is_stderr)
        ? globalThis.Boolean(object.is_stderr)
        : false,
      sequence: isSet(object.sequence) ? globalThis.String(object.sequence) : "0",
    };
  },

  toJSON(message: TerminalOutput): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.isStderr !== false) {
      obj.isStderr = message.isStderr;
    }
    if (message.sequence !== "0") {
      obj.sequence = message.sequence;
    }
    return obj;
  },

  create(base?: DeepPartial<TerminalOutput>): TerminalOutput {
    return TerminalOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TerminalOutput>): TerminalOutput {
    const message = createBaseTerminalOutput();
    message.data = object.data ?? Buffer.alloc(0);
    message.isStderr = object.isStderr ?? false;
    message.sequence = object.sequence ?? "0";
    return message;
  },
};

function createBaseCommandComplete(): CommandComplete {
  return { commandId: "", exitCode: 0, durationMs: "0" };
}

export const CommandComplete: MessageFns<CommandComplete> = {
  encode(message: CommandComplete, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commandId !== "") {
      writer.uint32(10).string(message.commandId);
    }
    if (message.exitCode !== 0) {
      writer.uint32(16).int32(message.exitCode);
    }
    if (message.durationMs !== "0") {
      writer.uint32(24).int64(message.durationMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandComplete {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandComplete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.durationMs = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandComplete {
    return {
      commandId: isSet(object.commandId)
        ? globalThis.String(object.commandId)
        : isSet(object.command_id)
        ? globalThis.String(object.command_id)
        : "",
      exitCode: isSet(object.exitCode)
        ? globalThis.Number(object.exitCode)
        : isSet(object.exit_code)
        ? globalThis.Number(object.exit_code)
        : 0,
      durationMs: isSet(object.durationMs)
        ? globalThis.String(object.durationMs)
        : isSet(object.duration_ms)
        ? globalThis.String(object.duration_ms)
        : "0",
    };
  },

  toJSON(message: CommandComplete): unknown {
    const obj: any = {};
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.durationMs !== "0") {
      obj.durationMs = message.durationMs;
    }
    return obj;
  },

  create(base?: DeepPartial<CommandComplete>): CommandComplete {
    return CommandComplete.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommandComplete>): CommandComplete {
    const message = createBaseCommandComplete();
    message.commandId = object.commandId ?? "";
    message.exitCode = object.exitCode ?? 0;
    message.durationMs = object.durationMs ?? "0";
    return message;
  },
};

function createBaseStatusUpdate(): StatusUpdate {
  return { oldStatus: 0, newStatus: 0, reason: "", workingDirectory: "" };
}

export const StatusUpdate: MessageFns<StatusUpdate> = {
  encode(message: StatusUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.oldStatus !== 0) {
      writer.uint32(8).int32(message.oldStatus);
    }
    if (message.newStatus !== 0) {
      writer.uint32(16).int32(message.newStatus);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    if (message.workingDirectory !== "") {
      writer.uint32(34).string(message.workingDirectory);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatusUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.oldStatus = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.newStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.workingDirectory = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusUpdate {
    return {
      oldStatus: isSet(object.oldStatus)
        ? sessionStatusFromJSON(object.oldStatus)
        : isSet(object.old_status)
        ? sessionStatusFromJSON(object.old_status)
        : 0,
      newStatus: isSet(object.newStatus)
        ? sessionStatusFromJSON(object.newStatus)
        : isSet(object.new_status)
        ? sessionStatusFromJSON(object.new_status)
        : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      workingDirectory: isSet(object.workingDirectory)
        ? globalThis.String(object.workingDirectory)
        : isSet(object.working_directory)
        ? globalThis.String(object.working_directory)
        : "",
    };
  },

  toJSON(message: StatusUpdate): unknown {
    const obj: any = {};
    if (message.oldStatus !== 0) {
      obj.oldStatus = sessionStatusToJSON(message.oldStatus);
    }
    if (message.newStatus !== 0) {
      obj.newStatus = sessionStatusToJSON(message.newStatus);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.workingDirectory !== "") {
      obj.workingDirectory = message.workingDirectory;
    }
    return obj;
  },

  create(base?: DeepPartial<StatusUpdate>): StatusUpdate {
    return StatusUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StatusUpdate>): StatusUpdate {
    const message = createBaseStatusUpdate();
    message.oldStatus = object.oldStatus ?? 0;
    message.newStatus = object.newStatus ?? 0;
    message.reason = object.reason ?? "";
    message.workingDirectory = object.workingDirectory ?? "";
    return message;
  },
};

function createBaseErrorReport(): ErrorReport {
  return { errorCode: "", message: "", stackTrace: "", isFatal: false, suggestions: [], canRetry: false };
}

export const ErrorReport: MessageFns<ErrorReport> = {
  encode(message: ErrorReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorCode !== "") {
      writer.uint32(10).string(message.errorCode);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.stackTrace !== "") {
      writer.uint32(26).string(message.stackTrace);
    }
    if (message.isFatal !== false) {
      writer.uint32(32).bool(message.isFatal);
    }
    for (const v of message.suggestions) {
      writer.uint32(42).string(v!);
    }
    if (message.canRetry !== false) {
      writer.uint32(48).bool(message.canRetry);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stackTrace = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isFatal = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.suggestions.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.canRetry = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorReport {
    return {
      errorCode: isSet(object.errorCode)
        ? globalThis.String(object.errorCode)
        : isSet(object.error_code)
        ? globalThis.String(object.error_code)
        : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      stackTrace: isSet(object.stackTrace)
        ? globalThis.String(object.stackTrace)
        : isSet(object.stack_trace)
        ? globalThis.String(object.stack_trace)
        : "",
      isFatal: isSet(object.isFatal)
        ? globalThis.Boolean(object.isFatal)
        : isSet(object.is_fatal)
        ? globalThis.Boolean(object.is_fatal)
        : false,
      suggestions: globalThis.Array.isArray(object?.suggestions)
        ? object.suggestions.map((e: any) => globalThis.String(e))
        : [],
      canRetry: isSet(object.canRetry)
        ? globalThis.Boolean(object.canRetry)
        : isSet(object.can_retry)
        ? globalThis.Boolean(object.can_retry)
        : false,
    };
  },

  toJSON(message: ErrorReport): unknown {
    const obj: any = {};
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.stackTrace !== "") {
      obj.stackTrace = message.stackTrace;
    }
    if (message.isFatal !== false) {
      obj.isFatal = message.isFatal;
    }
    if (message.suggestions?.length) {
      obj.suggestions = message.suggestions;
    }
    if (message.canRetry !== false) {
      obj.canRetry = message.canRetry;
    }
    return obj;
  },

  create(base?: DeepPartial<ErrorReport>): ErrorReport {
    return ErrorReport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ErrorReport>): ErrorReport {
    const message = createBaseErrorReport();
    message.errorCode = object.errorCode ?? "";
    message.message = object.message ?? "";
    message.stackTrace = object.stackTrace ?? "";
    message.isFatal = object.isFatal ?? false;
    message.suggestions = object.suggestions?.map((e) => e) || [];
    message.canRetry = object.canRetry ?? false;
    return message;
  },
};

function createBaseCommandAck(): CommandAck {
  return { commandId: "", success: false, message: "" };
}

export const CommandAck: MessageFns<CommandAck> = {
  encode(message: CommandAck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commandId !== "") {
      writer.uint32(10).string(message.commandId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandAck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandAck {
    return {
      commandId: isSet(object.commandId)
        ? globalThis.String(object.commandId)
        : isSet(object.command_id)
        ? globalThis.String(object.command_id)
        : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: CommandAck): unknown {
    const obj: any = {};
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<CommandAck>): CommandAck {
    return CommandAck.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommandAck>): CommandAck {
    const message = createBaseCommandAck();
    message.commandId = object.commandId ?? "";
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseHistoryResult(): HistoryResult {
  return { commandId: "", commands: [], total: 0, source: "", error: "" };
}

export const HistoryResult: MessageFns<HistoryResult> = {
  encode(message: HistoryResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commandId !== "") {
      writer.uint32(10).string(message.commandId);
    }
    for (const v of message.commands) {
      writer.uint32(18).string(v!);
    }
    if (message.total !== 0) {
      writer.uint32(24).int32(message.total);
    }
    if (message.source !== "") {
      writer.uint32(34).string(message.source);
    }
    if (message.error !== "") {
      writer.uint32(42).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HistoryResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHistoryResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commands.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HistoryResult {
    return {
      commandId: isSet(object.commandId)
        ? globalThis.String(object.commandId)
        : isSet(object.command_id)
        ? globalThis.String(object.command_id)
        : "",
      commands: globalThis.Array.isArray(object?.commands) ? object.commands.map((e: any) => globalThis.String(e)) : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: HistoryResult): unknown {
    const obj: any = {};
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.commands?.length) {
      obj.commands = message.commands;
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<HistoryResult>): HistoryResult {
    return HistoryResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HistoryResult>): HistoryResult {
    const message = createBaseHistoryResult();
    message.commandId = object.commandId ?? "";
    message.commands = object.commands?.map((e) => e) || [];
    message.total = object.total ?? 0;
    message.source = object.source ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBasePermissionStatus(): PermissionStatus {
  return { directories: [], platform: "", checkedAt: "0" };
}

export const PermissionStatus: MessageFns<PermissionStatus> = {
  encode(message: PermissionStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.directories) {
      DirectoryPermission.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.platform !== "") {
      writer.uint32(18).string(message.platform);
    }
    if (message.checkedAt !== "0") {
      writer.uint32(24).int64(message.checkedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PermissionStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.directories.push(DirectoryPermission.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.platform = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.checkedAt = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermissionStatus {
    return {
      directories: globalThis.Array.isArray(object?.directories)
        ? object.directories.map((e: any) => DirectoryPermission.fromJSON(e))
        : [],
      platform: isSet(object.platform) ? globalThis.String(object.platform) : "",
      checkedAt: isSet(object.checkedAt)
        ? globalThis.String(object.checkedAt)
        : isSet(object.checked_at)
        ? globalThis.String(object.checked_at)
        : "0",
    };
  },

  toJSON(message: PermissionStatus): unknown {
    const obj: any = {};
    if (message.directories?.length) {
      obj.directories = message.directories.map((e) => DirectoryPermission.toJSON(e));
    }
    if (message.platform !== "") {
      obj.platform = message.platform;
    }
    if (message.checkedAt !== "0") {
      obj.checkedAt = message.checkedAt;
    }
    return obj;
  },

  create(base?: DeepPartial<PermissionStatus>): PermissionStatus {
    return PermissionStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PermissionStatus>): PermissionStatus {
    const message = createBasePermissionStatus();
    message.directories = object.directories?.map((e) => DirectoryPermission.fromPartial(e)) || [];
    message.platform = object.platform ?? "";
    message.checkedAt = object.checkedAt ?? "0";
    return message;
  },
};

function createBaseDirectoryPermission(): DirectoryPermission {
  return { path: "", status: 0, errorMessage: "", isSensitive: false };
}

export const DirectoryPermission: MessageFns<DirectoryPermission> = {
  encode(message: DirectoryPermission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    if (message.isSensitive !== false) {
      writer.uint32(32).bool(message.isSensitive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DirectoryPermission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDirectoryPermission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isSensitive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DirectoryPermission {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      status: isSet(object.status) ? permissionAccessStatusFromJSON(object.status) : 0,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : "",
      isSensitive: isSet(object.isSensitive)
        ? globalThis.Boolean(object.isSensitive)
        : isSet(object.is_sensitive)
        ? globalThis.Boolean(object.is_sensitive)
        : false,
    };
  },

  toJSON(message: DirectoryPermission): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.status !== 0) {
      obj.status = permissionAccessStatusToJSON(message.status);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.isSensitive !== false) {
      obj.isSensitive = message.isSensitive;
    }
    return obj;
  },

  create(base?: DeepPartial<DirectoryPermission>): DirectoryPermission {
    return DirectoryPermission.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DirectoryPermission>): DirectoryPermission {
    const message = createBaseDirectoryPermission();
    message.path = object.path ?? "";
    message.status = object.status ?? 0;
    message.errorMessage = object.errorMessage ?? "";
    message.isSensitive = object.isSensitive ?? false;
    return message;
  },
};

function createBaseAgentResult(): AgentResult {
  return {
    requestId: "",
    success: false,
    text: "",
    error: "",
    toolResults: [],
    usage: undefined,
    durationMs: "0",
    outputJson: "",
  };
}

export const AgentResult: MessageFns<AgentResult> = {
  encode(message: AgentResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    for (const v of message.toolResults) {
      AgentToolResult.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.usage !== undefined) {
      AgentUsage.encode(message.usage, writer.uint32(50).fork()).join();
    }
    if (message.durationMs !== "0") {
      writer.uint32(56).int64(message.durationMs);
    }
    if (message.outputJson !== "") {
      writer.uint32(66).string(message.outputJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.toolResults.push(AgentToolResult.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.usage = AgentUsage.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.durationMs = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.outputJson = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentResult {
    return {
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      toolResults: globalThis.Array.isArray(object?.toolResults)
        ? object.toolResults.map((e: any) => AgentToolResult.fromJSON(e))
        : globalThis.Array.isArray(object?.tool_results)
        ? object.tool_results.map((e: any) => AgentToolResult.fromJSON(e))
        : [],
      usage: isSet(object.usage) ? AgentUsage.fromJSON(object.usage) : undefined,
      durationMs: isSet(object.durationMs)
        ? globalThis.String(object.durationMs)
        : isSet(object.duration_ms)
        ? globalThis.String(object.duration_ms)
        : "0",
      outputJson: isSet(object.outputJson)
        ? globalThis.String(object.outputJson)
        : isSet(object.output_json)
        ? globalThis.String(object.output_json)
        : "",
    };
  },

  toJSON(message: AgentResult): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.toolResults?.length) {
      obj.toolResults = message.toolResults.map((e) => AgentToolResult.toJSON(e));
    }
    if (message.usage !== undefined) {
      obj.usage = AgentUsage.toJSON(message.usage);
    }
    if (message.durationMs !== "0") {
      obj.durationMs = message.durationMs;
    }
    if (message.outputJson !== "") {
      obj.outputJson = message.outputJson;
    }
    return obj;
  },

  create(base?: DeepPartial<AgentResult>): AgentResult {
    return AgentResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgentResult>): AgentResult {
    const message = createBaseAgentResult();
    message.requestId = object.requestId ?? "";
    message.success = object.success ?? false;
    message.text = object.text ?? "";
    message.error = object.error ?? "";
    message.toolResults = object.toolResults?.map((e) => AgentToolResult.fromPartial(e)) || [];
    message.usage = (object.usage !== undefined && object.usage !== null)
      ? AgentUsage.fromPartial(object.usage)
      : undefined;
    message.durationMs = object.durationMs ?? "0";
    message.outputJson = object.outputJson ?? "";
    return message;
  },
};

function createBaseAgentToolResult(): AgentToolResult {
  return { toolName: "", toolCallId: "", success: false, result: "", error: "", durationMs: "0" };
}

export const AgentToolResult: MessageFns<AgentToolResult> = {
  encode(message: AgentToolResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toolName !== "") {
      writer.uint32(10).string(message.toolName);
    }
    if (message.toolCallId !== "") {
      writer.uint32(18).string(message.toolCallId);
    }
    if (message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    if (message.result !== "") {
      writer.uint32(34).string(message.result);
    }
    if (message.error !== "") {
      writer.uint32(42).string(message.error);
    }
    if (message.durationMs !== "0") {
      writer.uint32(48).int64(message.durationMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentToolResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentToolResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.toolName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toolCallId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.result = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.durationMs = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentToolResult {
    return {
      toolName: isSet(object.toolName)
        ? globalThis.String(object.toolName)
        : isSet(object.tool_name)
        ? globalThis.String(object.tool_name)
        : "",
      toolCallId: isSet(object.toolCallId)
        ? globalThis.String(object.toolCallId)
        : isSet(object.tool_call_id)
        ? globalThis.String(object.tool_call_id)
        : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      result: isSet(object.result) ? globalThis.String(object.result) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      durationMs: isSet(object.durationMs)
        ? globalThis.String(object.durationMs)
        : isSet(object.duration_ms)
        ? globalThis.String(object.duration_ms)
        : "0",
    };
  },

  toJSON(message: AgentToolResult): unknown {
    const obj: any = {};
    if (message.toolName !== "") {
      obj.toolName = message.toolName;
    }
    if (message.toolCallId !== "") {
      obj.toolCallId = message.toolCallId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.result !== "") {
      obj.result = message.result;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.durationMs !== "0") {
      obj.durationMs = message.durationMs;
    }
    return obj;
  },

  create(base?: DeepPartial<AgentToolResult>): AgentToolResult {
    return AgentToolResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgentToolResult>): AgentToolResult {
    const message = createBaseAgentToolResult();
    message.toolName = object.toolName ?? "";
    message.toolCallId = object.toolCallId ?? "";
    message.success = object.success ?? false;
    message.result = object.result ?? "";
    message.error = object.error ?? "";
    message.durationMs = object.durationMs ?? "0";
    return message;
  },
};

function createBaseAgentUsage(): AgentUsage {
  return { promptTokens: 0, completionTokens: 0, totalTokens: 0 };
}

export const AgentUsage: MessageFns<AgentUsage> = {
  encode(message: AgentUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.promptTokens !== 0) {
      writer.uint32(8).int32(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      writer.uint32(16).int32(message.completionTokens);
    }
    if (message.totalTokens !== 0) {
      writer.uint32(24).int32(message.totalTokens);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.promptTokens = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.completionTokens = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalTokens = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentUsage {
    return {
      promptTokens: isSet(object.promptTokens)
        ? globalThis.Number(object.promptTokens)
        : isSet(object.prompt_tokens)
        ? globalThis.Number(object.prompt_tokens)
        : 0,
      completionTokens: isSet(object.completionTokens)
        ? globalThis.Number(object.completionTokens)
        : isSet(object.completion_tokens)
        ? globalThis.Number(object.completion_tokens)
        : 0,
      totalTokens: isSet(object.totalTokens)
        ? globalThis.Number(object.totalTokens)
        : isSet(object.total_tokens)
        ? globalThis.Number(object.total_tokens)
        : 0,
    };
  },

  toJSON(message: AgentUsage): unknown {
    const obj: any = {};
    if (message.promptTokens !== 0) {
      obj.promptTokens = Math.round(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      obj.completionTokens = Math.round(message.completionTokens);
    }
    if (message.totalTokens !== 0) {
      obj.totalTokens = Math.round(message.totalTokens);
    }
    return obj;
  },

  create(base?: DeepPartial<AgentUsage>): AgentUsage {
    return AgentUsage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgentUsage>): AgentUsage {
    const message = createBaseAgentUsage();
    message.promptTokens = object.promptTokens ?? 0;
    message.completionTokens = object.completionTokens ?? 0;
    message.totalTokens = object.totalTokens ?? 0;
    return message;
  },
};

function createBaseAgentStreamEvent(): AgentStreamEvent {
  return { requestId: "", type: 0, payload: "", timestamp: "0" };
}

export const AgentStreamEvent: MessageFns<AgentStreamEvent> = {
  encode(message: AgentStreamEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.payload !== "") {
      writer.uint32(26).string(message.payload);
    }
    if (message.timestamp !== "0") {
      writer.uint32(32).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentStreamEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentStreamEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timestamp = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentStreamEvent {
    return {
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : "",
      type: isSet(object.type) ? agentEventTypeFromJSON(object.type) : 0,
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0",
    };
  },

  toJSON(message: AgentStreamEvent): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.type !== 0) {
      obj.type = agentEventTypeToJSON(message.type);
    }
    if (message.payload !== "") {
      obj.payload = message.payload;
    }
    if (message.timestamp !== "0") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<AgentStreamEvent>): AgentStreamEvent {
    return AgentStreamEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgentStreamEvent>): AgentStreamEvent {
    const message = createBaseAgentStreamEvent();
    message.requestId = object.requestId ?? "";
    message.type = object.type ?? 0;
    message.payload = object.payload ?? "";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseBrowserPageState(): BrowserPageState {
  return { url: "", title: "", content: "", tokenCount: 0, elementCount: 0, isDiff: false, changesCount: 0, links: [] };
}

export const BrowserPageState: MessageFns<BrowserPageState> = {
  encode(message: BrowserPageState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.tokenCount !== 0) {
      writer.uint32(32).int32(message.tokenCount);
    }
    if (message.elementCount !== 0) {
      writer.uint32(40).int32(message.elementCount);
    }
    if (message.isDiff !== false) {
      writer.uint32(48).bool(message.isDiff);
    }
    if (message.changesCount !== 0) {
      writer.uint32(56).int32(message.changesCount);
    }
    for (const v of message.links) {
      BrowserLink.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrowserPageState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrowserPageState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.tokenCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.elementCount = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isDiff = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.changesCount = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.links.push(BrowserLink.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrowserPageState {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      tokenCount: isSet(object.tokenCount)
        ? globalThis.Number(object.tokenCount)
        : isSet(object.token_count)
        ? globalThis.Number(object.token_count)
        : 0,
      elementCount: isSet(object.elementCount)
        ? globalThis.Number(object.elementCount)
        : isSet(object.element_count)
        ? globalThis.Number(object.element_count)
        : 0,
      isDiff: isSet(object.isDiff)
        ? globalThis.Boolean(object.isDiff)
        : isSet(object.is_diff)
        ? globalThis.Boolean(object.is_diff)
        : false,
      changesCount: isSet(object.changesCount)
        ? globalThis.Number(object.changesCount)
        : isSet(object.changes_count)
        ? globalThis.Number(object.changes_count)
        : 0,
      links: globalThis.Array.isArray(object?.links)
        ? object.links.map((e: any) => BrowserLink.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BrowserPageState): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.tokenCount !== 0) {
      obj.tokenCount = Math.round(message.tokenCount);
    }
    if (message.elementCount !== 0) {
      obj.elementCount = Math.round(message.elementCount);
    }
    if (message.isDiff !== false) {
      obj.isDiff = message.isDiff;
    }
    if (message.changesCount !== 0) {
      obj.changesCount = Math.round(message.changesCount);
    }
    if (message.links?.length) {
      obj.links = message.links.map((e) => BrowserLink.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BrowserPageState>): BrowserPageState {
    return BrowserPageState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BrowserPageState>): BrowserPageState {
    const message = createBaseBrowserPageState();
    message.url = object.url ?? "";
    message.title = object.title ?? "";
    message.content = object.content ?? "";
    message.tokenCount = object.tokenCount ?? 0;
    message.elementCount = object.elementCount ?? 0;
    message.isDiff = object.isDiff ?? false;
    message.changesCount = object.changesCount ?? 0;
    message.links = object.links?.map((e) => BrowserLink.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBrowserLink(): BrowserLink {
  return { index: 0, url: "", text: "" };
}

export const BrowserLink: MessageFns<BrowserLink> = {
  encode(message: BrowserLink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrowserLink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrowserLink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrowserLink {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
    };
  },

  toJSON(message: BrowserLink): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create(base?: DeepPartial<BrowserLink>): BrowserLink {
    return BrowserLink.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BrowserLink>): BrowserLink {
    const message = createBaseBrowserLink();
    message.index = object.index ?? 0;
    message.url = object.url ?? "";
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseBrowserNavigateResult(): BrowserNavigateResult {
  return { url: "", fromUrl: "", durationMs: "0", success: false, statusCode: 0, title: "" };
}

export const BrowserNavigateResult: MessageFns<BrowserNavigateResult> = {
  encode(message: BrowserNavigateResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.fromUrl !== "") {
      writer.uint32(18).string(message.fromUrl);
    }
    if (message.durationMs !== "0") {
      writer.uint32(24).int64(message.durationMs);
    }
    if (message.success !== false) {
      writer.uint32(32).bool(message.success);
    }
    if (message.statusCode !== 0) {
      writer.uint32(40).int32(message.statusCode);
    }
    if (message.title !== "") {
      writer.uint32(50).string(message.title);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrowserNavigateResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrowserNavigateResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fromUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.durationMs = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.statusCode = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.title = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrowserNavigateResult {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      fromUrl: isSet(object.fromUrl)
        ? globalThis.String(object.fromUrl)
        : isSet(object.from_url)
        ? globalThis.String(object.from_url)
        : "",
      durationMs: isSet(object.durationMs)
        ? globalThis.String(object.durationMs)
        : isSet(object.duration_ms)
        ? globalThis.String(object.duration_ms)
        : "0",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      statusCode: isSet(object.statusCode)
        ? globalThis.Number(object.statusCode)
        : isSet(object.status_code)
        ? globalThis.Number(object.status_code)
        : 0,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
    };
  },

  toJSON(message: BrowserNavigateResult): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.fromUrl !== "") {
      obj.fromUrl = message.fromUrl;
    }
    if (message.durationMs !== "0") {
      obj.durationMs = message.durationMs;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.statusCode !== 0) {
      obj.statusCode = Math.round(message.statusCode);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    return obj;
  },

  create(base?: DeepPartial<BrowserNavigateResult>): BrowserNavigateResult {
    return BrowserNavigateResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BrowserNavigateResult>): BrowserNavigateResult {
    const message = createBaseBrowserNavigateResult();
    message.url = object.url ?? "";
    message.fromUrl = object.fromUrl ?? "";
    message.durationMs = object.durationMs ?? "0";
    message.success = object.success ?? false;
    message.statusCode = object.statusCode ?? 0;
    message.title = object.title ?? "";
    return message;
  },
};

function createBaseBrowserActionResult(): BrowserActionResult {
  return { action: "", selector: "", text: "", durationMs: "0", success: false, error: "" };
}

export const BrowserActionResult: MessageFns<BrowserActionResult> = {
  encode(message: BrowserActionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== "") {
      writer.uint32(10).string(message.action);
    }
    if (message.selector !== "") {
      writer.uint32(18).string(message.selector);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    if (message.durationMs !== "0") {
      writer.uint32(32).int64(message.durationMs);
    }
    if (message.success !== false) {
      writer.uint32(40).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(50).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrowserActionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrowserActionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.selector = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.durationMs = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrowserActionResult {
    return {
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      selector: isSet(object.selector) ? globalThis.String(object.selector) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      durationMs: isSet(object.durationMs)
        ? globalThis.String(object.durationMs)
        : isSet(object.duration_ms)
        ? globalThis.String(object.duration_ms)
        : "0",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: BrowserActionResult): unknown {
    const obj: any = {};
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.selector !== "") {
      obj.selector = message.selector;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.durationMs !== "0") {
      obj.durationMs = message.durationMs;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<BrowserActionResult>): BrowserActionResult {
    return BrowserActionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BrowserActionResult>): BrowserActionResult {
    const message = createBaseBrowserActionResult();
    message.action = object.action ?? "";
    message.selector = object.selector ?? "";
    message.text = object.text ?? "";
    message.durationMs = object.durationMs ?? "0";
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseBrowserScreenshotResult(): BrowserScreenshotResult {
  return { fullpage: false, selector: "", format: "", sizeBytes: 0, data: Buffer.alloc(0) };
}

export const BrowserScreenshotResult: MessageFns<BrowserScreenshotResult> = {
  encode(message: BrowserScreenshotResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fullpage !== false) {
      writer.uint32(8).bool(message.fullpage);
    }
    if (message.selector !== "") {
      writer.uint32(18).string(message.selector);
    }
    if (message.format !== "") {
      writer.uint32(26).string(message.format);
    }
    if (message.sizeBytes !== 0) {
      writer.uint32(32).int32(message.sizeBytes);
    }
    if (message.data.length !== 0) {
      writer.uint32(42).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrowserScreenshotResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrowserScreenshotResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fullpage = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.selector = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.format = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sizeBytes = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrowserScreenshotResult {
    return {
      fullpage: isSet(object.fullpage) ? globalThis.Boolean(object.fullpage) : false,
      selector: isSet(object.selector) ? globalThis.String(object.selector) : "",
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      sizeBytes: isSet(object.sizeBytes)
        ? globalThis.Number(object.sizeBytes)
        : isSet(object.size_bytes)
        ? globalThis.Number(object.size_bytes)
        : 0,
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
    };
  },

  toJSON(message: BrowserScreenshotResult): unknown {
    const obj: any = {};
    if (message.fullpage !== false) {
      obj.fullpage = message.fullpage;
    }
    if (message.selector !== "") {
      obj.selector = message.selector;
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.sizeBytes !== 0) {
      obj.sizeBytes = Math.round(message.sizeBytes);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<BrowserScreenshotResult>): BrowserScreenshotResult {
    return BrowserScreenshotResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BrowserScreenshotResult>): BrowserScreenshotResult {
    const message = createBaseBrowserScreenshotResult();
    message.fullpage = object.fullpage ?? false;
    message.selector = object.selector ?? "";
    message.format = object.format ?? "";
    message.sizeBytes = object.sizeBytes ?? 0;
    message.data = object.data ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseBrowserDetectionEvent(): BrowserDetectionEvent {
  return { type: "", url: "", confidence: 0, details: "" };
}

export const BrowserDetectionEvent: MessageFns<BrowserDetectionEvent> = {
  encode(message: BrowserDetectionEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.confidence !== 0) {
      writer.uint32(25).double(message.confidence);
    }
    if (message.details !== "") {
      writer.uint32(34).string(message.details);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrowserDetectionEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrowserDetectionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.confidence = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.details = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrowserDetectionEvent {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      details: isSet(object.details) ? globalThis.String(object.details) : "",
    };
  },

  toJSON(message: BrowserDetectionEvent): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    return obj;
  },

  create(base?: DeepPartial<BrowserDetectionEvent>): BrowserDetectionEvent {
    return BrowserDetectionEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BrowserDetectionEvent>): BrowserDetectionEvent {
    const message = createBaseBrowserDetectionEvent();
    message.type = object.type ?? "";
    message.url = object.url ?? "";
    message.confidence = object.confidence ?? 0;
    message.details = object.details ?? "";
    return message;
  },
};

function createBaseBrowserEscalationEvent(): BrowserEscalationEvent {
  return { fromLevel: "", toLevel: "", reason: "", success: false };
}

export const BrowserEscalationEvent: MessageFns<BrowserEscalationEvent> = {
  encode(message: BrowserEscalationEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromLevel !== "") {
      writer.uint32(10).string(message.fromLevel);
    }
    if (message.toLevel !== "") {
      writer.uint32(18).string(message.toLevel);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    if (message.success !== false) {
      writer.uint32(32).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrowserEscalationEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrowserEscalationEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromLevel = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toLevel = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrowserEscalationEvent {
    return {
      fromLevel: isSet(object.fromLevel)
        ? globalThis.String(object.fromLevel)
        : isSet(object.from_level)
        ? globalThis.String(object.from_level)
        : "",
      toLevel: isSet(object.toLevel)
        ? globalThis.String(object.toLevel)
        : isSet(object.to_level)
        ? globalThis.String(object.to_level)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
    };
  },

  toJSON(message: BrowserEscalationEvent): unknown {
    const obj: any = {};
    if (message.fromLevel !== "") {
      obj.fromLevel = message.fromLevel;
    }
    if (message.toLevel !== "") {
      obj.toLevel = message.toLevel;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create(base?: DeepPartial<BrowserEscalationEvent>): BrowserEscalationEvent {
    return BrowserEscalationEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BrowserEscalationEvent>): BrowserEscalationEvent {
    const message = createBaseBrowserEscalationEvent();
    message.fromLevel = object.fromLevel ?? "";
    message.toLevel = object.toLevel ?? "";
    message.reason = object.reason ?? "";
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseBrowserSessionEvent(): BrowserSessionEvent {
  return { sessionId: "", profileId: "", sessionType: "", isStart: false, url: "" };
}

export const BrowserSessionEvent: MessageFns<BrowserSessionEvent> = {
  encode(message: BrowserSessionEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.profileId !== "") {
      writer.uint32(18).string(message.profileId);
    }
    if (message.sessionType !== "") {
      writer.uint32(26).string(message.sessionType);
    }
    if (message.isStart !== false) {
      writer.uint32(32).bool(message.isStart);
    }
    if (message.url !== "") {
      writer.uint32(42).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrowserSessionEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrowserSessionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sessionType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isStart = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrowserSessionEvent {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      profileId: isSet(object.profileId)
        ? globalThis.String(object.profileId)
        : isSet(object.profile_id)
        ? globalThis.String(object.profile_id)
        : "",
      sessionType: isSet(object.sessionType)
        ? globalThis.String(object.sessionType)
        : isSet(object.session_type)
        ? globalThis.String(object.session_type)
        : "",
      isStart: isSet(object.isStart)
        ? globalThis.Boolean(object.isStart)
        : isSet(object.is_start)
        ? globalThis.Boolean(object.is_start)
        : false,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: BrowserSessionEvent): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.profileId !== "") {
      obj.profileId = message.profileId;
    }
    if (message.sessionType !== "") {
      obj.sessionType = message.sessionType;
    }
    if (message.isStart !== false) {
      obj.isStart = message.isStart;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create(base?: DeepPartial<BrowserSessionEvent>): BrowserSessionEvent {
    return BrowserSessionEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BrowserSessionEvent>): BrowserSessionEvent {
    const message = createBaseBrowserSessionEvent();
    message.sessionId = object.sessionId ?? "";
    message.profileId = object.profileId ?? "";
    message.sessionType = object.sessionType ?? "";
    message.isStart = object.isStart ?? false;
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseSkillInfoItem(): SkillInfoItem {
  return {
    name: "",
    description: "",
    author: "",
    version: "",
    model: "",
    origin: "",
    requiredBins: [],
    requiredEnv: [],
  };
}

export const SkillInfoItem: MessageFns<SkillInfoItem> = {
  encode(message: SkillInfoItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.author !== "") {
      writer.uint32(26).string(message.author);
    }
    if (message.version !== "") {
      writer.uint32(34).string(message.version);
    }
    if (message.model !== "") {
      writer.uint32(42).string(message.model);
    }
    if (message.origin !== "") {
      writer.uint32(50).string(message.origin);
    }
    for (const v of message.requiredBins) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.requiredEnv) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillInfoItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillInfoItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.author = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.model = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.origin = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.requiredBins.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.requiredEnv.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillInfoItem {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      author: isSet(object.author) ? globalThis.String(object.author) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      origin: isSet(object.origin) ? globalThis.String(object.origin) : "",
      requiredBins: globalThis.Array.isArray(object?.requiredBins)
        ? object.requiredBins.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.required_bins)
        ? object.required_bins.map((e: any) => globalThis.String(e))
        : [],
      requiredEnv: globalThis.Array.isArray(object?.requiredEnv)
        ? object.requiredEnv.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.required_env)
        ? object.required_env.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SkillInfoItem): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.author !== "") {
      obj.author = message.author;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.origin !== "") {
      obj.origin = message.origin;
    }
    if (message.requiredBins?.length) {
      obj.requiredBins = message.requiredBins;
    }
    if (message.requiredEnv?.length) {
      obj.requiredEnv = message.requiredEnv;
    }
    return obj;
  },

  create(base?: DeepPartial<SkillInfoItem>): SkillInfoItem {
    return SkillInfoItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SkillInfoItem>): SkillInfoItem {
    const message = createBaseSkillInfoItem();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.author = object.author ?? "";
    message.version = object.version ?? "";
    message.model = object.model ?? "";
    message.origin = object.origin ?? "";
    message.requiredBins = object.requiredBins?.map((e) => e) || [];
    message.requiredEnv = object.requiredEnv?.map((e) => e) || [];
    return message;
  },
};

function createBaseSkillListResult(): SkillListResult {
  return { requestId: "", skills: [] };
}

export const SkillListResult: MessageFns<SkillListResult> = {
  encode(message: SkillListResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    for (const v of message.skills) {
      SkillInfoItem.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillListResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillListResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.skills.push(SkillInfoItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillListResult {
    return {
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : "",
      skills: globalThis.Array.isArray(object?.skills) ? object.skills.map((e: any) => SkillInfoItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: SkillListResult): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.skills?.length) {
      obj.skills = message.skills.map((e) => SkillInfoItem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SkillListResult>): SkillListResult {
    return SkillListResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SkillListResult>): SkillListResult {
    const message = createBaseSkillListResult();
    message.requestId = object.requestId ?? "";
    message.skills = object.skills?.map((e) => SkillInfoItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSkillShowResult(): SkillShowResult {
  return { requestId: "", found: false, info: undefined, content: "", source: "", error: "" };
}

export const SkillShowResult: MessageFns<SkillShowResult> = {
  encode(message: SkillShowResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.found !== false) {
      writer.uint32(16).bool(message.found);
    }
    if (message.info !== undefined) {
      SkillInfoItem.encode(message.info, writer.uint32(26).fork()).join();
    }
    if (message.content !== "") {
      writer.uint32(34).string(message.content);
    }
    if (message.source !== "") {
      writer.uint32(42).string(message.source);
    }
    if (message.error !== "") {
      writer.uint32(50).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillShowResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillShowResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.found = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.info = SkillInfoItem.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillShowResult {
    return {
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : "",
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
      info: isSet(object.info) ? SkillInfoItem.fromJSON(object.info) : undefined,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: SkillShowResult): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.found !== false) {
      obj.found = message.found;
    }
    if (message.info !== undefined) {
      obj.info = SkillInfoItem.toJSON(message.info);
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<SkillShowResult>): SkillShowResult {
    return SkillShowResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SkillShowResult>): SkillShowResult {
    const message = createBaseSkillShowResult();
    message.requestId = object.requestId ?? "";
    message.found = object.found ?? false;
    message.info = (object.info !== undefined && object.info !== null)
      ? SkillInfoItem.fromPartial(object.info)
      : undefined;
    message.content = object.content ?? "";
    message.source = object.source ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseSkillRunResult(): SkillRunResult {
  return {
    requestId: "",
    success: false,
    text: "",
    error: "",
    toolResults: [],
    usage: undefined,
    durationMs: "0",
    outputJson: "",
  };
}

export const SkillRunResult: MessageFns<SkillRunResult> = {
  encode(message: SkillRunResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    for (const v of message.toolResults) {
      AgentToolResult.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.usage !== undefined) {
      AgentUsage.encode(message.usage, writer.uint32(50).fork()).join();
    }
    if (message.durationMs !== "0") {
      writer.uint32(56).int64(message.durationMs);
    }
    if (message.outputJson !== "") {
      writer.uint32(66).string(message.outputJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillRunResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillRunResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.toolResults.push(AgentToolResult.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.usage = AgentUsage.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.durationMs = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.outputJson = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillRunResult {
    return {
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      toolResults: globalThis.Array.isArray(object?.toolResults)
        ? object.toolResults.map((e: any) => AgentToolResult.fromJSON(e))
        : globalThis.Array.isArray(object?.tool_results)
        ? object.tool_results.map((e: any) => AgentToolResult.fromJSON(e))
        : [],
      usage: isSet(object.usage) ? AgentUsage.fromJSON(object.usage) : undefined,
      durationMs: isSet(object.durationMs)
        ? globalThis.String(object.durationMs)
        : isSet(object.duration_ms)
        ? globalThis.String(object.duration_ms)
        : "0",
      outputJson: isSet(object.outputJson)
        ? globalThis.String(object.outputJson)
        : isSet(object.output_json)
        ? globalThis.String(object.output_json)
        : "",
    };
  },

  toJSON(message: SkillRunResult): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.toolResults?.length) {
      obj.toolResults = message.toolResults.map((e) => AgentToolResult.toJSON(e));
    }
    if (message.usage !== undefined) {
      obj.usage = AgentUsage.toJSON(message.usage);
    }
    if (message.durationMs !== "0") {
      obj.durationMs = message.durationMs;
    }
    if (message.outputJson !== "") {
      obj.outputJson = message.outputJson;
    }
    return obj;
  },

  create(base?: DeepPartial<SkillRunResult>): SkillRunResult {
    return SkillRunResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SkillRunResult>): SkillRunResult {
    const message = createBaseSkillRunResult();
    message.requestId = object.requestId ?? "";
    message.success = object.success ?? false;
    message.text = object.text ?? "";
    message.error = object.error ?? "";
    message.toolResults = object.toolResults?.map((e) => AgentToolResult.fromPartial(e)) || [];
    message.usage = (object.usage !== undefined && object.usage !== null)
      ? AgentUsage.fromPartial(object.usage)
      : undefined;
    message.durationMs = object.durationMs ?? "0";
    message.outputJson = object.outputJson ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
