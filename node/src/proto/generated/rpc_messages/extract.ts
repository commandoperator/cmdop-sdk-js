// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.4
//   protoc               unknown
// source: rpc_messages/extract.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "terminal";

/** Error codes for extraction failures */
export enum ExtractErrorCode {
  /** EXTRACT_ERROR_NONE - No error */
  EXTRACT_ERROR_NONE = 0,
  /** EXTRACT_ERROR_INVALID_SCHEMA - JSON Schema from SDK is invalid */
  EXTRACT_ERROR_INVALID_SCHEMA = 1,
  /** EXTRACT_ERROR_EXTRACTION_FAILED - Agent couldn't extract data (no data found, access denied, etc.) */
  EXTRACT_ERROR_EXTRACTION_FAILED = 2,
  /** EXTRACT_ERROR_VALIDATION_FAILED - LLM response doesn't match schema after all retries */
  EXTRACT_ERROR_VALIDATION_FAILED = 3,
  /** EXTRACT_ERROR_TIMEOUT - Request timed out */
  EXTRACT_ERROR_TIMEOUT = 4,
  /** EXTRACT_ERROR_LLM_ERROR - LLM API error */
  EXTRACT_ERROR_LLM_ERROR = 5,
  /** EXTRACT_ERROR_TOOL_ERROR - Tool execution error (file read failed, command failed, etc.) */
  EXTRACT_ERROR_TOOL_ERROR = 6,
  /** EXTRACT_ERROR_CANCELLED - Request was cancelled */
  EXTRACT_ERROR_CANCELLED = 7,
  /** EXTRACT_ERROR_SCHEMA_TOO_LARGE - JSON Schema exceeds size limit (64KB) */
  EXTRACT_ERROR_SCHEMA_TOO_LARGE = 8,
  UNRECOGNIZED = -1,
}

export function extractErrorCodeFromJSON(object: any): ExtractErrorCode {
  switch (object) {
    case 0:
    case "EXTRACT_ERROR_NONE":
      return ExtractErrorCode.EXTRACT_ERROR_NONE;
    case 1:
    case "EXTRACT_ERROR_INVALID_SCHEMA":
      return ExtractErrorCode.EXTRACT_ERROR_INVALID_SCHEMA;
    case 2:
    case "EXTRACT_ERROR_EXTRACTION_FAILED":
      return ExtractErrorCode.EXTRACT_ERROR_EXTRACTION_FAILED;
    case 3:
    case "EXTRACT_ERROR_VALIDATION_FAILED":
      return ExtractErrorCode.EXTRACT_ERROR_VALIDATION_FAILED;
    case 4:
    case "EXTRACT_ERROR_TIMEOUT":
      return ExtractErrorCode.EXTRACT_ERROR_TIMEOUT;
    case 5:
    case "EXTRACT_ERROR_LLM_ERROR":
      return ExtractErrorCode.EXTRACT_ERROR_LLM_ERROR;
    case 6:
    case "EXTRACT_ERROR_TOOL_ERROR":
      return ExtractErrorCode.EXTRACT_ERROR_TOOL_ERROR;
    case 7:
    case "EXTRACT_ERROR_CANCELLED":
      return ExtractErrorCode.EXTRACT_ERROR_CANCELLED;
    case 8:
    case "EXTRACT_ERROR_SCHEMA_TOO_LARGE":
      return ExtractErrorCode.EXTRACT_ERROR_SCHEMA_TOO_LARGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExtractErrorCode.UNRECOGNIZED;
  }
}

export function extractErrorCodeToJSON(object: ExtractErrorCode): string {
  switch (object) {
    case ExtractErrorCode.EXTRACT_ERROR_NONE:
      return "EXTRACT_ERROR_NONE";
    case ExtractErrorCode.EXTRACT_ERROR_INVALID_SCHEMA:
      return "EXTRACT_ERROR_INVALID_SCHEMA";
    case ExtractErrorCode.EXTRACT_ERROR_EXTRACTION_FAILED:
      return "EXTRACT_ERROR_EXTRACTION_FAILED";
    case ExtractErrorCode.EXTRACT_ERROR_VALIDATION_FAILED:
      return "EXTRACT_ERROR_VALIDATION_FAILED";
    case ExtractErrorCode.EXTRACT_ERROR_TIMEOUT:
      return "EXTRACT_ERROR_TIMEOUT";
    case ExtractErrorCode.EXTRACT_ERROR_LLM_ERROR:
      return "EXTRACT_ERROR_LLM_ERROR";
    case ExtractErrorCode.EXTRACT_ERROR_TOOL_ERROR:
      return "EXTRACT_ERROR_TOOL_ERROR";
    case ExtractErrorCode.EXTRACT_ERROR_CANCELLED:
      return "EXTRACT_ERROR_CANCELLED";
    case ExtractErrorCode.EXTRACT_ERROR_SCHEMA_TOO_LARGE:
      return "EXTRACT_ERROR_SCHEMA_TOO_LARGE";
    case ExtractErrorCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request for structured data extraction */
export interface ExtractRequest {
  /**
   * User prompt describing what to extract
   * Example: "Find database configuration in config files"
   */
  prompt: string;
  /**
   * JSON Schema for expected output (from Pydantic model.model_json_schema())
   * Defines the structure of the result field in response
   */
  jsonSchema: string;
  /** Optional extraction configuration */
  options: ExtractOptions | undefined;
}

/** Extraction configuration options */
export interface ExtractOptions {
  /**
   * LLM model override (empty = use default)
   * Example: "anthropic/claude-3-5-sonnet", "openai/gpt-4o"
   */
  model: string;
  /**
   * Temperature for LLM (0.0 = deterministic, 2.0 = creative)
   * Default: 0.0 for reliable extraction
   */
  temperature: number;
  /**
   * Maximum tokens for LLM response
   * Default: 4096
   */
  maxTokens: number;
  /**
   * Maximum validation retry attempts on schema mismatch
   * Default: 3
   */
  maxRetries: number;
  /**
   * Request timeout in seconds
   * Default: 60, Max: 300
   */
  timeoutSeconds: number;
  /**
   * Working directory for tool execution
   * Default: agent's current directory
   */
  workingDirectory: string;
  /**
   * Tools to enable for extraction (empty = all available)
   * Available: "execute_command", "read_file", "list_directory", "write_file"
   */
  enabledTools: string[];
}

/** Response from extraction */
export interface ExtractResponse {
  /** Whether extraction succeeded */
  success: boolean;
  /** Error message if !success */
  error: string;
  /** Error code for programmatic handling */
  errorCode: ExtractErrorCode;
  /**
   * Agent's reasoning/explanation of extraction process
   * Example: "Read ~/.config/app.yaml and found database settings..."
   */
  reasoning: string;
  /**
   * Extracted data as JSON string (matches requested json_schema)
   * Only populated if success = true
   */
  resultJson: string;
  /** Execution metrics */
  metrics: ExtractMetrics | undefined;
}

/** Extraction execution metrics */
export interface ExtractMetrics {
  /** Total execution time in milliseconds */
  durationMs: number;
  /** LLM API call time in milliseconds */
  llmDurationMs: number;
  /** Tool execution time in milliseconds */
  toolDurationMs: number;
  /** Number of LLM calls made */
  llmCalls: number;
  /** Number of tool calls made */
  toolCalls: number;
  /** Number of validation retries */
  retries: number;
  /** Token usage */
  tokens: ExtractTokenUsage | undefined;
}

/** Token usage statistics */
export interface ExtractTokenUsage {
  /** Input tokens sent to LLM */
  promptTokens: number;
  /** Output tokens received from LLM */
  completionTokens: number;
  /** Total tokens (prompt + completion) */
  totalTokens: number;
}

function createBaseExtractRequest(): ExtractRequest {
  return { prompt: "", jsonSchema: "", options: undefined };
}

export const ExtractRequest: MessageFns<ExtractRequest> = {
  encode(message: ExtractRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prompt !== "") {
      writer.uint32(10).string(message.prompt);
    }
    if (message.jsonSchema !== "") {
      writer.uint32(18).string(message.jsonSchema);
    }
    if (message.options !== undefined) {
      ExtractOptions.encode(message.options, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtractRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.jsonSchema = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.options = ExtractOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtractRequest {
    return {
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
      jsonSchema: isSet(object.jsonSchema)
        ? globalThis.String(object.jsonSchema)
        : isSet(object.json_schema)
        ? globalThis.String(object.json_schema)
        : "",
      options: isSet(object.options) ? ExtractOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: ExtractRequest): unknown {
    const obj: any = {};
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    if (message.jsonSchema !== "") {
      obj.jsonSchema = message.jsonSchema;
    }
    if (message.options !== undefined) {
      obj.options = ExtractOptions.toJSON(message.options);
    }
    return obj;
  },

  create(base?: DeepPartial<ExtractRequest>): ExtractRequest {
    return ExtractRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExtractRequest>): ExtractRequest {
    const message = createBaseExtractRequest();
    message.prompt = object.prompt ?? "";
    message.jsonSchema = object.jsonSchema ?? "";
    message.options = (object.options !== undefined && object.options !== null)
      ? ExtractOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseExtractOptions(): ExtractOptions {
  return {
    model: "",
    temperature: 0,
    maxTokens: 0,
    maxRetries: 0,
    timeoutSeconds: 0,
    workingDirectory: "",
    enabledTools: [],
  };
}

export const ExtractOptions: MessageFns<ExtractOptions> = {
  encode(message: ExtractOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.model !== "") {
      writer.uint32(10).string(message.model);
    }
    if (message.temperature !== 0) {
      writer.uint32(21).float(message.temperature);
    }
    if (message.maxTokens !== 0) {
      writer.uint32(24).int32(message.maxTokens);
    }
    if (message.maxRetries !== 0) {
      writer.uint32(32).int32(message.maxRetries);
    }
    if (message.timeoutSeconds !== 0) {
      writer.uint32(40).int32(message.timeoutSeconds);
    }
    if (message.workingDirectory !== "") {
      writer.uint32(50).string(message.workingDirectory);
    }
    for (const v of message.enabledTools) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtractOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtractOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.model = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.temperature = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxTokens = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxRetries = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timeoutSeconds = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.workingDirectory = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.enabledTools.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtractOptions {
    return {
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : 0,
      maxTokens: isSet(object.maxTokens)
        ? globalThis.Number(object.maxTokens)
        : isSet(object.max_tokens)
        ? globalThis.Number(object.max_tokens)
        : 0,
      maxRetries: isSet(object.maxRetries)
        ? globalThis.Number(object.maxRetries)
        : isSet(object.max_retries)
        ? globalThis.Number(object.max_retries)
        : 0,
      timeoutSeconds: isSet(object.timeoutSeconds)
        ? globalThis.Number(object.timeoutSeconds)
        : isSet(object.timeout_seconds)
        ? globalThis.Number(object.timeout_seconds)
        : 0,
      workingDirectory: isSet(object.workingDirectory)
        ? globalThis.String(object.workingDirectory)
        : isSet(object.working_directory)
        ? globalThis.String(object.working_directory)
        : "",
      enabledTools: globalThis.Array.isArray(object?.enabledTools)
        ? object.enabledTools.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.enabled_tools)
        ? object.enabled_tools.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ExtractOptions): unknown {
    const obj: any = {};
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.temperature !== 0) {
      obj.temperature = message.temperature;
    }
    if (message.maxTokens !== 0) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.maxRetries !== 0) {
      obj.maxRetries = Math.round(message.maxRetries);
    }
    if (message.timeoutSeconds !== 0) {
      obj.timeoutSeconds = Math.round(message.timeoutSeconds);
    }
    if (message.workingDirectory !== "") {
      obj.workingDirectory = message.workingDirectory;
    }
    if (message.enabledTools?.length) {
      obj.enabledTools = message.enabledTools;
    }
    return obj;
  },

  create(base?: DeepPartial<ExtractOptions>): ExtractOptions {
    return ExtractOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExtractOptions>): ExtractOptions {
    const message = createBaseExtractOptions();
    message.model = object.model ?? "";
    message.temperature = object.temperature ?? 0;
    message.maxTokens = object.maxTokens ?? 0;
    message.maxRetries = object.maxRetries ?? 0;
    message.timeoutSeconds = object.timeoutSeconds ?? 0;
    message.workingDirectory = object.workingDirectory ?? "";
    message.enabledTools = object.enabledTools?.map((e) => e) || [];
    return message;
  },
};

function createBaseExtractResponse(): ExtractResponse {
  return { success: false, error: "", errorCode: 0, reasoning: "", resultJson: "", metrics: undefined };
}

export const ExtractResponse: MessageFns<ExtractResponse> = {
  encode(message: ExtractResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    if (message.errorCode !== 0) {
      writer.uint32(24).int32(message.errorCode);
    }
    if (message.reasoning !== "") {
      writer.uint32(34).string(message.reasoning);
    }
    if (message.resultJson !== "") {
      writer.uint32(42).string(message.resultJson);
    }
    if (message.metrics !== undefined) {
      ExtractMetrics.encode(message.metrics, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtractResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reasoning = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.resultJson = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metrics = ExtractMetrics.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtractResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      errorCode: isSet(object.errorCode)
        ? extractErrorCodeFromJSON(object.errorCode)
        : isSet(object.error_code)
        ? extractErrorCodeFromJSON(object.error_code)
        : 0,
      reasoning: isSet(object.reasoning) ? globalThis.String(object.reasoning) : "",
      resultJson: isSet(object.resultJson)
        ? globalThis.String(object.resultJson)
        : isSet(object.result_json)
        ? globalThis.String(object.result_json)
        : "",
      metrics: isSet(object.metrics) ? ExtractMetrics.fromJSON(object.metrics) : undefined,
    };
  },

  toJSON(message: ExtractResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.errorCode !== 0) {
      obj.errorCode = extractErrorCodeToJSON(message.errorCode);
    }
    if (message.reasoning !== "") {
      obj.reasoning = message.reasoning;
    }
    if (message.resultJson !== "") {
      obj.resultJson = message.resultJson;
    }
    if (message.metrics !== undefined) {
      obj.metrics = ExtractMetrics.toJSON(message.metrics);
    }
    return obj;
  },

  create(base?: DeepPartial<ExtractResponse>): ExtractResponse {
    return ExtractResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExtractResponse>): ExtractResponse {
    const message = createBaseExtractResponse();
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    message.errorCode = object.errorCode ?? 0;
    message.reasoning = object.reasoning ?? "";
    message.resultJson = object.resultJson ?? "";
    message.metrics = (object.metrics !== undefined && object.metrics !== null)
      ? ExtractMetrics.fromPartial(object.metrics)
      : undefined;
    return message;
  },
};

function createBaseExtractMetrics(): ExtractMetrics {
  return {
    durationMs: 0,
    llmDurationMs: 0,
    toolDurationMs: 0,
    llmCalls: 0,
    toolCalls: 0,
    retries: 0,
    tokens: undefined,
  };
}

export const ExtractMetrics: MessageFns<ExtractMetrics> = {
  encode(message: ExtractMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.durationMs !== 0) {
      writer.uint32(8).int32(message.durationMs);
    }
    if (message.llmDurationMs !== 0) {
      writer.uint32(16).int32(message.llmDurationMs);
    }
    if (message.toolDurationMs !== 0) {
      writer.uint32(24).int32(message.toolDurationMs);
    }
    if (message.llmCalls !== 0) {
      writer.uint32(32).int32(message.llmCalls);
    }
    if (message.toolCalls !== 0) {
      writer.uint32(40).int32(message.toolCalls);
    }
    if (message.retries !== 0) {
      writer.uint32(48).int32(message.retries);
    }
    if (message.tokens !== undefined) {
      ExtractTokenUsage.encode(message.tokens, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtractMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtractMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.durationMs = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.llmDurationMs = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.toolDurationMs = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.llmCalls = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.toolCalls = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.retries = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tokens = ExtractTokenUsage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtractMetrics {
    return {
      durationMs: isSet(object.durationMs)
        ? globalThis.Number(object.durationMs)
        : isSet(object.duration_ms)
        ? globalThis.Number(object.duration_ms)
        : 0,
      llmDurationMs: isSet(object.llmDurationMs)
        ? globalThis.Number(object.llmDurationMs)
        : isSet(object.llm_duration_ms)
        ? globalThis.Number(object.llm_duration_ms)
        : 0,
      toolDurationMs: isSet(object.toolDurationMs)
        ? globalThis.Number(object.toolDurationMs)
        : isSet(object.tool_duration_ms)
        ? globalThis.Number(object.tool_duration_ms)
        : 0,
      llmCalls: isSet(object.llmCalls)
        ? globalThis.Number(object.llmCalls)
        : isSet(object.llm_calls)
        ? globalThis.Number(object.llm_calls)
        : 0,
      toolCalls: isSet(object.toolCalls)
        ? globalThis.Number(object.toolCalls)
        : isSet(object.tool_calls)
        ? globalThis.Number(object.tool_calls)
        : 0,
      retries: isSet(object.retries) ? globalThis.Number(object.retries) : 0,
      tokens: isSet(object.tokens) ? ExtractTokenUsage.fromJSON(object.tokens) : undefined,
    };
  },

  toJSON(message: ExtractMetrics): unknown {
    const obj: any = {};
    if (message.durationMs !== 0) {
      obj.durationMs = Math.round(message.durationMs);
    }
    if (message.llmDurationMs !== 0) {
      obj.llmDurationMs = Math.round(message.llmDurationMs);
    }
    if (message.toolDurationMs !== 0) {
      obj.toolDurationMs = Math.round(message.toolDurationMs);
    }
    if (message.llmCalls !== 0) {
      obj.llmCalls = Math.round(message.llmCalls);
    }
    if (message.toolCalls !== 0) {
      obj.toolCalls = Math.round(message.toolCalls);
    }
    if (message.retries !== 0) {
      obj.retries = Math.round(message.retries);
    }
    if (message.tokens !== undefined) {
      obj.tokens = ExtractTokenUsage.toJSON(message.tokens);
    }
    return obj;
  },

  create(base?: DeepPartial<ExtractMetrics>): ExtractMetrics {
    return ExtractMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExtractMetrics>): ExtractMetrics {
    const message = createBaseExtractMetrics();
    message.durationMs = object.durationMs ?? 0;
    message.llmDurationMs = object.llmDurationMs ?? 0;
    message.toolDurationMs = object.toolDurationMs ?? 0;
    message.llmCalls = object.llmCalls ?? 0;
    message.toolCalls = object.toolCalls ?? 0;
    message.retries = object.retries ?? 0;
    message.tokens = (object.tokens !== undefined && object.tokens !== null)
      ? ExtractTokenUsage.fromPartial(object.tokens)
      : undefined;
    return message;
  },
};

function createBaseExtractTokenUsage(): ExtractTokenUsage {
  return { promptTokens: 0, completionTokens: 0, totalTokens: 0 };
}

export const ExtractTokenUsage: MessageFns<ExtractTokenUsage> = {
  encode(message: ExtractTokenUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.promptTokens !== 0) {
      writer.uint32(8).int32(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      writer.uint32(16).int32(message.completionTokens);
    }
    if (message.totalTokens !== 0) {
      writer.uint32(24).int32(message.totalTokens);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtractTokenUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtractTokenUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.promptTokens = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.completionTokens = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalTokens = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtractTokenUsage {
    return {
      promptTokens: isSet(object.promptTokens)
        ? globalThis.Number(object.promptTokens)
        : isSet(object.prompt_tokens)
        ? globalThis.Number(object.prompt_tokens)
        : 0,
      completionTokens: isSet(object.completionTokens)
        ? globalThis.Number(object.completionTokens)
        : isSet(object.completion_tokens)
        ? globalThis.Number(object.completion_tokens)
        : 0,
      totalTokens: isSet(object.totalTokens)
        ? globalThis.Number(object.totalTokens)
        : isSet(object.total_tokens)
        ? globalThis.Number(object.total_tokens)
        : 0,
    };
  },

  toJSON(message: ExtractTokenUsage): unknown {
    const obj: any = {};
    if (message.promptTokens !== 0) {
      obj.promptTokens = Math.round(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      obj.completionTokens = Math.round(message.completionTokens);
    }
    if (message.totalTokens !== 0) {
      obj.totalTokens = Math.round(message.totalTokens);
    }
    return obj;
  },

  create(base?: DeepPartial<ExtractTokenUsage>): ExtractTokenUsage {
    return ExtractTokenUsage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExtractTokenUsage>): ExtractTokenUsage {
    const message = createBaseExtractTokenUsage();
    message.promptTokens = object.promptTokens ?? 0;
    message.completionTokens = object.completionTokens ?? 0;
    message.totalTokens = object.totalTokens ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
