// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: file_operations/transfer.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "terminal";

/** State of streaming relay transfer */
export enum StreamingRelayState {
  RELAY_STATE_UNSPECIFIED = 0,
  RELAY_INITIATED = 1,
  RELAY_STREAMING = 2,
  RELAY_COMPLETED = 3,
  RELAY_FAILED = 4,
  RELAY_CANCELLED = 5,
  UNRECOGNIZED = -1,
}

export function streamingRelayStateFromJSON(object: any): StreamingRelayState {
  switch (object) {
    case 0:
    case "RELAY_STATE_UNSPECIFIED":
      return StreamingRelayState.RELAY_STATE_UNSPECIFIED;
    case 1:
    case "RELAY_INITIATED":
      return StreamingRelayState.RELAY_INITIATED;
    case 2:
    case "RELAY_STREAMING":
      return StreamingRelayState.RELAY_STREAMING;
    case 3:
    case "RELAY_COMPLETED":
      return StreamingRelayState.RELAY_COMPLETED;
    case 4:
    case "RELAY_FAILED":
      return StreamingRelayState.RELAY_FAILED;
    case 5:
    case "RELAY_CANCELLED":
      return StreamingRelayState.RELAY_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StreamingRelayState.UNRECOGNIZED;
  }
}

export function streamingRelayStateToJSON(object: StreamingRelayState): string {
  switch (object) {
    case StreamingRelayState.RELAY_STATE_UNSPECIFIED:
      return "RELAY_STATE_UNSPECIFIED";
    case StreamingRelayState.RELAY_INITIATED:
      return "RELAY_INITIATED";
    case StreamingRelayState.RELAY_STREAMING:
      return "RELAY_STREAMING";
    case StreamingRelayState.RELAY_COMPLETED:
      return "RELAY_COMPLETED";
    case StreamingRelayState.RELAY_FAILED:
      return "RELAY_FAILED";
    case StreamingRelayState.RELAY_CANCELLED:
      return "RELAY_CANCELLED";
    case StreamingRelayState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** File chunk for streaming large files */
export interface FileChunk {
  /** Transfer session ID */
  transferId: string;
  /** 0-based chunk index */
  chunkIndex: number;
  /** Total number of chunks */
  totalChunks: number;
  /** Chunk data (default: 1MB) */
  data: Buffer;
  /** MD5 checksum of chunk data */
  checksum: string;
  /** Byte offset in file */
  offset: string;
  /** True for final chunk */
  isLast: boolean;
}

/** Request to initiate chunked upload (agent -> Django) */
export interface ChunkedUploadRequest {
  /** Terminal session ID */
  sessionId: string;
  /** Unique transfer ID */
  transferId: string;
  /** Source file path */
  path: string;
  /** Total file size in bytes */
  totalSize: string;
  /** Chunk size (default: 1MB) */
  chunkSize: number;
  /** MD5 of entire file */
  fileChecksum: string;
}

/** Response to chunked upload initiation */
export interface ChunkedUploadResponse {
  transferId: string;
  success: boolean;
  error: string;
  expectedChunks: number;
}

/** Request to initiate chunked download (agent <- Django) */
export interface ChunkedDownloadRequest {
  sessionId: string;
  transferId: string;
  /** Destination file path */
  path: string;
  totalSize: string;
  chunkSize: number;
  fileChecksum: string;
}

/** Response to chunked download initiation */
export interface ChunkedDownloadResponse {
  transferId: string;
  success: boolean;
  error: string;
}

/** Progress update for transfers */
export interface TransferProgress {
  transferId: string;
  bytesTransferred: string;
  totalBytes: string;
  percentage: number;
  /** Bytes per second */
  speedBps: number;
  /** Estimated time remaining */
  etaSeconds: number;
}

/** Transfer completion notification */
export interface TransferComplete {
  transferId: string;
  success: boolean;
  error: string;
  chunksTransferred: number;
  bytesTransferred: string;
  /** MD5 of reassembled file */
  finalChecksum: string;
}

/** Request to download from broker (agent <- Django) */
export interface BrokerDownloadRequest {
  /** Broker transfer ID */
  transferId: string;
  /** Where to save on device */
  targetPath: string;
  totalSize: string;
  fileChecksum: string;
  chunkSize: number;
}

/** Agent requests next chunk from broker */
export interface BrokerChunkRequest {
  transferId: string;
  chunkIndex: number;
  chunkSize: number;
}

/** Broker responds with chunk data */
export interface BrokerChunkResponse {
  transferId: string;
  chunkIndex: number;
  data: Buffer;
  checksum: string;
  isLast: boolean;
}

/** Request to initiate streaming relay (source -> Django) */
export interface StreamingRelayRequest {
  /** Unique transfer ID */
  transferId: string;
  /** Source device session */
  sourceSessionId: string;
  /** Target device session(s) - 1 to N */
  targetSessionIds: string[];
  /** File metadata */
  fileName: string;
  /** Path on source device */
  sourcePath: string;
  /** Destination path on targets */
  targetPath: string;
  fileSize: string;
  /** MD5 of entire file */
  fileChecksum: string;
  /** Chunk size (default: 1MB) */
  chunkSize: number;
}

/** Response to streaming relay initiation */
export interface StreamingRelayResponse {
  transferId: string;
  success: boolean;
  error: string;
  totalChunks: number;
  /** Which targets are connected */
  connectedTargets: string[];
  /** Which targets are offline */
  offlineTargets: string[];
}

/** Chunk for streaming relay (source -> Django -> targets) */
export interface StreamingRelayChunk {
  transferId: string;
  /** Who sent this chunk */
  sourceSessionId: string;
  /** Where to relay (can be subset) */
  targetSessionIds: string[];
  chunkIndex: number;
  totalChunks: number;
  data: Buffer;
  /** MD5 of chunk */
  chunkChecksum: string;
  /** Byte offset in file */
  offset: string;
  /** First chunk (contains metadata) */
  isFirst: boolean;
  /** Final chunk */
  isLast: boolean;
}

/** Acknowledgment from target (target -> Django -> source) */
export interface StreamingRelayAck {
  transferId: string;
  /** Which target is acknowledging */
  sessionId: string;
  chunkIndex: number;
  success: boolean;
  error: string;
}

/** Status update for streaming relay (Django -> Centrifugo) */
export interface StreamingRelayStatus {
  transferId: string;
  state: StreamingRelayState;
  /** 0-100% */
  overallProgress: number;
  /** Per-target progress */
  targetProgress: { [key: string]: number };
  /** session_id -> chunks received */
  targetChunksAcked: { [key: string]: number };
  /** Chunks sent by source */
  chunksSent: number;
  totalChunks: number;
  /** Error message if failed */
  error: string;
  /** File metadata */
  fileName: string;
  /** Total file size in bytes */
  fileSize: string;
}

export interface StreamingRelayStatus_TargetProgressEntry {
  key: string;
  value: number;
}

export interface StreamingRelayStatus_TargetChunksAckedEntry {
  key: string;
  value: number;
}

/** Get status of streaming relay */
export interface StreamingRelayStatusRequest {
  transferId: string;
}

/** Cancel streaming relay */
export interface StreamingRelayCancelRequest {
  transferId: string;
  reason: string;
}

export interface StreamingRelayCancelResponse {
  transferId: string;
  success: boolean;
  error: string;
}

function createBaseFileChunk(): FileChunk {
  return {
    transferId: "",
    chunkIndex: 0,
    totalChunks: 0,
    data: Buffer.alloc(0),
    checksum: "",
    offset: "0",
    isLast: false,
  };
}

export const FileChunk: MessageFns<FileChunk> = {
  encode(message: FileChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.chunkIndex !== 0) {
      writer.uint32(16).int32(message.chunkIndex);
    }
    if (message.totalChunks !== 0) {
      writer.uint32(24).int32(message.totalChunks);
    }
    if (message.data.length !== 0) {
      writer.uint32(34).bytes(message.data);
    }
    if (message.checksum !== "") {
      writer.uint32(42).string(message.checksum);
    }
    if (message.offset !== "0") {
      writer.uint32(48).int64(message.offset);
    }
    if (message.isLast !== false) {
      writer.uint32(56).bool(message.isLast);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.chunkIndex = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalChunks = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isLast = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileChunk {
    return {
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : isSet(object.transfer_id)
        ? globalThis.String(object.transfer_id)
        : "",
      chunkIndex: isSet(object.chunkIndex)
        ? globalThis.Number(object.chunkIndex)
        : isSet(object.chunk_index)
        ? globalThis.Number(object.chunk_index)
        : 0,
      totalChunks: isSet(object.totalChunks)
        ? globalThis.Number(object.totalChunks)
        : isSet(object.total_chunks)
        ? globalThis.Number(object.total_chunks)
        : 0,
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
      isLast: isSet(object.isLast)
        ? globalThis.Boolean(object.isLast)
        : isSet(object.is_last)
        ? globalThis.Boolean(object.is_last)
        : false,
    };
  },

  toJSON(message: FileChunk): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.chunkIndex !== 0) {
      obj.chunkIndex = Math.round(message.chunkIndex);
    }
    if (message.totalChunks !== 0) {
      obj.totalChunks = Math.round(message.totalChunks);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (message.offset !== "0") {
      obj.offset = message.offset;
    }
    if (message.isLast !== false) {
      obj.isLast = message.isLast;
    }
    return obj;
  },

  create(base?: DeepPartial<FileChunk>): FileChunk {
    return FileChunk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileChunk>): FileChunk {
    const message = createBaseFileChunk();
    message.transferId = object.transferId ?? "";
    message.chunkIndex = object.chunkIndex ?? 0;
    message.totalChunks = object.totalChunks ?? 0;
    message.data = object.data ?? Buffer.alloc(0);
    message.checksum = object.checksum ?? "";
    message.offset = object.offset ?? "0";
    message.isLast = object.isLast ?? false;
    return message;
  },
};

function createBaseChunkedUploadRequest(): ChunkedUploadRequest {
  return { sessionId: "", transferId: "", path: "", totalSize: "0", chunkSize: 0, fileChecksum: "" };
}

export const ChunkedUploadRequest: MessageFns<ChunkedUploadRequest> = {
  encode(message: ChunkedUploadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.transferId !== "") {
      writer.uint32(18).string(message.transferId);
    }
    if (message.path !== "") {
      writer.uint32(26).string(message.path);
    }
    if (message.totalSize !== "0") {
      writer.uint32(32).int64(message.totalSize);
    }
    if (message.chunkSize !== 0) {
      writer.uint32(40).int32(message.chunkSize);
    }
    if (message.fileChecksum !== "") {
      writer.uint32(50).string(message.fileChecksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChunkedUploadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChunkedUploadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalSize = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.chunkSize = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fileChecksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChunkedUploadRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : isSet(object.transfer_id)
        ? globalThis.String(object.transfer_id)
        : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      totalSize: isSet(object.totalSize)
        ? globalThis.String(object.totalSize)
        : isSet(object.total_size)
        ? globalThis.String(object.total_size)
        : "0",
      chunkSize: isSet(object.chunkSize)
        ? globalThis.Number(object.chunkSize)
        : isSet(object.chunk_size)
        ? globalThis.Number(object.chunk_size)
        : 0,
      fileChecksum: isSet(object.fileChecksum)
        ? globalThis.String(object.fileChecksum)
        : isSet(object.file_checksum)
        ? globalThis.String(object.file_checksum)
        : "",
    };
  },

  toJSON(message: ChunkedUploadRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.totalSize !== "0") {
      obj.totalSize = message.totalSize;
    }
    if (message.chunkSize !== 0) {
      obj.chunkSize = Math.round(message.chunkSize);
    }
    if (message.fileChecksum !== "") {
      obj.fileChecksum = message.fileChecksum;
    }
    return obj;
  },

  create(base?: DeepPartial<ChunkedUploadRequest>): ChunkedUploadRequest {
    return ChunkedUploadRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChunkedUploadRequest>): ChunkedUploadRequest {
    const message = createBaseChunkedUploadRequest();
    message.sessionId = object.sessionId ?? "";
    message.transferId = object.transferId ?? "";
    message.path = object.path ?? "";
    message.totalSize = object.totalSize ?? "0";
    message.chunkSize = object.chunkSize ?? 0;
    message.fileChecksum = object.fileChecksum ?? "";
    return message;
  },
};

function createBaseChunkedUploadResponse(): ChunkedUploadResponse {
  return { transferId: "", success: false, error: "", expectedChunks: 0 };
}

export const ChunkedUploadResponse: MessageFns<ChunkedUploadResponse> = {
  encode(message: ChunkedUploadResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    if (message.expectedChunks !== 0) {
      writer.uint32(32).int32(message.expectedChunks);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChunkedUploadResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChunkedUploadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.expectedChunks = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChunkedUploadResponse {
    return {
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : isSet(object.transfer_id)
        ? globalThis.String(object.transfer_id)
        : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      expectedChunks: isSet(object.expectedChunks)
        ? globalThis.Number(object.expectedChunks)
        : isSet(object.expected_chunks)
        ? globalThis.Number(object.expected_chunks)
        : 0,
    };
  },

  toJSON(message: ChunkedUploadResponse): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.expectedChunks !== 0) {
      obj.expectedChunks = Math.round(message.expectedChunks);
    }
    return obj;
  },

  create(base?: DeepPartial<ChunkedUploadResponse>): ChunkedUploadResponse {
    return ChunkedUploadResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChunkedUploadResponse>): ChunkedUploadResponse {
    const message = createBaseChunkedUploadResponse();
    message.transferId = object.transferId ?? "";
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    message.expectedChunks = object.expectedChunks ?? 0;
    return message;
  },
};

function createBaseChunkedDownloadRequest(): ChunkedDownloadRequest {
  return { sessionId: "", transferId: "", path: "", totalSize: "0", chunkSize: 0, fileChecksum: "" };
}

export const ChunkedDownloadRequest: MessageFns<ChunkedDownloadRequest> = {
  encode(message: ChunkedDownloadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.transferId !== "") {
      writer.uint32(18).string(message.transferId);
    }
    if (message.path !== "") {
      writer.uint32(26).string(message.path);
    }
    if (message.totalSize !== "0") {
      writer.uint32(32).int64(message.totalSize);
    }
    if (message.chunkSize !== 0) {
      writer.uint32(40).int32(message.chunkSize);
    }
    if (message.fileChecksum !== "") {
      writer.uint32(50).string(message.fileChecksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChunkedDownloadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChunkedDownloadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalSize = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.chunkSize = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fileChecksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChunkedDownloadRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : isSet(object.transfer_id)
        ? globalThis.String(object.transfer_id)
        : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      totalSize: isSet(object.totalSize)
        ? globalThis.String(object.totalSize)
        : isSet(object.total_size)
        ? globalThis.String(object.total_size)
        : "0",
      chunkSize: isSet(object.chunkSize)
        ? globalThis.Number(object.chunkSize)
        : isSet(object.chunk_size)
        ? globalThis.Number(object.chunk_size)
        : 0,
      fileChecksum: isSet(object.fileChecksum)
        ? globalThis.String(object.fileChecksum)
        : isSet(object.file_checksum)
        ? globalThis.String(object.file_checksum)
        : "",
    };
  },

  toJSON(message: ChunkedDownloadRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.totalSize !== "0") {
      obj.totalSize = message.totalSize;
    }
    if (message.chunkSize !== 0) {
      obj.chunkSize = Math.round(message.chunkSize);
    }
    if (message.fileChecksum !== "") {
      obj.fileChecksum = message.fileChecksum;
    }
    return obj;
  },

  create(base?: DeepPartial<ChunkedDownloadRequest>): ChunkedDownloadRequest {
    return ChunkedDownloadRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChunkedDownloadRequest>): ChunkedDownloadRequest {
    const message = createBaseChunkedDownloadRequest();
    message.sessionId = object.sessionId ?? "";
    message.transferId = object.transferId ?? "";
    message.path = object.path ?? "";
    message.totalSize = object.totalSize ?? "0";
    message.chunkSize = object.chunkSize ?? 0;
    message.fileChecksum = object.fileChecksum ?? "";
    return message;
  },
};

function createBaseChunkedDownloadResponse(): ChunkedDownloadResponse {
  return { transferId: "", success: false, error: "" };
}

export const ChunkedDownloadResponse: MessageFns<ChunkedDownloadResponse> = {
  encode(message: ChunkedDownloadResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChunkedDownloadResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChunkedDownloadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChunkedDownloadResponse {
    return {
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : isSet(object.transfer_id)
        ? globalThis.String(object.transfer_id)
        : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: ChunkedDownloadResponse): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<ChunkedDownloadResponse>): ChunkedDownloadResponse {
    return ChunkedDownloadResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChunkedDownloadResponse>): ChunkedDownloadResponse {
    const message = createBaseChunkedDownloadResponse();
    message.transferId = object.transferId ?? "";
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseTransferProgress(): TransferProgress {
  return { transferId: "", bytesTransferred: "0", totalBytes: "0", percentage: 0, speedBps: 0, etaSeconds: 0 };
}

export const TransferProgress: MessageFns<TransferProgress> = {
  encode(message: TransferProgress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.bytesTransferred !== "0") {
      writer.uint32(16).int64(message.bytesTransferred);
    }
    if (message.totalBytes !== "0") {
      writer.uint32(24).int64(message.totalBytes);
    }
    if (message.percentage !== 0) {
      writer.uint32(37).float(message.percentage);
    }
    if (message.speedBps !== 0) {
      writer.uint32(45).float(message.speedBps);
    }
    if (message.etaSeconds !== 0) {
      writer.uint32(48).int32(message.etaSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferProgress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bytesTransferred = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalBytes = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.percentage = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.speedBps = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.etaSeconds = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferProgress {
    return {
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : isSet(object.transfer_id)
        ? globalThis.String(object.transfer_id)
        : "",
      bytesTransferred: isSet(object.bytesTransferred)
        ? globalThis.String(object.bytesTransferred)
        : isSet(object.bytes_transferred)
        ? globalThis.String(object.bytes_transferred)
        : "0",
      totalBytes: isSet(object.totalBytes)
        ? globalThis.String(object.totalBytes)
        : isSet(object.total_bytes)
        ? globalThis.String(object.total_bytes)
        : "0",
      percentage: isSet(object.percentage) ? globalThis.Number(object.percentage) : 0,
      speedBps: isSet(object.speedBps)
        ? globalThis.Number(object.speedBps)
        : isSet(object.speed_bps)
        ? globalThis.Number(object.speed_bps)
        : 0,
      etaSeconds: isSet(object.etaSeconds)
        ? globalThis.Number(object.etaSeconds)
        : isSet(object.eta_seconds)
        ? globalThis.Number(object.eta_seconds)
        : 0,
    };
  },

  toJSON(message: TransferProgress): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.bytesTransferred !== "0") {
      obj.bytesTransferred = message.bytesTransferred;
    }
    if (message.totalBytes !== "0") {
      obj.totalBytes = message.totalBytes;
    }
    if (message.percentage !== 0) {
      obj.percentage = message.percentage;
    }
    if (message.speedBps !== 0) {
      obj.speedBps = message.speedBps;
    }
    if (message.etaSeconds !== 0) {
      obj.etaSeconds = Math.round(message.etaSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<TransferProgress>): TransferProgress {
    return TransferProgress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferProgress>): TransferProgress {
    const message = createBaseTransferProgress();
    message.transferId = object.transferId ?? "";
    message.bytesTransferred = object.bytesTransferred ?? "0";
    message.totalBytes = object.totalBytes ?? "0";
    message.percentage = object.percentage ?? 0;
    message.speedBps = object.speedBps ?? 0;
    message.etaSeconds = object.etaSeconds ?? 0;
    return message;
  },
};

function createBaseTransferComplete(): TransferComplete {
  return { transferId: "", success: false, error: "", chunksTransferred: 0, bytesTransferred: "0", finalChecksum: "" };
}

export const TransferComplete: MessageFns<TransferComplete> = {
  encode(message: TransferComplete, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    if (message.chunksTransferred !== 0) {
      writer.uint32(32).int32(message.chunksTransferred);
    }
    if (message.bytesTransferred !== "0") {
      writer.uint32(40).int64(message.bytesTransferred);
    }
    if (message.finalChecksum !== "") {
      writer.uint32(50).string(message.finalChecksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferComplete {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferComplete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.chunksTransferred = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.bytesTransferred = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.finalChecksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferComplete {
    return {
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : isSet(object.transfer_id)
        ? globalThis.String(object.transfer_id)
        : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      chunksTransferred: isSet(object.chunksTransferred)
        ? globalThis.Number(object.chunksTransferred)
        : isSet(object.chunks_transferred)
        ? globalThis.Number(object.chunks_transferred)
        : 0,
      bytesTransferred: isSet(object.bytesTransferred)
        ? globalThis.String(object.bytesTransferred)
        : isSet(object.bytes_transferred)
        ? globalThis.String(object.bytes_transferred)
        : "0",
      finalChecksum: isSet(object.finalChecksum)
        ? globalThis.String(object.finalChecksum)
        : isSet(object.final_checksum)
        ? globalThis.String(object.final_checksum)
        : "",
    };
  },

  toJSON(message: TransferComplete): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.chunksTransferred !== 0) {
      obj.chunksTransferred = Math.round(message.chunksTransferred);
    }
    if (message.bytesTransferred !== "0") {
      obj.bytesTransferred = message.bytesTransferred;
    }
    if (message.finalChecksum !== "") {
      obj.finalChecksum = message.finalChecksum;
    }
    return obj;
  },

  create(base?: DeepPartial<TransferComplete>): TransferComplete {
    return TransferComplete.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferComplete>): TransferComplete {
    const message = createBaseTransferComplete();
    message.transferId = object.transferId ?? "";
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    message.chunksTransferred = object.chunksTransferred ?? 0;
    message.bytesTransferred = object.bytesTransferred ?? "0";
    message.finalChecksum = object.finalChecksum ?? "";
    return message;
  },
};

function createBaseBrokerDownloadRequest(): BrokerDownloadRequest {
  return { transferId: "", targetPath: "", totalSize: "0", fileChecksum: "", chunkSize: 0 };
}

export const BrokerDownloadRequest: MessageFns<BrokerDownloadRequest> = {
  encode(message: BrokerDownloadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.targetPath !== "") {
      writer.uint32(18).string(message.targetPath);
    }
    if (message.totalSize !== "0") {
      writer.uint32(24).int64(message.totalSize);
    }
    if (message.fileChecksum !== "") {
      writer.uint32(34).string(message.fileChecksum);
    }
    if (message.chunkSize !== 0) {
      writer.uint32(40).int32(message.chunkSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrokerDownloadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrokerDownloadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetPath = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fileChecksum = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.chunkSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrokerDownloadRequest {
    return {
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : isSet(object.transfer_id)
        ? globalThis.String(object.transfer_id)
        : "",
      targetPath: isSet(object.targetPath)
        ? globalThis.String(object.targetPath)
        : isSet(object.target_path)
        ? globalThis.String(object.target_path)
        : "",
      totalSize: isSet(object.totalSize)
        ? globalThis.String(object.totalSize)
        : isSet(object.total_size)
        ? globalThis.String(object.total_size)
        : "0",
      fileChecksum: isSet(object.fileChecksum)
        ? globalThis.String(object.fileChecksum)
        : isSet(object.file_checksum)
        ? globalThis.String(object.file_checksum)
        : "",
      chunkSize: isSet(object.chunkSize)
        ? globalThis.Number(object.chunkSize)
        : isSet(object.chunk_size)
        ? globalThis.Number(object.chunk_size)
        : 0,
    };
  },

  toJSON(message: BrokerDownloadRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.targetPath !== "") {
      obj.targetPath = message.targetPath;
    }
    if (message.totalSize !== "0") {
      obj.totalSize = message.totalSize;
    }
    if (message.fileChecksum !== "") {
      obj.fileChecksum = message.fileChecksum;
    }
    if (message.chunkSize !== 0) {
      obj.chunkSize = Math.round(message.chunkSize);
    }
    return obj;
  },

  create(base?: DeepPartial<BrokerDownloadRequest>): BrokerDownloadRequest {
    return BrokerDownloadRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BrokerDownloadRequest>): BrokerDownloadRequest {
    const message = createBaseBrokerDownloadRequest();
    message.transferId = object.transferId ?? "";
    message.targetPath = object.targetPath ?? "";
    message.totalSize = object.totalSize ?? "0";
    message.fileChecksum = object.fileChecksum ?? "";
    message.chunkSize = object.chunkSize ?? 0;
    return message;
  },
};

function createBaseBrokerChunkRequest(): BrokerChunkRequest {
  return { transferId: "", chunkIndex: 0, chunkSize: 0 };
}

export const BrokerChunkRequest: MessageFns<BrokerChunkRequest> = {
  encode(message: BrokerChunkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.chunkIndex !== 0) {
      writer.uint32(16).int32(message.chunkIndex);
    }
    if (message.chunkSize !== 0) {
      writer.uint32(24).int32(message.chunkSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrokerChunkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrokerChunkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.chunkIndex = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.chunkSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrokerChunkRequest {
    return {
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : isSet(object.transfer_id)
        ? globalThis.String(object.transfer_id)
        : "",
      chunkIndex: isSet(object.chunkIndex)
        ? globalThis.Number(object.chunkIndex)
        : isSet(object.chunk_index)
        ? globalThis.Number(object.chunk_index)
        : 0,
      chunkSize: isSet(object.chunkSize)
        ? globalThis.Number(object.chunkSize)
        : isSet(object.chunk_size)
        ? globalThis.Number(object.chunk_size)
        : 0,
    };
  },

  toJSON(message: BrokerChunkRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.chunkIndex !== 0) {
      obj.chunkIndex = Math.round(message.chunkIndex);
    }
    if (message.chunkSize !== 0) {
      obj.chunkSize = Math.round(message.chunkSize);
    }
    return obj;
  },

  create(base?: DeepPartial<BrokerChunkRequest>): BrokerChunkRequest {
    return BrokerChunkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BrokerChunkRequest>): BrokerChunkRequest {
    const message = createBaseBrokerChunkRequest();
    message.transferId = object.transferId ?? "";
    message.chunkIndex = object.chunkIndex ?? 0;
    message.chunkSize = object.chunkSize ?? 0;
    return message;
  },
};

function createBaseBrokerChunkResponse(): BrokerChunkResponse {
  return { transferId: "", chunkIndex: 0, data: Buffer.alloc(0), checksum: "", isLast: false };
}

export const BrokerChunkResponse: MessageFns<BrokerChunkResponse> = {
  encode(message: BrokerChunkResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.chunkIndex !== 0) {
      writer.uint32(16).int32(message.chunkIndex);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (message.checksum !== "") {
      writer.uint32(34).string(message.checksum);
    }
    if (message.isLast !== false) {
      writer.uint32(40).bool(message.isLast);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrokerChunkResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrokerChunkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.chunkIndex = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isLast = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrokerChunkResponse {
    return {
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : isSet(object.transfer_id)
        ? globalThis.String(object.transfer_id)
        : "",
      chunkIndex: isSet(object.chunkIndex)
        ? globalThis.Number(object.chunkIndex)
        : isSet(object.chunk_index)
        ? globalThis.Number(object.chunk_index)
        : 0,
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
      isLast: isSet(object.isLast)
        ? globalThis.Boolean(object.isLast)
        : isSet(object.is_last)
        ? globalThis.Boolean(object.is_last)
        : false,
    };
  },

  toJSON(message: BrokerChunkResponse): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.chunkIndex !== 0) {
      obj.chunkIndex = Math.round(message.chunkIndex);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (message.isLast !== false) {
      obj.isLast = message.isLast;
    }
    return obj;
  },

  create(base?: DeepPartial<BrokerChunkResponse>): BrokerChunkResponse {
    return BrokerChunkResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BrokerChunkResponse>): BrokerChunkResponse {
    const message = createBaseBrokerChunkResponse();
    message.transferId = object.transferId ?? "";
    message.chunkIndex = object.chunkIndex ?? 0;
    message.data = object.data ?? Buffer.alloc(0);
    message.checksum = object.checksum ?? "";
    message.isLast = object.isLast ?? false;
    return message;
  },
};

function createBaseStreamingRelayRequest(): StreamingRelayRequest {
  return {
    transferId: "",
    sourceSessionId: "",
    targetSessionIds: [],
    fileName: "",
    sourcePath: "",
    targetPath: "",
    fileSize: "0",
    fileChecksum: "",
    chunkSize: 0,
  };
}

export const StreamingRelayRequest: MessageFns<StreamingRelayRequest> = {
  encode(message: StreamingRelayRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.sourceSessionId !== "") {
      writer.uint32(18).string(message.sourceSessionId);
    }
    for (const v of message.targetSessionIds) {
      writer.uint32(26).string(v!);
    }
    if (message.fileName !== "") {
      writer.uint32(34).string(message.fileName);
    }
    if (message.sourcePath !== "") {
      writer.uint32(42).string(message.sourcePath);
    }
    if (message.targetPath !== "") {
      writer.uint32(50).string(message.targetPath);
    }
    if (message.fileSize !== "0") {
      writer.uint32(56).int64(message.fileSize);
    }
    if (message.fileChecksum !== "") {
      writer.uint32(66).string(message.fileChecksum);
    }
    if (message.chunkSize !== 0) {
      writer.uint32(72).int32(message.chunkSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingRelayRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingRelayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourceSessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetSessionIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sourcePath = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.targetPath = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.fileSize = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.fileChecksum = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.chunkSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingRelayRequest {
    return {
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : isSet(object.transfer_id)
        ? globalThis.String(object.transfer_id)
        : "",
      sourceSessionId: isSet(object.sourceSessionId)
        ? globalThis.String(object.sourceSessionId)
        : isSet(object.source_session_id)
        ? globalThis.String(object.source_session_id)
        : "",
      targetSessionIds: globalThis.Array.isArray(object?.targetSessionIds)
        ? object.targetSessionIds.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.target_session_ids)
        ? object.target_session_ids.map((e: any) => globalThis.String(e))
        : [],
      fileName: isSet(object.fileName)
        ? globalThis.String(object.fileName)
        : isSet(object.file_name)
        ? globalThis.String(object.file_name)
        : "",
      sourcePath: isSet(object.sourcePath)
        ? globalThis.String(object.sourcePath)
        : isSet(object.source_path)
        ? globalThis.String(object.source_path)
        : "",
      targetPath: isSet(object.targetPath)
        ? globalThis.String(object.targetPath)
        : isSet(object.target_path)
        ? globalThis.String(object.target_path)
        : "",
      fileSize: isSet(object.fileSize)
        ? globalThis.String(object.fileSize)
        : isSet(object.file_size)
        ? globalThis.String(object.file_size)
        : "0",
      fileChecksum: isSet(object.fileChecksum)
        ? globalThis.String(object.fileChecksum)
        : isSet(object.file_checksum)
        ? globalThis.String(object.file_checksum)
        : "",
      chunkSize: isSet(object.chunkSize)
        ? globalThis.Number(object.chunkSize)
        : isSet(object.chunk_size)
        ? globalThis.Number(object.chunk_size)
        : 0,
    };
  },

  toJSON(message: StreamingRelayRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.sourceSessionId !== "") {
      obj.sourceSessionId = message.sourceSessionId;
    }
    if (message.targetSessionIds?.length) {
      obj.targetSessionIds = message.targetSessionIds;
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.sourcePath !== "") {
      obj.sourcePath = message.sourcePath;
    }
    if (message.targetPath !== "") {
      obj.targetPath = message.targetPath;
    }
    if (message.fileSize !== "0") {
      obj.fileSize = message.fileSize;
    }
    if (message.fileChecksum !== "") {
      obj.fileChecksum = message.fileChecksum;
    }
    if (message.chunkSize !== 0) {
      obj.chunkSize = Math.round(message.chunkSize);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingRelayRequest>): StreamingRelayRequest {
    return StreamingRelayRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingRelayRequest>): StreamingRelayRequest {
    const message = createBaseStreamingRelayRequest();
    message.transferId = object.transferId ?? "";
    message.sourceSessionId = object.sourceSessionId ?? "";
    message.targetSessionIds = object.targetSessionIds?.map((e) => e) || [];
    message.fileName = object.fileName ?? "";
    message.sourcePath = object.sourcePath ?? "";
    message.targetPath = object.targetPath ?? "";
    message.fileSize = object.fileSize ?? "0";
    message.fileChecksum = object.fileChecksum ?? "";
    message.chunkSize = object.chunkSize ?? 0;
    return message;
  },
};

function createBaseStreamingRelayResponse(): StreamingRelayResponse {
  return { transferId: "", success: false, error: "", totalChunks: 0, connectedTargets: [], offlineTargets: [] };
}

export const StreamingRelayResponse: MessageFns<StreamingRelayResponse> = {
  encode(message: StreamingRelayResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    if (message.totalChunks !== 0) {
      writer.uint32(32).int32(message.totalChunks);
    }
    for (const v of message.connectedTargets) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.offlineTargets) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingRelayResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingRelayResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalChunks = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.connectedTargets.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.offlineTargets.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingRelayResponse {
    return {
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : isSet(object.transfer_id)
        ? globalThis.String(object.transfer_id)
        : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      totalChunks: isSet(object.totalChunks)
        ? globalThis.Number(object.totalChunks)
        : isSet(object.total_chunks)
        ? globalThis.Number(object.total_chunks)
        : 0,
      connectedTargets: globalThis.Array.isArray(object?.connectedTargets)
        ? object.connectedTargets.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.connected_targets)
        ? object.connected_targets.map((e: any) => globalThis.String(e))
        : [],
      offlineTargets: globalThis.Array.isArray(object?.offlineTargets)
        ? object.offlineTargets.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.offline_targets)
        ? object.offline_targets.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: StreamingRelayResponse): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.totalChunks !== 0) {
      obj.totalChunks = Math.round(message.totalChunks);
    }
    if (message.connectedTargets?.length) {
      obj.connectedTargets = message.connectedTargets;
    }
    if (message.offlineTargets?.length) {
      obj.offlineTargets = message.offlineTargets;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingRelayResponse>): StreamingRelayResponse {
    return StreamingRelayResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingRelayResponse>): StreamingRelayResponse {
    const message = createBaseStreamingRelayResponse();
    message.transferId = object.transferId ?? "";
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    message.totalChunks = object.totalChunks ?? 0;
    message.connectedTargets = object.connectedTargets?.map((e) => e) || [];
    message.offlineTargets = object.offlineTargets?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamingRelayChunk(): StreamingRelayChunk {
  return {
    transferId: "",
    sourceSessionId: "",
    targetSessionIds: [],
    chunkIndex: 0,
    totalChunks: 0,
    data: Buffer.alloc(0),
    chunkChecksum: "",
    offset: "0",
    isFirst: false,
    isLast: false,
  };
}

export const StreamingRelayChunk: MessageFns<StreamingRelayChunk> = {
  encode(message: StreamingRelayChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.sourceSessionId !== "") {
      writer.uint32(18).string(message.sourceSessionId);
    }
    for (const v of message.targetSessionIds) {
      writer.uint32(26).string(v!);
    }
    if (message.chunkIndex !== 0) {
      writer.uint32(32).int32(message.chunkIndex);
    }
    if (message.totalChunks !== 0) {
      writer.uint32(40).int32(message.totalChunks);
    }
    if (message.data.length !== 0) {
      writer.uint32(50).bytes(message.data);
    }
    if (message.chunkChecksum !== "") {
      writer.uint32(58).string(message.chunkChecksum);
    }
    if (message.offset !== "0") {
      writer.uint32(64).int64(message.offset);
    }
    if (message.isFirst !== false) {
      writer.uint32(72).bool(message.isFirst);
    }
    if (message.isLast !== false) {
      writer.uint32(80).bool(message.isLast);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingRelayChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingRelayChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourceSessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetSessionIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.chunkIndex = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalChunks = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.chunkChecksum = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isFirst = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isLast = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingRelayChunk {
    return {
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : isSet(object.transfer_id)
        ? globalThis.String(object.transfer_id)
        : "",
      sourceSessionId: isSet(object.sourceSessionId)
        ? globalThis.String(object.sourceSessionId)
        : isSet(object.source_session_id)
        ? globalThis.String(object.source_session_id)
        : "",
      targetSessionIds: globalThis.Array.isArray(object?.targetSessionIds)
        ? object.targetSessionIds.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.target_session_ids)
        ? object.target_session_ids.map((e: any) => globalThis.String(e))
        : [],
      chunkIndex: isSet(object.chunkIndex)
        ? globalThis.Number(object.chunkIndex)
        : isSet(object.chunk_index)
        ? globalThis.Number(object.chunk_index)
        : 0,
      totalChunks: isSet(object.totalChunks)
        ? globalThis.Number(object.totalChunks)
        : isSet(object.total_chunks)
        ? globalThis.Number(object.total_chunks)
        : 0,
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      chunkChecksum: isSet(object.chunkChecksum)
        ? globalThis.String(object.chunkChecksum)
        : isSet(object.chunk_checksum)
        ? globalThis.String(object.chunk_checksum)
        : "",
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
      isFirst: isSet(object.isFirst)
        ? globalThis.Boolean(object.isFirst)
        : isSet(object.is_first)
        ? globalThis.Boolean(object.is_first)
        : false,
      isLast: isSet(object.isLast)
        ? globalThis.Boolean(object.isLast)
        : isSet(object.is_last)
        ? globalThis.Boolean(object.is_last)
        : false,
    };
  },

  toJSON(message: StreamingRelayChunk): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.sourceSessionId !== "") {
      obj.sourceSessionId = message.sourceSessionId;
    }
    if (message.targetSessionIds?.length) {
      obj.targetSessionIds = message.targetSessionIds;
    }
    if (message.chunkIndex !== 0) {
      obj.chunkIndex = Math.round(message.chunkIndex);
    }
    if (message.totalChunks !== 0) {
      obj.totalChunks = Math.round(message.totalChunks);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.chunkChecksum !== "") {
      obj.chunkChecksum = message.chunkChecksum;
    }
    if (message.offset !== "0") {
      obj.offset = message.offset;
    }
    if (message.isFirst !== false) {
      obj.isFirst = message.isFirst;
    }
    if (message.isLast !== false) {
      obj.isLast = message.isLast;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingRelayChunk>): StreamingRelayChunk {
    return StreamingRelayChunk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingRelayChunk>): StreamingRelayChunk {
    const message = createBaseStreamingRelayChunk();
    message.transferId = object.transferId ?? "";
    message.sourceSessionId = object.sourceSessionId ?? "";
    message.targetSessionIds = object.targetSessionIds?.map((e) => e) || [];
    message.chunkIndex = object.chunkIndex ?? 0;
    message.totalChunks = object.totalChunks ?? 0;
    message.data = object.data ?? Buffer.alloc(0);
    message.chunkChecksum = object.chunkChecksum ?? "";
    message.offset = object.offset ?? "0";
    message.isFirst = object.isFirst ?? false;
    message.isLast = object.isLast ?? false;
    return message;
  },
};

function createBaseStreamingRelayAck(): StreamingRelayAck {
  return { transferId: "", sessionId: "", chunkIndex: 0, success: false, error: "" };
}

export const StreamingRelayAck: MessageFns<StreamingRelayAck> = {
  encode(message: StreamingRelayAck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.chunkIndex !== 0) {
      writer.uint32(24).int32(message.chunkIndex);
    }
    if (message.success !== false) {
      writer.uint32(32).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(42).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingRelayAck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingRelayAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.chunkIndex = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingRelayAck {
    return {
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : isSet(object.transfer_id)
        ? globalThis.String(object.transfer_id)
        : "",
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      chunkIndex: isSet(object.chunkIndex)
        ? globalThis.Number(object.chunkIndex)
        : isSet(object.chunk_index)
        ? globalThis.Number(object.chunk_index)
        : 0,
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: StreamingRelayAck): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.chunkIndex !== 0) {
      obj.chunkIndex = Math.round(message.chunkIndex);
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingRelayAck>): StreamingRelayAck {
    return StreamingRelayAck.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingRelayAck>): StreamingRelayAck {
    const message = createBaseStreamingRelayAck();
    message.transferId = object.transferId ?? "";
    message.sessionId = object.sessionId ?? "";
    message.chunkIndex = object.chunkIndex ?? 0;
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseStreamingRelayStatus(): StreamingRelayStatus {
  return {
    transferId: "",
    state: 0,
    overallProgress: 0,
    targetProgress: {},
    targetChunksAcked: {},
    chunksSent: 0,
    totalChunks: 0,
    error: "",
    fileName: "",
    fileSize: "0",
  };
}

export const StreamingRelayStatus: MessageFns<StreamingRelayStatus> = {
  encode(message: StreamingRelayStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.overallProgress !== 0) {
      writer.uint32(29).float(message.overallProgress);
    }
    globalThis.Object.entries(message.targetProgress).forEach(([key, value]: [string, number]) => {
      StreamingRelayStatus_TargetProgressEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    globalThis.Object.entries(message.targetChunksAcked).forEach(([key, value]: [string, number]) => {
      StreamingRelayStatus_TargetChunksAckedEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.chunksSent !== 0) {
      writer.uint32(48).int32(message.chunksSent);
    }
    if (message.totalChunks !== 0) {
      writer.uint32(56).int32(message.totalChunks);
    }
    if (message.error !== "") {
      writer.uint32(66).string(message.error);
    }
    if (message.fileName !== "") {
      writer.uint32(74).string(message.fileName);
    }
    if (message.fileSize !== "0") {
      writer.uint32(80).int64(message.fileSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingRelayStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingRelayStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.overallProgress = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = StreamingRelayStatus_TargetProgressEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.targetProgress[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = StreamingRelayStatus_TargetChunksAckedEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.targetChunksAcked[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.chunksSent = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalChunks = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.fileSize = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingRelayStatus {
    return {
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : isSet(object.transfer_id)
        ? globalThis.String(object.transfer_id)
        : "",
      state: isSet(object.state) ? streamingRelayStateFromJSON(object.state) : 0,
      overallProgress: isSet(object.overallProgress)
        ? globalThis.Number(object.overallProgress)
        : isSet(object.overall_progress)
        ? globalThis.Number(object.overall_progress)
        : 0,
      targetProgress: isObject(object.targetProgress)
        ? (globalThis.Object.entries(object.targetProgress) as [string, any][]).reduce(
          (acc: { [key: string]: number }, [key, value]: [string, any]) => {
            acc[key] = globalThis.Number(value);
            return acc;
          },
          {},
        )
        : isObject(object.target_progress)
        ? (globalThis.Object.entries(object.target_progress) as [string, any][]).reduce(
          (acc: { [key: string]: number }, [key, value]: [string, any]) => {
            acc[key] = globalThis.Number(value);
            return acc;
          },
          {},
        )
        : {},
      targetChunksAcked: isObject(object.targetChunksAcked)
        ? (globalThis.Object.entries(object.targetChunksAcked) as [string, any][]).reduce(
          (acc: { [key: string]: number }, [key, value]: [string, any]) => {
            acc[key] = globalThis.Number(value);
            return acc;
          },
          {},
        )
        : isObject(object.target_chunks_acked)
        ? (globalThis.Object.entries(object.target_chunks_acked) as [string, any][]).reduce(
          (acc: { [key: string]: number }, [key, value]: [string, any]) => {
            acc[key] = globalThis.Number(value);
            return acc;
          },
          {},
        )
        : {},
      chunksSent: isSet(object.chunksSent)
        ? globalThis.Number(object.chunksSent)
        : isSet(object.chunks_sent)
        ? globalThis.Number(object.chunks_sent)
        : 0,
      totalChunks: isSet(object.totalChunks)
        ? globalThis.Number(object.totalChunks)
        : isSet(object.total_chunks)
        ? globalThis.Number(object.total_chunks)
        : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      fileName: isSet(object.fileName)
        ? globalThis.String(object.fileName)
        : isSet(object.file_name)
        ? globalThis.String(object.file_name)
        : "",
      fileSize: isSet(object.fileSize)
        ? globalThis.String(object.fileSize)
        : isSet(object.file_size)
        ? globalThis.String(object.file_size)
        : "0",
    };
  },

  toJSON(message: StreamingRelayStatus): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.state !== 0) {
      obj.state = streamingRelayStateToJSON(message.state);
    }
    if (message.overallProgress !== 0) {
      obj.overallProgress = message.overallProgress;
    }
    if (message.targetProgress) {
      const entries = globalThis.Object.entries(message.targetProgress) as [string, number][];
      if (entries.length > 0) {
        obj.targetProgress = {};
        entries.forEach(([k, v]) => {
          obj.targetProgress[k] = v;
        });
      }
    }
    if (message.targetChunksAcked) {
      const entries = globalThis.Object.entries(message.targetChunksAcked) as [string, number][];
      if (entries.length > 0) {
        obj.targetChunksAcked = {};
        entries.forEach(([k, v]) => {
          obj.targetChunksAcked[k] = Math.round(v);
        });
      }
    }
    if (message.chunksSent !== 0) {
      obj.chunksSent = Math.round(message.chunksSent);
    }
    if (message.totalChunks !== 0) {
      obj.totalChunks = Math.round(message.totalChunks);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.fileSize !== "0") {
      obj.fileSize = message.fileSize;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingRelayStatus>): StreamingRelayStatus {
    return StreamingRelayStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingRelayStatus>): StreamingRelayStatus {
    const message = createBaseStreamingRelayStatus();
    message.transferId = object.transferId ?? "";
    message.state = object.state ?? 0;
    message.overallProgress = object.overallProgress ?? 0;
    message.targetProgress = (globalThis.Object.entries(object.targetProgress ?? {}) as [string, number][]).reduce(
      (acc: { [key: string]: number }, [key, value]: [string, number]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    message.targetChunksAcked = (globalThis.Object.entries(object.targetChunksAcked ?? {}) as [string, number][])
      .reduce((acc: { [key: string]: number }, [key, value]: [string, number]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      }, {});
    message.chunksSent = object.chunksSent ?? 0;
    message.totalChunks = object.totalChunks ?? 0;
    message.error = object.error ?? "";
    message.fileName = object.fileName ?? "";
    message.fileSize = object.fileSize ?? "0";
    return message;
  },
};

function createBaseStreamingRelayStatus_TargetProgressEntry(): StreamingRelayStatus_TargetProgressEntry {
  return { key: "", value: 0 };
}

export const StreamingRelayStatus_TargetProgressEntry: MessageFns<StreamingRelayStatus_TargetProgressEntry> = {
  encode(message: StreamingRelayStatus_TargetProgressEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingRelayStatus_TargetProgressEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingRelayStatus_TargetProgressEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingRelayStatus_TargetProgressEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: StreamingRelayStatus_TargetProgressEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingRelayStatus_TargetProgressEntry>): StreamingRelayStatus_TargetProgressEntry {
    return StreamingRelayStatus_TargetProgressEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingRelayStatus_TargetProgressEntry>): StreamingRelayStatus_TargetProgressEntry {
    const message = createBaseStreamingRelayStatus_TargetProgressEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseStreamingRelayStatus_TargetChunksAckedEntry(): StreamingRelayStatus_TargetChunksAckedEntry {
  return { key: "", value: 0 };
}

export const StreamingRelayStatus_TargetChunksAckedEntry: MessageFns<StreamingRelayStatus_TargetChunksAckedEntry> = {
  encode(
    message: StreamingRelayStatus_TargetChunksAckedEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingRelayStatus_TargetChunksAckedEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingRelayStatus_TargetChunksAckedEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingRelayStatus_TargetChunksAckedEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: StreamingRelayStatus_TargetChunksAckedEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingRelayStatus_TargetChunksAckedEntry>): StreamingRelayStatus_TargetChunksAckedEntry {
    return StreamingRelayStatus_TargetChunksAckedEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<StreamingRelayStatus_TargetChunksAckedEntry>,
  ): StreamingRelayStatus_TargetChunksAckedEntry {
    const message = createBaseStreamingRelayStatus_TargetChunksAckedEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseStreamingRelayStatusRequest(): StreamingRelayStatusRequest {
  return { transferId: "" };
}

export const StreamingRelayStatusRequest: MessageFns<StreamingRelayStatusRequest> = {
  encode(message: StreamingRelayStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingRelayStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingRelayStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingRelayStatusRequest {
    return {
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : isSet(object.transfer_id)
        ? globalThis.String(object.transfer_id)
        : "",
    };
  },

  toJSON(message: StreamingRelayStatusRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingRelayStatusRequest>): StreamingRelayStatusRequest {
    return StreamingRelayStatusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingRelayStatusRequest>): StreamingRelayStatusRequest {
    const message = createBaseStreamingRelayStatusRequest();
    message.transferId = object.transferId ?? "";
    return message;
  },
};

function createBaseStreamingRelayCancelRequest(): StreamingRelayCancelRequest {
  return { transferId: "", reason: "" };
}

export const StreamingRelayCancelRequest: MessageFns<StreamingRelayCancelRequest> = {
  encode(message: StreamingRelayCancelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingRelayCancelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingRelayCancelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingRelayCancelRequest {
    return {
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : isSet(object.transfer_id)
        ? globalThis.String(object.transfer_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: StreamingRelayCancelRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingRelayCancelRequest>): StreamingRelayCancelRequest {
    return StreamingRelayCancelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingRelayCancelRequest>): StreamingRelayCancelRequest {
    const message = createBaseStreamingRelayCancelRequest();
    message.transferId = object.transferId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseStreamingRelayCancelResponse(): StreamingRelayCancelResponse {
  return { transferId: "", success: false, error: "" };
}

export const StreamingRelayCancelResponse: MessageFns<StreamingRelayCancelResponse> = {
  encode(message: StreamingRelayCancelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingRelayCancelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingRelayCancelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingRelayCancelResponse {
    return {
      transferId: isSet(object.transferId)
        ? globalThis.String(object.transferId)
        : isSet(object.transfer_id)
        ? globalThis.String(object.transfer_id)
        : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: StreamingRelayCancelResponse): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingRelayCancelResponse>): StreamingRelayCancelResponse {
    return StreamingRelayCancelResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingRelayCancelResponse>): StreamingRelayCancelResponse {
    const message = createBaseStreamingRelayCancelResponse();
    message.transferId = object.transferId ?? "";
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
