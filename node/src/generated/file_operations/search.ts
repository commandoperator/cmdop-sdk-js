// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: file_operations/search.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { FileVisibilityMode, fileVisibilityModeFromJSON, fileVisibilityModeToJSON, StreamFileEntry } from "./common";

export const protobufPackage = "terminal";

/** Type of search match */
export enum SearchMatchType {
  MATCH_TYPE_UNSPECIFIED = 0,
  /** MATCH_FILENAME - Matched by glob pattern */
  MATCH_FILENAME = 1,
  /** MATCH_CONTENT - Matched by content grep */
  MATCH_CONTENT = 2,
  UNRECOGNIZED = -1,
}

export function searchMatchTypeFromJSON(object: any): SearchMatchType {
  switch (object) {
    case 0:
    case "MATCH_TYPE_UNSPECIFIED":
      return SearchMatchType.MATCH_TYPE_UNSPECIFIED;
    case 1:
    case "MATCH_FILENAME":
      return SearchMatchType.MATCH_FILENAME;
    case 2:
    case "MATCH_CONTENT":
      return SearchMatchType.MATCH_CONTENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchMatchType.UNRECOGNIZED;
  }
}

export function searchMatchTypeToJSON(object: SearchMatchType): string {
  switch (object) {
    case SearchMatchType.MATCH_TYPE_UNSPECIFIED:
      return "MATCH_TYPE_UNSPECIFIED";
    case SearchMatchType.MATCH_FILENAME:
      return "MATCH_FILENAME";
    case SearchMatchType.MATCH_CONTENT:
      return "MATCH_CONTENT";
    case SearchMatchType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** File search request - combines glob (filename) and grep (content) */
export interface FileSearchRequest {
  /** Base directory to search */
  path: string;
  /** Glob pattern for filenames (e.g., "*.ts", "** /*.go") */
  filenamePattern: string;
  /** Regex pattern for file content */
  contentPattern: string;
  /** Case sensitivity for content search */
  caseSensitive: boolean;
  /** DEPRECATED: Use visibility_mode instead */
  includeHidden: boolean;
  /** Maximum results (default: 100) */
  maxResults: number;
  /** Maximum directory depth (0 = unlimited) */
  maxDepth: number;
  /** Lines of context around matches (default: 0) */
  contextLines: number;
  /** Smart visibility control (v2.10.0) */
  visibilityMode: FileVisibilityMode;
}

/** Individual search match */
export interface FileSearchMatch {
  /** File info */
  entry:
    | StreamFileEntry
    | undefined;
  /** How file was matched */
  matchType: SearchMatchType;
  /** Content matches (if content_pattern used) */
  contentMatches: ContentMatch[];
}

/** Content match with context */
export interface ContentMatch {
  /** 1-based line number */
  lineNumber: number;
  /** Matching line content */
  line: string;
  /** Match start position in line */
  columnStart: number;
  /** Match end position in line */
  columnEnd: number;
  /** Lines before match */
  contextBefore: string[];
  /** Lines after match */
  contextAfter: string[];
}

/** File search result */
export interface FileSearchResult {
  /** Matched files */
  matches: FileSearchMatch[];
  /** Total matches found */
  totalMatches: number;
  /** True if results were truncated */
  truncated: boolean;
  /** Actual search path used */
  searchPath: string;
  /** Number of files scanned */
  filesScanned: string;
  /** Search duration in milliseconds */
  durationMs: string;
}

function createBaseFileSearchRequest(): FileSearchRequest {
  return {
    path: "",
    filenamePattern: "",
    contentPattern: "",
    caseSensitive: false,
    includeHidden: false,
    maxResults: 0,
    maxDepth: 0,
    contextLines: 0,
    visibilityMode: 0,
  };
}

export const FileSearchRequest: MessageFns<FileSearchRequest> = {
  encode(message: FileSearchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.filenamePattern !== "") {
      writer.uint32(18).string(message.filenamePattern);
    }
    if (message.contentPattern !== "") {
      writer.uint32(26).string(message.contentPattern);
    }
    if (message.caseSensitive !== false) {
      writer.uint32(32).bool(message.caseSensitive);
    }
    if (message.includeHidden !== false) {
      writer.uint32(40).bool(message.includeHidden);
    }
    if (message.maxResults !== 0) {
      writer.uint32(48).int32(message.maxResults);
    }
    if (message.maxDepth !== 0) {
      writer.uint32(56).int32(message.maxDepth);
    }
    if (message.contextLines !== 0) {
      writer.uint32(64).int32(message.contextLines);
    }
    if (message.visibilityMode !== 0) {
      writer.uint32(72).int32(message.visibilityMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileSearchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filenamePattern = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contentPattern = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.caseSensitive = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.includeHidden = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.maxResults = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.maxDepth = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.contextLines = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.visibilityMode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileSearchRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      filenamePattern: isSet(object.filenamePattern)
        ? globalThis.String(object.filenamePattern)
        : isSet(object.filename_pattern)
        ? globalThis.String(object.filename_pattern)
        : "",
      contentPattern: isSet(object.contentPattern)
        ? globalThis.String(object.contentPattern)
        : isSet(object.content_pattern)
        ? globalThis.String(object.content_pattern)
        : "",
      caseSensitive: isSet(object.caseSensitive)
        ? globalThis.Boolean(object.caseSensitive)
        : isSet(object.case_sensitive)
        ? globalThis.Boolean(object.case_sensitive)
        : false,
      includeHidden: isSet(object.includeHidden)
        ? globalThis.Boolean(object.includeHidden)
        : isSet(object.include_hidden)
        ? globalThis.Boolean(object.include_hidden)
        : false,
      maxResults: isSet(object.maxResults)
        ? globalThis.Number(object.maxResults)
        : isSet(object.max_results)
        ? globalThis.Number(object.max_results)
        : 0,
      maxDepth: isSet(object.maxDepth)
        ? globalThis.Number(object.maxDepth)
        : isSet(object.max_depth)
        ? globalThis.Number(object.max_depth)
        : 0,
      contextLines: isSet(object.contextLines)
        ? globalThis.Number(object.contextLines)
        : isSet(object.context_lines)
        ? globalThis.Number(object.context_lines)
        : 0,
      visibilityMode: isSet(object.visibilityMode)
        ? fileVisibilityModeFromJSON(object.visibilityMode)
        : isSet(object.visibility_mode)
        ? fileVisibilityModeFromJSON(object.visibility_mode)
        : 0,
    };
  },

  toJSON(message: FileSearchRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.filenamePattern !== "") {
      obj.filenamePattern = message.filenamePattern;
    }
    if (message.contentPattern !== "") {
      obj.contentPattern = message.contentPattern;
    }
    if (message.caseSensitive !== false) {
      obj.caseSensitive = message.caseSensitive;
    }
    if (message.includeHidden !== false) {
      obj.includeHidden = message.includeHidden;
    }
    if (message.maxResults !== 0) {
      obj.maxResults = Math.round(message.maxResults);
    }
    if (message.maxDepth !== 0) {
      obj.maxDepth = Math.round(message.maxDepth);
    }
    if (message.contextLines !== 0) {
      obj.contextLines = Math.round(message.contextLines);
    }
    if (message.visibilityMode !== 0) {
      obj.visibilityMode = fileVisibilityModeToJSON(message.visibilityMode);
    }
    return obj;
  },

  create(base?: DeepPartial<FileSearchRequest>): FileSearchRequest {
    return FileSearchRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileSearchRequest>): FileSearchRequest {
    const message = createBaseFileSearchRequest();
    message.path = object.path ?? "";
    message.filenamePattern = object.filenamePattern ?? "";
    message.contentPattern = object.contentPattern ?? "";
    message.caseSensitive = object.caseSensitive ?? false;
    message.includeHidden = object.includeHidden ?? false;
    message.maxResults = object.maxResults ?? 0;
    message.maxDepth = object.maxDepth ?? 0;
    message.contextLines = object.contextLines ?? 0;
    message.visibilityMode = object.visibilityMode ?? 0;
    return message;
  },
};

function createBaseFileSearchMatch(): FileSearchMatch {
  return { entry: undefined, matchType: 0, contentMatches: [] };
}

export const FileSearchMatch: MessageFns<FileSearchMatch> = {
  encode(message: FileSearchMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entry !== undefined) {
      StreamFileEntry.encode(message.entry, writer.uint32(10).fork()).join();
    }
    if (message.matchType !== 0) {
      writer.uint32(16).int32(message.matchType);
    }
    for (const v of message.contentMatches) {
      ContentMatch.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileSearchMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileSearchMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entry = StreamFileEntry.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.matchType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contentMatches.push(ContentMatch.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileSearchMatch {
    return {
      entry: isSet(object.entry) ? StreamFileEntry.fromJSON(object.entry) : undefined,
      matchType: isSet(object.matchType)
        ? searchMatchTypeFromJSON(object.matchType)
        : isSet(object.match_type)
        ? searchMatchTypeFromJSON(object.match_type)
        : 0,
      contentMatches: globalThis.Array.isArray(object?.contentMatches)
        ? object.contentMatches.map((e: any) => ContentMatch.fromJSON(e))
        : globalThis.Array.isArray(object?.content_matches)
        ? object.content_matches.map((e: any) => ContentMatch.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FileSearchMatch): unknown {
    const obj: any = {};
    if (message.entry !== undefined) {
      obj.entry = StreamFileEntry.toJSON(message.entry);
    }
    if (message.matchType !== 0) {
      obj.matchType = searchMatchTypeToJSON(message.matchType);
    }
    if (message.contentMatches?.length) {
      obj.contentMatches = message.contentMatches.map((e) => ContentMatch.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FileSearchMatch>): FileSearchMatch {
    return FileSearchMatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileSearchMatch>): FileSearchMatch {
    const message = createBaseFileSearchMatch();
    message.entry = (object.entry !== undefined && object.entry !== null)
      ? StreamFileEntry.fromPartial(object.entry)
      : undefined;
    message.matchType = object.matchType ?? 0;
    message.contentMatches = object.contentMatches?.map((e) => ContentMatch.fromPartial(e)) || [];
    return message;
  },
};

function createBaseContentMatch(): ContentMatch {
  return { lineNumber: 0, line: "", columnStart: 0, columnEnd: 0, contextBefore: [], contextAfter: [] };
}

export const ContentMatch: MessageFns<ContentMatch> = {
  encode(message: ContentMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lineNumber !== 0) {
      writer.uint32(8).int32(message.lineNumber);
    }
    if (message.line !== "") {
      writer.uint32(18).string(message.line);
    }
    if (message.columnStart !== 0) {
      writer.uint32(24).int32(message.columnStart);
    }
    if (message.columnEnd !== 0) {
      writer.uint32(32).int32(message.columnEnd);
    }
    for (const v of message.contextBefore) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.contextAfter) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContentMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContentMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.lineNumber = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.line = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.columnStart = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.columnEnd = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contextBefore.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.contextAfter.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContentMatch {
    return {
      lineNumber: isSet(object.lineNumber)
        ? globalThis.Number(object.lineNumber)
        : isSet(object.line_number)
        ? globalThis.Number(object.line_number)
        : 0,
      line: isSet(object.line) ? globalThis.String(object.line) : "",
      columnStart: isSet(object.columnStart)
        ? globalThis.Number(object.columnStart)
        : isSet(object.column_start)
        ? globalThis.Number(object.column_start)
        : 0,
      columnEnd: isSet(object.columnEnd)
        ? globalThis.Number(object.columnEnd)
        : isSet(object.column_end)
        ? globalThis.Number(object.column_end)
        : 0,
      contextBefore: globalThis.Array.isArray(object?.contextBefore)
        ? object.contextBefore.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.context_before)
        ? object.context_before.map((e: any) => globalThis.String(e))
        : [],
      contextAfter: globalThis.Array.isArray(object?.contextAfter)
        ? object.contextAfter.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.context_after)
        ? object.context_after.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ContentMatch): unknown {
    const obj: any = {};
    if (message.lineNumber !== 0) {
      obj.lineNumber = Math.round(message.lineNumber);
    }
    if (message.line !== "") {
      obj.line = message.line;
    }
    if (message.columnStart !== 0) {
      obj.columnStart = Math.round(message.columnStart);
    }
    if (message.columnEnd !== 0) {
      obj.columnEnd = Math.round(message.columnEnd);
    }
    if (message.contextBefore?.length) {
      obj.contextBefore = message.contextBefore;
    }
    if (message.contextAfter?.length) {
      obj.contextAfter = message.contextAfter;
    }
    return obj;
  },

  create(base?: DeepPartial<ContentMatch>): ContentMatch {
    return ContentMatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContentMatch>): ContentMatch {
    const message = createBaseContentMatch();
    message.lineNumber = object.lineNumber ?? 0;
    message.line = object.line ?? "";
    message.columnStart = object.columnStart ?? 0;
    message.columnEnd = object.columnEnd ?? 0;
    message.contextBefore = object.contextBefore?.map((e) => e) || [];
    message.contextAfter = object.contextAfter?.map((e) => e) || [];
    return message;
  },
};

function createBaseFileSearchResult(): FileSearchResult {
  return { matches: [], totalMatches: 0, truncated: false, searchPath: "", filesScanned: "0", durationMs: "0" };
}

export const FileSearchResult: MessageFns<FileSearchResult> = {
  encode(message: FileSearchResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matches) {
      FileSearchMatch.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalMatches !== 0) {
      writer.uint32(16).int32(message.totalMatches);
    }
    if (message.truncated !== false) {
      writer.uint32(24).bool(message.truncated);
    }
    if (message.searchPath !== "") {
      writer.uint32(34).string(message.searchPath);
    }
    if (message.filesScanned !== "0") {
      writer.uint32(40).int64(message.filesScanned);
    }
    if (message.durationMs !== "0") {
      writer.uint32(48).int64(message.durationMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileSearchResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileSearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matches.push(FileSearchMatch.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalMatches = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.truncated = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.searchPath = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.filesScanned = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.durationMs = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileSearchResult {
    return {
      matches: globalThis.Array.isArray(object?.matches)
        ? object.matches.map((e: any) => FileSearchMatch.fromJSON(e))
        : [],
      totalMatches: isSet(object.totalMatches)
        ? globalThis.Number(object.totalMatches)
        : isSet(object.total_matches)
        ? globalThis.Number(object.total_matches)
        : 0,
      truncated: isSet(object.truncated) ? globalThis.Boolean(object.truncated) : false,
      searchPath: isSet(object.searchPath)
        ? globalThis.String(object.searchPath)
        : isSet(object.search_path)
        ? globalThis.String(object.search_path)
        : "",
      filesScanned: isSet(object.filesScanned)
        ? globalThis.String(object.filesScanned)
        : isSet(object.files_scanned)
        ? globalThis.String(object.files_scanned)
        : "0",
      durationMs: isSet(object.durationMs)
        ? globalThis.String(object.durationMs)
        : isSet(object.duration_ms)
        ? globalThis.String(object.duration_ms)
        : "0",
    };
  },

  toJSON(message: FileSearchResult): unknown {
    const obj: any = {};
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => FileSearchMatch.toJSON(e));
    }
    if (message.totalMatches !== 0) {
      obj.totalMatches = Math.round(message.totalMatches);
    }
    if (message.truncated !== false) {
      obj.truncated = message.truncated;
    }
    if (message.searchPath !== "") {
      obj.searchPath = message.searchPath;
    }
    if (message.filesScanned !== "0") {
      obj.filesScanned = message.filesScanned;
    }
    if (message.durationMs !== "0") {
      obj.durationMs = message.durationMs;
    }
    return obj;
  },

  create(base?: DeepPartial<FileSearchResult>): FileSearchResult {
    return FileSearchResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileSearchResult>): FileSearchResult {
    const message = createBaseFileSearchResult();
    message.matches = object.matches?.map((e) => FileSearchMatch.fromPartial(e)) || [];
    message.totalMatches = object.totalMatches ?? 0;
    message.truncated = object.truncated ?? false;
    message.searchPath = object.searchPath ?? "";
    message.filesScanned = object.filesScanned ?? "0";
    message.durationMs = object.durationMs ?? "0";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
