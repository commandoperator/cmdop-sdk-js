// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: file_operations/changes.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { StreamFileEntry } from "./common";

export const protobufPackage = "terminal";

/** Change type for file system operations */
export enum FileChangeType {
  FILE_CHANGE_UNSPECIFIED = 0,
  /** FILE_CHANGE_CREATE - File or directory created */
  FILE_CHANGE_CREATE = 1,
  /** FILE_CHANGE_MODIFY - File content or metadata modified */
  FILE_CHANGE_MODIFY = 2,
  /** FILE_CHANGE_DELETE - File or directory deleted */
  FILE_CHANGE_DELETE = 3,
  /** FILE_CHANGE_MOVE - File or directory moved/renamed */
  FILE_CHANGE_MOVE = 4,
  UNRECOGNIZED = -1,
}

export function fileChangeTypeFromJSON(object: any): FileChangeType {
  switch (object) {
    case 0:
    case "FILE_CHANGE_UNSPECIFIED":
      return FileChangeType.FILE_CHANGE_UNSPECIFIED;
    case 1:
    case "FILE_CHANGE_CREATE":
      return FileChangeType.FILE_CHANGE_CREATE;
    case 2:
    case "FILE_CHANGE_MODIFY":
      return FileChangeType.FILE_CHANGE_MODIFY;
    case 3:
    case "FILE_CHANGE_DELETE":
      return FileChangeType.FILE_CHANGE_DELETE;
    case 4:
    case "FILE_CHANGE_MOVE":
      return FileChangeType.FILE_CHANGE_MOVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FileChangeType.UNRECOGNIZED;
  }
}

export function fileChangeTypeToJSON(object: FileChangeType): string {
  switch (object) {
    case FileChangeType.FILE_CHANGE_UNSPECIFIED:
      return "FILE_CHANGE_UNSPECIFIED";
    case FileChangeType.FILE_CHANGE_CREATE:
      return "FILE_CHANGE_CREATE";
    case FileChangeType.FILE_CHANGE_MODIFY:
      return "FILE_CHANGE_MODIFY";
    case FileChangeType.FILE_CHANGE_DELETE:
      return "FILE_CHANGE_DELETE";
    case FileChangeType.FILE_CHANGE_MOVE:
      return "FILE_CHANGE_MOVE";
    case FileChangeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A single file change event */
export interface FileChange {
  changeType: FileChangeType;
  /** The file/directory affected (null for delete) */
  item:
    | StreamFileEntry
    | undefined;
  /** Previous path (only for move operations) */
  oldPath: string;
}

/** Request for getting file changes since a sequence number */
export interface FileGetChangesRequest {
  /** Fetch changes since this sequence (0 for full sync) */
  sinceSequence: string;
  /** Optional: filter to specific directory path */
  path: string;
  /** Max changes to return (default: 100, max: 500) */
  limit: number;
  /** Pagination cursor from previous response */
  cursor: string;
}

/** Response with file changes for incremental sync */
export interface FileGetChangesResult {
  changes: FileChange[];
  /** Current sequence number to use as next anchor */
  currentSequence: string;
  /** Unix timestamp for clock drift detection */
  serverTimestamp: number;
  /** True if more changes available */
  hasMore: boolean;
  /** Cursor for next page (if has_more is true) */
  nextCursor: string;
  /** Hash of current state for corruption detection */
  stateDigest: string;
}

function createBaseFileChange(): FileChange {
  return { changeType: 0, item: undefined, oldPath: "" };
}

export const FileChange: MessageFns<FileChange> = {
  encode(message: FileChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.changeType !== 0) {
      writer.uint32(8).int32(message.changeType);
    }
    if (message.item !== undefined) {
      StreamFileEntry.encode(message.item, writer.uint32(18).fork()).join();
    }
    if (message.oldPath !== "") {
      writer.uint32(26).string(message.oldPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.changeType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.item = StreamFileEntry.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.oldPath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileChange {
    return {
      changeType: isSet(object.changeType)
        ? fileChangeTypeFromJSON(object.changeType)
        : isSet(object.change_type)
        ? fileChangeTypeFromJSON(object.change_type)
        : 0,
      item: isSet(object.item) ? StreamFileEntry.fromJSON(object.item) : undefined,
      oldPath: isSet(object.oldPath)
        ? globalThis.String(object.oldPath)
        : isSet(object.old_path)
        ? globalThis.String(object.old_path)
        : "",
    };
  },

  toJSON(message: FileChange): unknown {
    const obj: any = {};
    if (message.changeType !== 0) {
      obj.changeType = fileChangeTypeToJSON(message.changeType);
    }
    if (message.item !== undefined) {
      obj.item = StreamFileEntry.toJSON(message.item);
    }
    if (message.oldPath !== "") {
      obj.oldPath = message.oldPath;
    }
    return obj;
  },

  create(base?: DeepPartial<FileChange>): FileChange {
    return FileChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileChange>): FileChange {
    const message = createBaseFileChange();
    message.changeType = object.changeType ?? 0;
    message.item = (object.item !== undefined && object.item !== null)
      ? StreamFileEntry.fromPartial(object.item)
      : undefined;
    message.oldPath = object.oldPath ?? "";
    return message;
  },
};

function createBaseFileGetChangesRequest(): FileGetChangesRequest {
  return { sinceSequence: "0", path: "", limit: 0, cursor: "" };
}

export const FileGetChangesRequest: MessageFns<FileGetChangesRequest> = {
  encode(message: FileGetChangesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sinceSequence !== "0") {
      writer.uint32(8).int64(message.sinceSequence);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.cursor !== "") {
      writer.uint32(34).string(message.cursor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileGetChangesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileGetChangesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sinceSequence = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cursor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileGetChangesRequest {
    return {
      sinceSequence: isSet(object.sinceSequence)
        ? globalThis.String(object.sinceSequence)
        : isSet(object.since_sequence)
        ? globalThis.String(object.since_sequence)
        : "0",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
    };
  },

  toJSON(message: FileGetChangesRequest): unknown {
    const obj: any = {};
    if (message.sinceSequence !== "0") {
      obj.sinceSequence = message.sinceSequence;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    return obj;
  },

  create(base?: DeepPartial<FileGetChangesRequest>): FileGetChangesRequest {
    return FileGetChangesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileGetChangesRequest>): FileGetChangesRequest {
    const message = createBaseFileGetChangesRequest();
    message.sinceSequence = object.sinceSequence ?? "0";
    message.path = object.path ?? "";
    message.limit = object.limit ?? 0;
    message.cursor = object.cursor ?? "";
    return message;
  },
};

function createBaseFileGetChangesResult(): FileGetChangesResult {
  return { changes: [], currentSequence: "0", serverTimestamp: 0, hasMore: false, nextCursor: "", stateDigest: "" };
}

export const FileGetChangesResult: MessageFns<FileGetChangesResult> = {
  encode(message: FileGetChangesResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.changes) {
      FileChange.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.currentSequence !== "0") {
      writer.uint32(16).int64(message.currentSequence);
    }
    if (message.serverTimestamp !== 0) {
      writer.uint32(25).double(message.serverTimestamp);
    }
    if (message.hasMore !== false) {
      writer.uint32(32).bool(message.hasMore);
    }
    if (message.nextCursor !== "") {
      writer.uint32(42).string(message.nextCursor);
    }
    if (message.stateDigest !== "") {
      writer.uint32(50).string(message.stateDigest);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileGetChangesResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileGetChangesResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.changes.push(FileChange.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.currentSequence = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.serverTimestamp = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.hasMore = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nextCursor = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.stateDigest = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileGetChangesResult {
    return {
      changes: globalThis.Array.isArray(object?.changes) ? object.changes.map((e: any) => FileChange.fromJSON(e)) : [],
      currentSequence: isSet(object.currentSequence)
        ? globalThis.String(object.currentSequence)
        : isSet(object.current_sequence)
        ? globalThis.String(object.current_sequence)
        : "0",
      serverTimestamp: isSet(object.serverTimestamp)
        ? globalThis.Number(object.serverTimestamp)
        : isSet(object.server_timestamp)
        ? globalThis.Number(object.server_timestamp)
        : 0,
      hasMore: isSet(object.hasMore)
        ? globalThis.Boolean(object.hasMore)
        : isSet(object.has_more)
        ? globalThis.Boolean(object.has_more)
        : false,
      nextCursor: isSet(object.nextCursor)
        ? globalThis.String(object.nextCursor)
        : isSet(object.next_cursor)
        ? globalThis.String(object.next_cursor)
        : "",
      stateDigest: isSet(object.stateDigest)
        ? globalThis.String(object.stateDigest)
        : isSet(object.state_digest)
        ? globalThis.String(object.state_digest)
        : "",
    };
  },

  toJSON(message: FileGetChangesResult): unknown {
    const obj: any = {};
    if (message.changes?.length) {
      obj.changes = message.changes.map((e) => FileChange.toJSON(e));
    }
    if (message.currentSequence !== "0") {
      obj.currentSequence = message.currentSequence;
    }
    if (message.serverTimestamp !== 0) {
      obj.serverTimestamp = message.serverTimestamp;
    }
    if (message.hasMore !== false) {
      obj.hasMore = message.hasMore;
    }
    if (message.nextCursor !== "") {
      obj.nextCursor = message.nextCursor;
    }
    if (message.stateDigest !== "") {
      obj.stateDigest = message.stateDigest;
    }
    return obj;
  },

  create(base?: DeepPartial<FileGetChangesResult>): FileGetChangesResult {
    return FileGetChangesResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileGetChangesResult>): FileGetChangesResult {
    const message = createBaseFileGetChangesResult();
    message.changes = object.changes?.map((e) => FileChange.fromPartial(e)) || [];
    message.currentSequence = object.currentSequence ?? "0";
    message.serverTimestamp = object.serverTimestamp ?? 0;
    message.hasMore = object.hasMore ?? false;
    message.nextCursor = object.nextCursor ?? "";
    message.stateDigest = object.stateDigest ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
