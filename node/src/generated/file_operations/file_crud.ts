// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: file_operations/file_crud.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { StreamFileEntry, ViewerType, viewerTypeFromJSON, viewerTypeToJSON } from "./common";

export const protobufPackage = "terminal";

export interface FileReadRequest {
  path: string;
  /** Start offset */
  offset: string;
  /** 0 = entire file */
  length: string;
  /** Transcode video to H.264+AAC (v2.9.0) */
  transcode: boolean;
}

export interface FileReadResult {
  /** File content (for small files) */
  content: Buffer;
  /** utf-8, binary */
  encoding: string;
  totalSize: string;
  mimeType: string;
  /** True if content was truncated */
  isTruncated: boolean;
  /** Viewer type for preview (added in v2.4.0) */
  viewerType: ViewerType;
  /** True if content is transcoded (v2.9.0) */
  isTranscoded: boolean;
  /** True if transcoding is finished (v2.9.0) */
  transcodeComplete: boolean;
}

export interface FileWriteRequest {
  path: string;
  content: Buffer;
  overwrite: boolean;
  createParents: boolean;
}

export interface FileWriteResult {
  bytesWritten: string;
  entry: StreamFileEntry | undefined;
}

export interface FileDeleteRequest {
  path: string;
  /** For directories */
  recursive: boolean;
}

export interface FileDeleteResult {
  deletedPath: string;
  filesDeleted: number;
  dirsDeleted: number;
}

export interface FileMoveRequest {
  sourcePath: string;
  destinationPath: string;
  overwrite: boolean;
}

export interface FileMoveResult {
  entry: StreamFileEntry | undefined;
}

export interface FileCopyRequest {
  sourcePath: string;
  destinationPath: string;
  overwrite: boolean;
  recursive: boolean;
}

export interface FileCopyResult {
  entry: StreamFileEntry | undefined;
  bytesCopied: string;
}

export interface FileGetInfoRequest {
  path: string;
}

export interface FileGetInfoResult {
  entry: StreamFileEntry | undefined;
}

function createBaseFileReadRequest(): FileReadRequest {
  return { path: "", offset: "0", length: "0", transcode: false };
}

export const FileReadRequest: MessageFns<FileReadRequest> = {
  encode(message: FileReadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.offset !== "0") {
      writer.uint32(16).int64(message.offset);
    }
    if (message.length !== "0") {
      writer.uint32(24).int64(message.length);
    }
    if (message.transcode !== false) {
      writer.uint32(32).bool(message.transcode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileReadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileReadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.length = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.transcode = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileReadRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
      length: isSet(object.length) ? globalThis.String(object.length) : "0",
      transcode: isSet(object.transcode) ? globalThis.Boolean(object.transcode) : false,
    };
  },

  toJSON(message: FileReadRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.offset !== "0") {
      obj.offset = message.offset;
    }
    if (message.length !== "0") {
      obj.length = message.length;
    }
    if (message.transcode !== false) {
      obj.transcode = message.transcode;
    }
    return obj;
  },

  create(base?: DeepPartial<FileReadRequest>): FileReadRequest {
    return FileReadRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileReadRequest>): FileReadRequest {
    const message = createBaseFileReadRequest();
    message.path = object.path ?? "";
    message.offset = object.offset ?? "0";
    message.length = object.length ?? "0";
    message.transcode = object.transcode ?? false;
    return message;
  },
};

function createBaseFileReadResult(): FileReadResult {
  return {
    content: Buffer.alloc(0),
    encoding: "",
    totalSize: "0",
    mimeType: "",
    isTruncated: false,
    viewerType: 0,
    isTranscoded: false,
    transcodeComplete: false,
  };
}

export const FileReadResult: MessageFns<FileReadResult> = {
  encode(message: FileReadResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content.length !== 0) {
      writer.uint32(10).bytes(message.content);
    }
    if (message.encoding !== "") {
      writer.uint32(18).string(message.encoding);
    }
    if (message.totalSize !== "0") {
      writer.uint32(24).int64(message.totalSize);
    }
    if (message.mimeType !== "") {
      writer.uint32(34).string(message.mimeType);
    }
    if (message.isTruncated !== false) {
      writer.uint32(40).bool(message.isTruncated);
    }
    if (message.viewerType !== 0) {
      writer.uint32(48).int32(message.viewerType);
    }
    if (message.isTranscoded !== false) {
      writer.uint32(56).bool(message.isTranscoded);
    }
    if (message.transcodeComplete !== false) {
      writer.uint32(64).bool(message.transcodeComplete);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileReadResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileReadResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = Buffer.from(reader.bytes());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.encoding = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isTruncated = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.viewerType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isTranscoded = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.transcodeComplete = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileReadResult {
    return {
      content: isSet(object.content) ? Buffer.from(bytesFromBase64(object.content)) : Buffer.alloc(0),
      encoding: isSet(object.encoding) ? globalThis.String(object.encoding) : "",
      totalSize: isSet(object.totalSize)
        ? globalThis.String(object.totalSize)
        : isSet(object.total_size)
        ? globalThis.String(object.total_size)
        : "0",
      mimeType: isSet(object.mimeType)
        ? globalThis.String(object.mimeType)
        : isSet(object.mime_type)
        ? globalThis.String(object.mime_type)
        : "",
      isTruncated: isSet(object.isTruncated)
        ? globalThis.Boolean(object.isTruncated)
        : isSet(object.is_truncated)
        ? globalThis.Boolean(object.is_truncated)
        : false,
      viewerType: isSet(object.viewerType)
        ? viewerTypeFromJSON(object.viewerType)
        : isSet(object.viewer_type)
        ? viewerTypeFromJSON(object.viewer_type)
        : 0,
      isTranscoded: isSet(object.isTranscoded)
        ? globalThis.Boolean(object.isTranscoded)
        : isSet(object.is_transcoded)
        ? globalThis.Boolean(object.is_transcoded)
        : false,
      transcodeComplete: isSet(object.transcodeComplete)
        ? globalThis.Boolean(object.transcodeComplete)
        : isSet(object.transcode_complete)
        ? globalThis.Boolean(object.transcode_complete)
        : false,
    };
  },

  toJSON(message: FileReadResult): unknown {
    const obj: any = {};
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    if (message.encoding !== "") {
      obj.encoding = message.encoding;
    }
    if (message.totalSize !== "0") {
      obj.totalSize = message.totalSize;
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.isTruncated !== false) {
      obj.isTruncated = message.isTruncated;
    }
    if (message.viewerType !== 0) {
      obj.viewerType = viewerTypeToJSON(message.viewerType);
    }
    if (message.isTranscoded !== false) {
      obj.isTranscoded = message.isTranscoded;
    }
    if (message.transcodeComplete !== false) {
      obj.transcodeComplete = message.transcodeComplete;
    }
    return obj;
  },

  create(base?: DeepPartial<FileReadResult>): FileReadResult {
    return FileReadResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileReadResult>): FileReadResult {
    const message = createBaseFileReadResult();
    message.content = object.content ?? Buffer.alloc(0);
    message.encoding = object.encoding ?? "";
    message.totalSize = object.totalSize ?? "0";
    message.mimeType = object.mimeType ?? "";
    message.isTruncated = object.isTruncated ?? false;
    message.viewerType = object.viewerType ?? 0;
    message.isTranscoded = object.isTranscoded ?? false;
    message.transcodeComplete = object.transcodeComplete ?? false;
    return message;
  },
};

function createBaseFileWriteRequest(): FileWriteRequest {
  return { path: "", content: Buffer.alloc(0), overwrite: false, createParents: false };
}

export const FileWriteRequest: MessageFns<FileWriteRequest> = {
  encode(message: FileWriteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.content.length !== 0) {
      writer.uint32(18).bytes(message.content);
    }
    if (message.overwrite !== false) {
      writer.uint32(24).bool(message.overwrite);
    }
    if (message.createParents !== false) {
      writer.uint32(32).bool(message.createParents);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileWriteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileWriteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = Buffer.from(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.overwrite = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.createParents = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileWriteRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      content: isSet(object.content) ? Buffer.from(bytesFromBase64(object.content)) : Buffer.alloc(0),
      overwrite: isSet(object.overwrite) ? globalThis.Boolean(object.overwrite) : false,
      createParents: isSet(object.createParents)
        ? globalThis.Boolean(object.createParents)
        : isSet(object.create_parents)
        ? globalThis.Boolean(object.create_parents)
        : false,
    };
  },

  toJSON(message: FileWriteRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    if (message.overwrite !== false) {
      obj.overwrite = message.overwrite;
    }
    if (message.createParents !== false) {
      obj.createParents = message.createParents;
    }
    return obj;
  },

  create(base?: DeepPartial<FileWriteRequest>): FileWriteRequest {
    return FileWriteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileWriteRequest>): FileWriteRequest {
    const message = createBaseFileWriteRequest();
    message.path = object.path ?? "";
    message.content = object.content ?? Buffer.alloc(0);
    message.overwrite = object.overwrite ?? false;
    message.createParents = object.createParents ?? false;
    return message;
  },
};

function createBaseFileWriteResult(): FileWriteResult {
  return { bytesWritten: "0", entry: undefined };
}

export const FileWriteResult: MessageFns<FileWriteResult> = {
  encode(message: FileWriteResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytesWritten !== "0") {
      writer.uint32(8).int64(message.bytesWritten);
    }
    if (message.entry !== undefined) {
      StreamFileEntry.encode(message.entry, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileWriteResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileWriteResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bytesWritten = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entry = StreamFileEntry.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileWriteResult {
    return {
      bytesWritten: isSet(object.bytesWritten)
        ? globalThis.String(object.bytesWritten)
        : isSet(object.bytes_written)
        ? globalThis.String(object.bytes_written)
        : "0",
      entry: isSet(object.entry) ? StreamFileEntry.fromJSON(object.entry) : undefined,
    };
  },

  toJSON(message: FileWriteResult): unknown {
    const obj: any = {};
    if (message.bytesWritten !== "0") {
      obj.bytesWritten = message.bytesWritten;
    }
    if (message.entry !== undefined) {
      obj.entry = StreamFileEntry.toJSON(message.entry);
    }
    return obj;
  },

  create(base?: DeepPartial<FileWriteResult>): FileWriteResult {
    return FileWriteResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileWriteResult>): FileWriteResult {
    const message = createBaseFileWriteResult();
    message.bytesWritten = object.bytesWritten ?? "0";
    message.entry = (object.entry !== undefined && object.entry !== null)
      ? StreamFileEntry.fromPartial(object.entry)
      : undefined;
    return message;
  },
};

function createBaseFileDeleteRequest(): FileDeleteRequest {
  return { path: "", recursive: false };
}

export const FileDeleteRequest: MessageFns<FileDeleteRequest> = {
  encode(message: FileDeleteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.recursive !== false) {
      writer.uint32(16).bool(message.recursive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileDeleteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.recursive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileDeleteRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      recursive: isSet(object.recursive) ? globalThis.Boolean(object.recursive) : false,
    };
  },

  toJSON(message: FileDeleteRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.recursive !== false) {
      obj.recursive = message.recursive;
    }
    return obj;
  },

  create(base?: DeepPartial<FileDeleteRequest>): FileDeleteRequest {
    return FileDeleteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileDeleteRequest>): FileDeleteRequest {
    const message = createBaseFileDeleteRequest();
    message.path = object.path ?? "";
    message.recursive = object.recursive ?? false;
    return message;
  },
};

function createBaseFileDeleteResult(): FileDeleteResult {
  return { deletedPath: "", filesDeleted: 0, dirsDeleted: 0 };
}

export const FileDeleteResult: MessageFns<FileDeleteResult> = {
  encode(message: FileDeleteResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deletedPath !== "") {
      writer.uint32(10).string(message.deletedPath);
    }
    if (message.filesDeleted !== 0) {
      writer.uint32(16).int32(message.filesDeleted);
    }
    if (message.dirsDeleted !== 0) {
      writer.uint32(24).int32(message.dirsDeleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileDeleteResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileDeleteResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deletedPath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.filesDeleted = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.dirsDeleted = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileDeleteResult {
    return {
      deletedPath: isSet(object.deletedPath)
        ? globalThis.String(object.deletedPath)
        : isSet(object.deleted_path)
        ? globalThis.String(object.deleted_path)
        : "",
      filesDeleted: isSet(object.filesDeleted)
        ? globalThis.Number(object.filesDeleted)
        : isSet(object.files_deleted)
        ? globalThis.Number(object.files_deleted)
        : 0,
      dirsDeleted: isSet(object.dirsDeleted)
        ? globalThis.Number(object.dirsDeleted)
        : isSet(object.dirs_deleted)
        ? globalThis.Number(object.dirs_deleted)
        : 0,
    };
  },

  toJSON(message: FileDeleteResult): unknown {
    const obj: any = {};
    if (message.deletedPath !== "") {
      obj.deletedPath = message.deletedPath;
    }
    if (message.filesDeleted !== 0) {
      obj.filesDeleted = Math.round(message.filesDeleted);
    }
    if (message.dirsDeleted !== 0) {
      obj.dirsDeleted = Math.round(message.dirsDeleted);
    }
    return obj;
  },

  create(base?: DeepPartial<FileDeleteResult>): FileDeleteResult {
    return FileDeleteResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileDeleteResult>): FileDeleteResult {
    const message = createBaseFileDeleteResult();
    message.deletedPath = object.deletedPath ?? "";
    message.filesDeleted = object.filesDeleted ?? 0;
    message.dirsDeleted = object.dirsDeleted ?? 0;
    return message;
  },
};

function createBaseFileMoveRequest(): FileMoveRequest {
  return { sourcePath: "", destinationPath: "", overwrite: false };
}

export const FileMoveRequest: MessageFns<FileMoveRequest> = {
  encode(message: FileMoveRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourcePath !== "") {
      writer.uint32(10).string(message.sourcePath);
    }
    if (message.destinationPath !== "") {
      writer.uint32(18).string(message.destinationPath);
    }
    if (message.overwrite !== false) {
      writer.uint32(24).bool(message.overwrite);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileMoveRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileMoveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourcePath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.destinationPath = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.overwrite = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileMoveRequest {
    return {
      sourcePath: isSet(object.sourcePath)
        ? globalThis.String(object.sourcePath)
        : isSet(object.source_path)
        ? globalThis.String(object.source_path)
        : "",
      destinationPath: isSet(object.destinationPath)
        ? globalThis.String(object.destinationPath)
        : isSet(object.destination_path)
        ? globalThis.String(object.destination_path)
        : "",
      overwrite: isSet(object.overwrite) ? globalThis.Boolean(object.overwrite) : false,
    };
  },

  toJSON(message: FileMoveRequest): unknown {
    const obj: any = {};
    if (message.sourcePath !== "") {
      obj.sourcePath = message.sourcePath;
    }
    if (message.destinationPath !== "") {
      obj.destinationPath = message.destinationPath;
    }
    if (message.overwrite !== false) {
      obj.overwrite = message.overwrite;
    }
    return obj;
  },

  create(base?: DeepPartial<FileMoveRequest>): FileMoveRequest {
    return FileMoveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileMoveRequest>): FileMoveRequest {
    const message = createBaseFileMoveRequest();
    message.sourcePath = object.sourcePath ?? "";
    message.destinationPath = object.destinationPath ?? "";
    message.overwrite = object.overwrite ?? false;
    return message;
  },
};

function createBaseFileMoveResult(): FileMoveResult {
  return { entry: undefined };
}

export const FileMoveResult: MessageFns<FileMoveResult> = {
  encode(message: FileMoveResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entry !== undefined) {
      StreamFileEntry.encode(message.entry, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileMoveResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileMoveResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entry = StreamFileEntry.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileMoveResult {
    return { entry: isSet(object.entry) ? StreamFileEntry.fromJSON(object.entry) : undefined };
  },

  toJSON(message: FileMoveResult): unknown {
    const obj: any = {};
    if (message.entry !== undefined) {
      obj.entry = StreamFileEntry.toJSON(message.entry);
    }
    return obj;
  },

  create(base?: DeepPartial<FileMoveResult>): FileMoveResult {
    return FileMoveResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileMoveResult>): FileMoveResult {
    const message = createBaseFileMoveResult();
    message.entry = (object.entry !== undefined && object.entry !== null)
      ? StreamFileEntry.fromPartial(object.entry)
      : undefined;
    return message;
  },
};

function createBaseFileCopyRequest(): FileCopyRequest {
  return { sourcePath: "", destinationPath: "", overwrite: false, recursive: false };
}

export const FileCopyRequest: MessageFns<FileCopyRequest> = {
  encode(message: FileCopyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourcePath !== "") {
      writer.uint32(10).string(message.sourcePath);
    }
    if (message.destinationPath !== "") {
      writer.uint32(18).string(message.destinationPath);
    }
    if (message.overwrite !== false) {
      writer.uint32(24).bool(message.overwrite);
    }
    if (message.recursive !== false) {
      writer.uint32(32).bool(message.recursive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileCopyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileCopyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourcePath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.destinationPath = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.overwrite = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.recursive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileCopyRequest {
    return {
      sourcePath: isSet(object.sourcePath)
        ? globalThis.String(object.sourcePath)
        : isSet(object.source_path)
        ? globalThis.String(object.source_path)
        : "",
      destinationPath: isSet(object.destinationPath)
        ? globalThis.String(object.destinationPath)
        : isSet(object.destination_path)
        ? globalThis.String(object.destination_path)
        : "",
      overwrite: isSet(object.overwrite) ? globalThis.Boolean(object.overwrite) : false,
      recursive: isSet(object.recursive) ? globalThis.Boolean(object.recursive) : false,
    };
  },

  toJSON(message: FileCopyRequest): unknown {
    const obj: any = {};
    if (message.sourcePath !== "") {
      obj.sourcePath = message.sourcePath;
    }
    if (message.destinationPath !== "") {
      obj.destinationPath = message.destinationPath;
    }
    if (message.overwrite !== false) {
      obj.overwrite = message.overwrite;
    }
    if (message.recursive !== false) {
      obj.recursive = message.recursive;
    }
    return obj;
  },

  create(base?: DeepPartial<FileCopyRequest>): FileCopyRequest {
    return FileCopyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileCopyRequest>): FileCopyRequest {
    const message = createBaseFileCopyRequest();
    message.sourcePath = object.sourcePath ?? "";
    message.destinationPath = object.destinationPath ?? "";
    message.overwrite = object.overwrite ?? false;
    message.recursive = object.recursive ?? false;
    return message;
  },
};

function createBaseFileCopyResult(): FileCopyResult {
  return { entry: undefined, bytesCopied: "0" };
}

export const FileCopyResult: MessageFns<FileCopyResult> = {
  encode(message: FileCopyResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entry !== undefined) {
      StreamFileEntry.encode(message.entry, writer.uint32(10).fork()).join();
    }
    if (message.bytesCopied !== "0") {
      writer.uint32(16).int64(message.bytesCopied);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileCopyResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileCopyResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entry = StreamFileEntry.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bytesCopied = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileCopyResult {
    return {
      entry: isSet(object.entry) ? StreamFileEntry.fromJSON(object.entry) : undefined,
      bytesCopied: isSet(object.bytesCopied)
        ? globalThis.String(object.bytesCopied)
        : isSet(object.bytes_copied)
        ? globalThis.String(object.bytes_copied)
        : "0",
    };
  },

  toJSON(message: FileCopyResult): unknown {
    const obj: any = {};
    if (message.entry !== undefined) {
      obj.entry = StreamFileEntry.toJSON(message.entry);
    }
    if (message.bytesCopied !== "0") {
      obj.bytesCopied = message.bytesCopied;
    }
    return obj;
  },

  create(base?: DeepPartial<FileCopyResult>): FileCopyResult {
    return FileCopyResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileCopyResult>): FileCopyResult {
    const message = createBaseFileCopyResult();
    message.entry = (object.entry !== undefined && object.entry !== null)
      ? StreamFileEntry.fromPartial(object.entry)
      : undefined;
    message.bytesCopied = object.bytesCopied ?? "0";
    return message;
  },
};

function createBaseFileGetInfoRequest(): FileGetInfoRequest {
  return { path: "" };
}

export const FileGetInfoRequest: MessageFns<FileGetInfoRequest> = {
  encode(message: FileGetInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileGetInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileGetInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileGetInfoRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: FileGetInfoRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<FileGetInfoRequest>): FileGetInfoRequest {
    return FileGetInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileGetInfoRequest>): FileGetInfoRequest {
    const message = createBaseFileGetInfoRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseFileGetInfoResult(): FileGetInfoResult {
  return { entry: undefined };
}

export const FileGetInfoResult: MessageFns<FileGetInfoResult> = {
  encode(message: FileGetInfoResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entry !== undefined) {
      StreamFileEntry.encode(message.entry, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileGetInfoResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileGetInfoResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entry = StreamFileEntry.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileGetInfoResult {
    return { entry: isSet(object.entry) ? StreamFileEntry.fromJSON(object.entry) : undefined };
  },

  toJSON(message: FileGetInfoResult): unknown {
    const obj: any = {};
    if (message.entry !== undefined) {
      obj.entry = StreamFileEntry.toJSON(message.entry);
    }
    return obj;
  },

  create(base?: DeepPartial<FileGetInfoResult>): FileGetInfoResult {
    return FileGetInfoResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileGetInfoResult>): FileGetInfoResult {
    const message = createBaseFileGetInfoResult();
    message.entry = (object.entry !== undefined && object.entry !== null)
      ? StreamFileEntry.fromPartial(object.entry)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
