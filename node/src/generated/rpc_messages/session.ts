// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: rpc_messages/session.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { SessionConfig, SessionStatus, sessionStatusFromJSON, sessionStatusToJSON } from "../common_types";
import { Timestamp } from "../google/protobuf/timestamp";

export const protobufPackage = "terminal";

/** Create session */
export interface CreateSessionRequest {
  /** User ID (from auth) */
  userId: string;
  /** Optional session name */
  name: string;
  /** Initial configuration */
  config: SessionConfig | undefined;
}

export interface CreateSessionResponse {
  success: boolean;
  /** Created session UUID */
  sessionId: string;
  /** Error message if failed */
  error: string;
}

/** Close session */
export interface CloseSessionRequest {
  sessionId: string;
  reason: string;
  force: boolean;
}

export interface CloseSessionResponse {
  success: boolean;
  error: string;
}

/** Get session status */
export interface GetSessionStatusRequest {
  sessionId: string;
}

export interface GetSessionStatusResponse {
  exists: boolean;
  status: SessionStatus;
  /** Hostname of the agent */
  agentHostname: string;
  connectedAt: Date | undefined;
  lastHeartbeatAt: Date | undefined;
  commandsCount: number;
}

/** List sessions (v2.14.0) - for SDK session discovery */
export interface ListSessionsRequest {
  /** Optional: filter by machine hostname */
  hostnameFilter: string;
  /** Optional: "connected", "disconnected" */
  statusFilter: string;
  /** Max sessions to return (default: 20) */
  limit: number;
  /** Pagination offset */
  offset: number;
}

export interface SessionInfoItem {
  /** Session UUID */
  sessionId: string;
  /** Machine hostname */
  machineHostname: string;
  /** Machine display name */
  machineName: string;
  /** connected, disconnected, grace_period */
  status: string;
  /** macos, linux, windows */
  os: string;
  /** Agent version string */
  agentVersion: string;
  /** Seconds since last heartbeat */
  heartbeatAgeSeconds: string;
  /** Whether machine has shell access */
  hasShell: boolean;
  /** Shell path (/bin/bash, etc.) */
  shell: string;
  /** Current working directory */
  workingDirectory: string;
  connectedAt: Date | undefined;
}

export interface ListSessionsResponse {
  /** List of sessions */
  sessions: SessionInfoItem[];
  /** Total count (for pagination) */
  total: number;
  /** Workspace name for context */
  workspaceName: string;
  /** Error message if failed */
  error: string;
}

/**
 * Get session by hostname (v2.21.0) - for SDK set_machine()
 * Returns the best active session for a given hostname.
 * If partial_match=true and multiple machines match, returns ambiguous=true.
 */
export interface GetSessionByHostnameRequest {
  /** Machine hostname (exact or partial match) */
  hostname: string;
  /** If true, use ICONTAINS; if false, exact match */
  partialMatch: boolean;
}

export interface GetSessionByHostnameResponse {
  /** Whether session was found */
  found: boolean;
  /** Session UUID */
  sessionId: string;
  /** Full hostname */
  machineHostname: string;
  /** Machine display name */
  machineName: string;
  /** Session status */
  status: string;
  /** Error message if not found */
  error: string;
  connectedAt: Date | undefined;
  heartbeatAgeSeconds: number;
  hasShell: boolean;
  shell: string;
  workingDirectory: string;
  /** True if multiple machines matched */
  ambiguous: boolean;
  /** Number of matching machines (for ambiguous) */
  matchesCount: number;
  /** Operating system */
  os: string;
  /** Agent version */
  agentVersion: string;
}

function createBaseCreateSessionRequest(): CreateSessionRequest {
  return { userId: "", name: "", config: undefined };
}

export const CreateSessionRequest: MessageFns<CreateSessionRequest> = {
  encode(message: CreateSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.config !== undefined) {
      SessionConfig.encode(message.config, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config = SessionConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionRequest {
    return {
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      config: isSet(object.config) ? SessionConfig.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: CreateSessionRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.config !== undefined) {
      obj.config = SessionConfig.toJSON(message.config);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSessionRequest>): CreateSessionRequest {
    return CreateSessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSessionRequest>): CreateSessionRequest {
    const message = createBaseCreateSessionRequest();
    message.userId = object.userId ?? "";
    message.name = object.name ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? SessionConfig.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseCreateSessionResponse(): CreateSessionResponse {
  return { success: false, sessionId: "", error: "" };
}

export const CreateSessionResponse: MessageFns<CreateSessionResponse> = {
  encode(message: CreateSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: CreateSessionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSessionResponse>): CreateSessionResponse {
    return CreateSessionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSessionResponse>): CreateSessionResponse {
    const message = createBaseCreateSessionResponse();
    message.success = object.success ?? false;
    message.sessionId = object.sessionId ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseCloseSessionRequest(): CloseSessionRequest {
  return { sessionId: "", reason: "", force: false };
}

export const CloseSessionRequest: MessageFns<CloseSessionRequest> = {
  encode(message: CloseSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    if (message.force !== false) {
      writer.uint32(24).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloseSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloseSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.force = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloseSessionRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: CloseSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<CloseSessionRequest>): CloseSessionRequest {
    return CloseSessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloseSessionRequest>): CloseSessionRequest {
    const message = createBaseCloseSessionRequest();
    message.sessionId = object.sessionId ?? "";
    message.reason = object.reason ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseCloseSessionResponse(): CloseSessionResponse {
  return { success: false, error: "" };
}

export const CloseSessionResponse: MessageFns<CloseSessionResponse> = {
  encode(message: CloseSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloseSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloseSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloseSessionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: CloseSessionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<CloseSessionResponse>): CloseSessionResponse {
    return CloseSessionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloseSessionResponse>): CloseSessionResponse {
    const message = createBaseCloseSessionResponse();
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseGetSessionStatusRequest(): GetSessionStatusRequest {
  return { sessionId: "" };
}

export const GetSessionStatusRequest: MessageFns<GetSessionStatusRequest> = {
  encode(message: GetSessionStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSessionStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionStatusRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
    };
  },

  toJSON(message: GetSessionStatusRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSessionStatusRequest>): GetSessionStatusRequest {
    return GetSessionStatusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSessionStatusRequest>): GetSessionStatusRequest {
    const message = createBaseGetSessionStatusRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseGetSessionStatusResponse(): GetSessionStatusResponse {
  return {
    exists: false,
    status: 0,
    agentHostname: "",
    connectedAt: undefined,
    lastHeartbeatAt: undefined,
    commandsCount: 0,
  };
}

export const GetSessionStatusResponse: MessageFns<GetSessionStatusResponse> = {
  encode(message: GetSessionStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exists !== false) {
      writer.uint32(8).bool(message.exists);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.agentHostname !== "") {
      writer.uint32(26).string(message.agentHostname);
    }
    if (message.connectedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.connectedAt), writer.uint32(34).fork()).join();
    }
    if (message.lastHeartbeatAt !== undefined) {
      Timestamp.encode(toTimestamp(message.lastHeartbeatAt), writer.uint32(42).fork()).join();
    }
    if (message.commandsCount !== 0) {
      writer.uint32(48).int32(message.commandsCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSessionStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.exists = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.agentHostname = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.connectedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lastHeartbeatAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.commandsCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionStatusResponse {
    return {
      exists: isSet(object.exists) ? globalThis.Boolean(object.exists) : false,
      status: isSet(object.status) ? sessionStatusFromJSON(object.status) : 0,
      agentHostname: isSet(object.agentHostname)
        ? globalThis.String(object.agentHostname)
        : isSet(object.agent_hostname)
        ? globalThis.String(object.agent_hostname)
        : "",
      connectedAt: isSet(object.connectedAt)
        ? fromJsonTimestamp(object.connectedAt)
        : isSet(object.connected_at)
        ? fromJsonTimestamp(object.connected_at)
        : undefined,
      lastHeartbeatAt: isSet(object.lastHeartbeatAt)
        ? fromJsonTimestamp(object.lastHeartbeatAt)
        : isSet(object.last_heartbeat_at)
        ? fromJsonTimestamp(object.last_heartbeat_at)
        : undefined,
      commandsCount: isSet(object.commandsCount)
        ? globalThis.Number(object.commandsCount)
        : isSet(object.commands_count)
        ? globalThis.Number(object.commands_count)
        : 0,
    };
  },

  toJSON(message: GetSessionStatusResponse): unknown {
    const obj: any = {};
    if (message.exists !== false) {
      obj.exists = message.exists;
    }
    if (message.status !== 0) {
      obj.status = sessionStatusToJSON(message.status);
    }
    if (message.agentHostname !== "") {
      obj.agentHostname = message.agentHostname;
    }
    if (message.connectedAt !== undefined) {
      obj.connectedAt = message.connectedAt.toISOString();
    }
    if (message.lastHeartbeatAt !== undefined) {
      obj.lastHeartbeatAt = message.lastHeartbeatAt.toISOString();
    }
    if (message.commandsCount !== 0) {
      obj.commandsCount = Math.round(message.commandsCount);
    }
    return obj;
  },

  create(base?: DeepPartial<GetSessionStatusResponse>): GetSessionStatusResponse {
    return GetSessionStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSessionStatusResponse>): GetSessionStatusResponse {
    const message = createBaseGetSessionStatusResponse();
    message.exists = object.exists ?? false;
    message.status = object.status ?? 0;
    message.agentHostname = object.agentHostname ?? "";
    message.connectedAt = object.connectedAt ?? undefined;
    message.lastHeartbeatAt = object.lastHeartbeatAt ?? undefined;
    message.commandsCount = object.commandsCount ?? 0;
    return message;
  },
};

function createBaseListSessionsRequest(): ListSessionsRequest {
  return { hostnameFilter: "", statusFilter: "", limit: 0, offset: 0 };
}

export const ListSessionsRequest: MessageFns<ListSessionsRequest> = {
  encode(message: ListSessionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostnameFilter !== "") {
      writer.uint32(10).string(message.hostnameFilter);
    }
    if (message.statusFilter !== "") {
      writer.uint32(18).string(message.statusFilter);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(32).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hostnameFilter = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.statusFilter = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionsRequest {
    return {
      hostnameFilter: isSet(object.hostnameFilter)
        ? globalThis.String(object.hostnameFilter)
        : isSet(object.hostname_filter)
        ? globalThis.String(object.hostname_filter)
        : "",
      statusFilter: isSet(object.statusFilter)
        ? globalThis.String(object.statusFilter)
        : isSet(object.status_filter)
        ? globalThis.String(object.status_filter)
        : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
    };
  },

  toJSON(message: ListSessionsRequest): unknown {
    const obj: any = {};
    if (message.hostnameFilter !== "") {
      obj.hostnameFilter = message.hostnameFilter;
    }
    if (message.statusFilter !== "") {
      obj.statusFilter = message.statusFilter;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create(base?: DeepPartial<ListSessionsRequest>): ListSessionsRequest {
    return ListSessionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSessionsRequest>): ListSessionsRequest {
    const message = createBaseListSessionsRequest();
    message.hostnameFilter = object.hostnameFilter ?? "";
    message.statusFilter = object.statusFilter ?? "";
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseSessionInfoItem(): SessionInfoItem {
  return {
    sessionId: "",
    machineHostname: "",
    machineName: "",
    status: "",
    os: "",
    agentVersion: "",
    heartbeatAgeSeconds: "0",
    hasShell: false,
    shell: "",
    workingDirectory: "",
    connectedAt: undefined,
  };
}

export const SessionInfoItem: MessageFns<SessionInfoItem> = {
  encode(message: SessionInfoItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.machineHostname !== "") {
      writer.uint32(18).string(message.machineHostname);
    }
    if (message.machineName !== "") {
      writer.uint32(26).string(message.machineName);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.os !== "") {
      writer.uint32(42).string(message.os);
    }
    if (message.agentVersion !== "") {
      writer.uint32(50).string(message.agentVersion);
    }
    if (message.heartbeatAgeSeconds !== "0") {
      writer.uint32(56).int64(message.heartbeatAgeSeconds);
    }
    if (message.hasShell !== false) {
      writer.uint32(64).bool(message.hasShell);
    }
    if (message.shell !== "") {
      writer.uint32(74).string(message.shell);
    }
    if (message.workingDirectory !== "") {
      writer.uint32(82).string(message.workingDirectory);
    }
    if (message.connectedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.connectedAt), writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionInfoItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionInfoItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.machineHostname = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.machineName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.os = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.agentVersion = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.heartbeatAgeSeconds = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.hasShell = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.shell = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.workingDirectory = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.connectedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionInfoItem {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      machineHostname: isSet(object.machineHostname)
        ? globalThis.String(object.machineHostname)
        : isSet(object.machine_hostname)
        ? globalThis.String(object.machine_hostname)
        : "",
      machineName: isSet(object.machineName)
        ? globalThis.String(object.machineName)
        : isSet(object.machine_name)
        ? globalThis.String(object.machine_name)
        : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      os: isSet(object.os) ? globalThis.String(object.os) : "",
      agentVersion: isSet(object.agentVersion)
        ? globalThis.String(object.agentVersion)
        : isSet(object.agent_version)
        ? globalThis.String(object.agent_version)
        : "",
      heartbeatAgeSeconds: isSet(object.heartbeatAgeSeconds)
        ? globalThis.String(object.heartbeatAgeSeconds)
        : isSet(object.heartbeat_age_seconds)
        ? globalThis.String(object.heartbeat_age_seconds)
        : "0",
      hasShell: isSet(object.hasShell)
        ? globalThis.Boolean(object.hasShell)
        : isSet(object.has_shell)
        ? globalThis.Boolean(object.has_shell)
        : false,
      shell: isSet(object.shell) ? globalThis.String(object.shell) : "",
      workingDirectory: isSet(object.workingDirectory)
        ? globalThis.String(object.workingDirectory)
        : isSet(object.working_directory)
        ? globalThis.String(object.working_directory)
        : "",
      connectedAt: isSet(object.connectedAt)
        ? fromJsonTimestamp(object.connectedAt)
        : isSet(object.connected_at)
        ? fromJsonTimestamp(object.connected_at)
        : undefined,
    };
  },

  toJSON(message: SessionInfoItem): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.machineHostname !== "") {
      obj.machineHostname = message.machineHostname;
    }
    if (message.machineName !== "") {
      obj.machineName = message.machineName;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.os !== "") {
      obj.os = message.os;
    }
    if (message.agentVersion !== "") {
      obj.agentVersion = message.agentVersion;
    }
    if (message.heartbeatAgeSeconds !== "0") {
      obj.heartbeatAgeSeconds = message.heartbeatAgeSeconds;
    }
    if (message.hasShell !== false) {
      obj.hasShell = message.hasShell;
    }
    if (message.shell !== "") {
      obj.shell = message.shell;
    }
    if (message.workingDirectory !== "") {
      obj.workingDirectory = message.workingDirectory;
    }
    if (message.connectedAt !== undefined) {
      obj.connectedAt = message.connectedAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<SessionInfoItem>): SessionInfoItem {
    return SessionInfoItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionInfoItem>): SessionInfoItem {
    const message = createBaseSessionInfoItem();
    message.sessionId = object.sessionId ?? "";
    message.machineHostname = object.machineHostname ?? "";
    message.machineName = object.machineName ?? "";
    message.status = object.status ?? "";
    message.os = object.os ?? "";
    message.agentVersion = object.agentVersion ?? "";
    message.heartbeatAgeSeconds = object.heartbeatAgeSeconds ?? "0";
    message.hasShell = object.hasShell ?? false;
    message.shell = object.shell ?? "";
    message.workingDirectory = object.workingDirectory ?? "";
    message.connectedAt = object.connectedAt ?? undefined;
    return message;
  },
};

function createBaseListSessionsResponse(): ListSessionsResponse {
  return { sessions: [], total: 0, workspaceName: "", error: "" };
}

export const ListSessionsResponse: MessageFns<ListSessionsResponse> = {
  encode(message: ListSessionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sessions) {
      SessionInfoItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.workspaceName !== "") {
      writer.uint32(26).string(message.workspaceName);
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessions.push(SessionInfoItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workspaceName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionsResponse {
    return {
      sessions: globalThis.Array.isArray(object?.sessions)
        ? object.sessions.map((e: any) => SessionInfoItem.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      workspaceName: isSet(object.workspaceName)
        ? globalThis.String(object.workspaceName)
        : isSet(object.workspace_name)
        ? globalThis.String(object.workspace_name)
        : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: ListSessionsResponse): unknown {
    const obj: any = {};
    if (message.sessions?.length) {
      obj.sessions = message.sessions.map((e) => SessionInfoItem.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.workspaceName !== "") {
      obj.workspaceName = message.workspaceName;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSessionsResponse>): ListSessionsResponse {
    return ListSessionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSessionsResponse>): ListSessionsResponse {
    const message = createBaseListSessionsResponse();
    message.sessions = object.sessions?.map((e) => SessionInfoItem.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.workspaceName = object.workspaceName ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseGetSessionByHostnameRequest(): GetSessionByHostnameRequest {
  return { hostname: "", partialMatch: false };
}

export const GetSessionByHostnameRequest: MessageFns<GetSessionByHostnameRequest> = {
  encode(message: GetSessionByHostnameRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostname !== "") {
      writer.uint32(10).string(message.hostname);
    }
    if (message.partialMatch !== false) {
      writer.uint32(16).bool(message.partialMatch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSessionByHostnameRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionByHostnameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.partialMatch = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionByHostnameRequest {
    return {
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      partialMatch: isSet(object.partialMatch)
        ? globalThis.Boolean(object.partialMatch)
        : isSet(object.partial_match)
        ? globalThis.Boolean(object.partial_match)
        : false,
    };
  },

  toJSON(message: GetSessionByHostnameRequest): unknown {
    const obj: any = {};
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.partialMatch !== false) {
      obj.partialMatch = message.partialMatch;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSessionByHostnameRequest>): GetSessionByHostnameRequest {
    return GetSessionByHostnameRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSessionByHostnameRequest>): GetSessionByHostnameRequest {
    const message = createBaseGetSessionByHostnameRequest();
    message.hostname = object.hostname ?? "";
    message.partialMatch = object.partialMatch ?? false;
    return message;
  },
};

function createBaseGetSessionByHostnameResponse(): GetSessionByHostnameResponse {
  return {
    found: false,
    sessionId: "",
    machineHostname: "",
    machineName: "",
    status: "",
    error: "",
    connectedAt: undefined,
    heartbeatAgeSeconds: 0,
    hasShell: false,
    shell: "",
    workingDirectory: "",
    ambiguous: false,
    matchesCount: 0,
    os: "",
    agentVersion: "",
  };
}

export const GetSessionByHostnameResponse: MessageFns<GetSessionByHostnameResponse> = {
  encode(message: GetSessionByHostnameResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.found !== false) {
      writer.uint32(8).bool(message.found);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.machineHostname !== "") {
      writer.uint32(26).string(message.machineHostname);
    }
    if (message.machineName !== "") {
      writer.uint32(34).string(message.machineName);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.error !== "") {
      writer.uint32(50).string(message.error);
    }
    if (message.connectedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.connectedAt), writer.uint32(58).fork()).join();
    }
    if (message.heartbeatAgeSeconds !== 0) {
      writer.uint32(64).int32(message.heartbeatAgeSeconds);
    }
    if (message.hasShell !== false) {
      writer.uint32(72).bool(message.hasShell);
    }
    if (message.shell !== "") {
      writer.uint32(82).string(message.shell);
    }
    if (message.workingDirectory !== "") {
      writer.uint32(90).string(message.workingDirectory);
    }
    if (message.ambiguous !== false) {
      writer.uint32(96).bool(message.ambiguous);
    }
    if (message.matchesCount !== 0) {
      writer.uint32(104).int32(message.matchesCount);
    }
    if (message.os !== "") {
      writer.uint32(114).string(message.os);
    }
    if (message.agentVersion !== "") {
      writer.uint32(122).string(message.agentVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSessionByHostnameResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionByHostnameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.found = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.machineHostname = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.machineName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.connectedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.heartbeatAgeSeconds = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.hasShell = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.shell = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.workingDirectory = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.ambiguous = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.matchesCount = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.os = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.agentVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionByHostnameResponse {
    return {
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      machineHostname: isSet(object.machineHostname)
        ? globalThis.String(object.machineHostname)
        : isSet(object.machine_hostname)
        ? globalThis.String(object.machine_hostname)
        : "",
      machineName: isSet(object.machineName)
        ? globalThis.String(object.machineName)
        : isSet(object.machine_name)
        ? globalThis.String(object.machine_name)
        : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      connectedAt: isSet(object.connectedAt)
        ? fromJsonTimestamp(object.connectedAt)
        : isSet(object.connected_at)
        ? fromJsonTimestamp(object.connected_at)
        : undefined,
      heartbeatAgeSeconds: isSet(object.heartbeatAgeSeconds)
        ? globalThis.Number(object.heartbeatAgeSeconds)
        : isSet(object.heartbeat_age_seconds)
        ? globalThis.Number(object.heartbeat_age_seconds)
        : 0,
      hasShell: isSet(object.hasShell)
        ? globalThis.Boolean(object.hasShell)
        : isSet(object.has_shell)
        ? globalThis.Boolean(object.has_shell)
        : false,
      shell: isSet(object.shell) ? globalThis.String(object.shell) : "",
      workingDirectory: isSet(object.workingDirectory)
        ? globalThis.String(object.workingDirectory)
        : isSet(object.working_directory)
        ? globalThis.String(object.working_directory)
        : "",
      ambiguous: isSet(object.ambiguous) ? globalThis.Boolean(object.ambiguous) : false,
      matchesCount: isSet(object.matchesCount)
        ? globalThis.Number(object.matchesCount)
        : isSet(object.matches_count)
        ? globalThis.Number(object.matches_count)
        : 0,
      os: isSet(object.os) ? globalThis.String(object.os) : "",
      agentVersion: isSet(object.agentVersion)
        ? globalThis.String(object.agentVersion)
        : isSet(object.agent_version)
        ? globalThis.String(object.agent_version)
        : "",
    };
  },

  toJSON(message: GetSessionByHostnameResponse): unknown {
    const obj: any = {};
    if (message.found !== false) {
      obj.found = message.found;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.machineHostname !== "") {
      obj.machineHostname = message.machineHostname;
    }
    if (message.machineName !== "") {
      obj.machineName = message.machineName;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.connectedAt !== undefined) {
      obj.connectedAt = message.connectedAt.toISOString();
    }
    if (message.heartbeatAgeSeconds !== 0) {
      obj.heartbeatAgeSeconds = Math.round(message.heartbeatAgeSeconds);
    }
    if (message.hasShell !== false) {
      obj.hasShell = message.hasShell;
    }
    if (message.shell !== "") {
      obj.shell = message.shell;
    }
    if (message.workingDirectory !== "") {
      obj.workingDirectory = message.workingDirectory;
    }
    if (message.ambiguous !== false) {
      obj.ambiguous = message.ambiguous;
    }
    if (message.matchesCount !== 0) {
      obj.matchesCount = Math.round(message.matchesCount);
    }
    if (message.os !== "") {
      obj.os = message.os;
    }
    if (message.agentVersion !== "") {
      obj.agentVersion = message.agentVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSessionByHostnameResponse>): GetSessionByHostnameResponse {
    return GetSessionByHostnameResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSessionByHostnameResponse>): GetSessionByHostnameResponse {
    const message = createBaseGetSessionByHostnameResponse();
    message.found = object.found ?? false;
    message.sessionId = object.sessionId ?? "";
    message.machineHostname = object.machineHostname ?? "";
    message.machineName = object.machineName ?? "";
    message.status = object.status ?? "";
    message.error = object.error ?? "";
    message.connectedAt = object.connectedAt ?? undefined;
    message.heartbeatAgeSeconds = object.heartbeatAgeSeconds ?? 0;
    message.hasShell = object.hasShell ?? false;
    message.shell = object.shell ?? "";
    message.workingDirectory = object.workingDirectory ?? "";
    message.ambiguous = object.ambiguous ?? false;
    message.matchesCount = object.matchesCount ?? 0;
    message.os = object.os ?? "";
    message.agentVersion = object.agentVersion ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
