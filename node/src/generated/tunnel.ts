// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: tunnel.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "terminal";

/** Tunnel state enum */
export enum TunnelState {
  TUNNEL_STATE_UNSPECIFIED = 0,
  TUNNEL_STATE_CREATING = 1,
  TUNNEL_STATE_ACTIVE = 2,
  TUNNEL_STATE_CLOSED = 3,
  TUNNEL_STATE_ERROR = 4,
  UNRECOGNIZED = -1,
}

export function tunnelStateFromJSON(object: any): TunnelState {
  switch (object) {
    case 0:
    case "TUNNEL_STATE_UNSPECIFIED":
      return TunnelState.TUNNEL_STATE_UNSPECIFIED;
    case 1:
    case "TUNNEL_STATE_CREATING":
      return TunnelState.TUNNEL_STATE_CREATING;
    case 2:
    case "TUNNEL_STATE_ACTIVE":
      return TunnelState.TUNNEL_STATE_ACTIVE;
    case 3:
    case "TUNNEL_STATE_CLOSED":
      return TunnelState.TUNNEL_STATE_CLOSED;
    case 4:
    case "TUNNEL_STATE_ERROR":
      return TunnelState.TUNNEL_STATE_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TunnelState.UNRECOGNIZED;
  }
}

export function tunnelStateToJSON(object: TunnelState): string {
  switch (object) {
    case TunnelState.TUNNEL_STATE_UNSPECIFIED:
      return "TUNNEL_STATE_UNSPECIFIED";
    case TunnelState.TUNNEL_STATE_CREATING:
      return "TUNNEL_STATE_CREATING";
    case TunnelState.TUNNEL_STATE_ACTIVE:
      return "TUNNEL_STATE_ACTIVE";
    case TunnelState.TUNNEL_STATE_CLOSED:
      return "TUNNEL_STATE_CLOSED";
    case TunnelState.TUNNEL_STATE_ERROR:
      return "TUNNEL_STATE_ERROR";
    case TunnelState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Tunnel protocol type */
export enum TunnelProtocol {
  TUNNEL_PROTOCOL_HTTP = 0,
  TUNNEL_PROTOCOL_HTTPS = 1,
  TUNNEL_PROTOCOL_TCP = 2,
  UNRECOGNIZED = -1,
}

export function tunnelProtocolFromJSON(object: any): TunnelProtocol {
  switch (object) {
    case 0:
    case "TUNNEL_PROTOCOL_HTTP":
      return TunnelProtocol.TUNNEL_PROTOCOL_HTTP;
    case 1:
    case "TUNNEL_PROTOCOL_HTTPS":
      return TunnelProtocol.TUNNEL_PROTOCOL_HTTPS;
    case 2:
    case "TUNNEL_PROTOCOL_TCP":
      return TunnelProtocol.TUNNEL_PROTOCOL_TCP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TunnelProtocol.UNRECOGNIZED;
  }
}

export function tunnelProtocolToJSON(object: TunnelProtocol): string {
  switch (object) {
    case TunnelProtocol.TUNNEL_PROTOCOL_HTTP:
      return "TUNNEL_PROTOCOL_HTTP";
    case TunnelProtocol.TUNNEL_PROTOCOL_HTTPS:
      return "TUNNEL_PROTOCOL_HTTPS";
    case TunnelProtocol.TUNNEL_PROTOCOL_TCP:
      return "TUNNEL_PROTOCOL_TCP";
    case TunnelProtocol.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request to create a tunnel (Server -> Agent) */
export interface TunnelCreate {
  /** Unique tunnel identifier */
  tunnelId: string;
  /** Target address on agent machine (localhost:8080) */
  localAddress: string;
  /** Protocol type (http, https, tcp) */
  protocol: TunnelProtocol;
  /** Assigned subdomain (abc123.tunnel.cmdop.com) */
  subdomain: string;
}

/** Tunnel data packet (bidirectional - wraps HTTP request/response) */
export interface TunnelData {
  /** Tunnel identifier */
  tunnelId: string;
  /** Per-connection UUID (each HTTP request gets one) */
  connectionId: string;
  /** Raw HTTP request or response bytes */
  data: Buffer;
  /** Sequence number for ordering chunks */
  sequence: number;
  /** true = from internet (Server->Agent), false = response (Agent->Server) */
  isRequest: boolean;
  /** true = connection closed */
  isClose: boolean;
  /** HTTP metadata (optional, for logging/debugging) */
  method: string;
  /** Request path - only for requests */
  path: string;
  /** HTTP status code - only for responses */
  statusCode: number;
  /** Headers (optional) */
  headers: { [key: string]: string };
}

export interface TunnelData_HeadersEntry {
  key: string;
  value: string;
}

/** Request to close a tunnel (Server -> Agent) */
export interface TunnelClose {
  /** Tunnel to close */
  tunnelId: string;
  /** Reason for closing */
  reason: string;
}

/** Tunnel creation result (Agent -> Server) */
export interface TunnelCreated {
  /** Tunnel identifier */
  tunnelId: string;
  /** Whether tunnel was created successfully */
  success: boolean;
  /** Error message if failed */
  error: string;
  /** Full public URL (https://abc123.tunnel.cmdop.com) */
  publicUrl: string;
}

/** Tunnel closed acknowledgement (Agent -> Server) */
export interface TunnelClosed {
  /** Tunnel that was closed */
  tunnelId: string;
}

/** Tunnel error report (Agent -> Server) */
export interface TunnelError {
  /** Tunnel identifier */
  tunnelId: string;
  /** Connection that errored (if applicable) */
  connectionId: string;
  /** Error code */
  errorCode: string;
  /** Error message */
  message: string;
  /** If true, tunnel will be closed */
  isFatal: boolean;
}

function createBaseTunnelCreate(): TunnelCreate {
  return { tunnelId: "", localAddress: "", protocol: 0, subdomain: "" };
}

export const TunnelCreate: MessageFns<TunnelCreate> = {
  encode(message: TunnelCreate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tunnelId !== "") {
      writer.uint32(10).string(message.tunnelId);
    }
    if (message.localAddress !== "") {
      writer.uint32(18).string(message.localAddress);
    }
    if (message.protocol !== 0) {
      writer.uint32(24).int32(message.protocol);
    }
    if (message.subdomain !== "") {
      writer.uint32(34).string(message.subdomain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TunnelCreate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTunnelCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tunnelId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.localAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.protocol = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.subdomain = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TunnelCreate {
    return {
      tunnelId: isSet(object.tunnelId)
        ? globalThis.String(object.tunnelId)
        : isSet(object.tunnel_id)
        ? globalThis.String(object.tunnel_id)
        : "",
      localAddress: isSet(object.localAddress)
        ? globalThis.String(object.localAddress)
        : isSet(object.local_address)
        ? globalThis.String(object.local_address)
        : "",
      protocol: isSet(object.protocol) ? tunnelProtocolFromJSON(object.protocol) : 0,
      subdomain: isSet(object.subdomain) ? globalThis.String(object.subdomain) : "",
    };
  },

  toJSON(message: TunnelCreate): unknown {
    const obj: any = {};
    if (message.tunnelId !== "") {
      obj.tunnelId = message.tunnelId;
    }
    if (message.localAddress !== "") {
      obj.localAddress = message.localAddress;
    }
    if (message.protocol !== 0) {
      obj.protocol = tunnelProtocolToJSON(message.protocol);
    }
    if (message.subdomain !== "") {
      obj.subdomain = message.subdomain;
    }
    return obj;
  },

  create(base?: DeepPartial<TunnelCreate>): TunnelCreate {
    return TunnelCreate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TunnelCreate>): TunnelCreate {
    const message = createBaseTunnelCreate();
    message.tunnelId = object.tunnelId ?? "";
    message.localAddress = object.localAddress ?? "";
    message.protocol = object.protocol ?? 0;
    message.subdomain = object.subdomain ?? "";
    return message;
  },
};

function createBaseTunnelData(): TunnelData {
  return {
    tunnelId: "",
    connectionId: "",
    data: Buffer.alloc(0),
    sequence: 0,
    isRequest: false,
    isClose: false,
    method: "",
    path: "",
    statusCode: 0,
    headers: {},
  };
}

export const TunnelData: MessageFns<TunnelData> = {
  encode(message: TunnelData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tunnelId !== "") {
      writer.uint32(10).string(message.tunnelId);
    }
    if (message.connectionId !== "") {
      writer.uint32(18).string(message.connectionId);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (message.sequence !== 0) {
      writer.uint32(32).int32(message.sequence);
    }
    if (message.isRequest !== false) {
      writer.uint32(40).bool(message.isRequest);
    }
    if (message.isClose !== false) {
      writer.uint32(48).bool(message.isClose);
    }
    if (message.method !== "") {
      writer.uint32(58).string(message.method);
    }
    if (message.path !== "") {
      writer.uint32(66).string(message.path);
    }
    if (message.statusCode !== 0) {
      writer.uint32(72).int32(message.statusCode);
    }
    globalThis.Object.entries(message.headers).forEach(([key, value]: [string, string]) => {
      TunnelData_HeadersEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TunnelData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTunnelData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tunnelId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sequence = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isRequest = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isClose = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.statusCode = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = TunnelData_HeadersEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.headers[entry10.key] = entry10.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TunnelData {
    return {
      tunnelId: isSet(object.tunnelId)
        ? globalThis.String(object.tunnelId)
        : isSet(object.tunnel_id)
        ? globalThis.String(object.tunnel_id)
        : "",
      connectionId: isSet(object.connectionId)
        ? globalThis.String(object.connectionId)
        : isSet(object.connection_id)
        ? globalThis.String(object.connection_id)
        : "",
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
      isRequest: isSet(object.isRequest)
        ? globalThis.Boolean(object.isRequest)
        : isSet(object.is_request)
        ? globalThis.Boolean(object.is_request)
        : false,
      isClose: isSet(object.isClose)
        ? globalThis.Boolean(object.isClose)
        : isSet(object.is_close)
        ? globalThis.Boolean(object.is_close)
        : false,
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      statusCode: isSet(object.statusCode)
        ? globalThis.Number(object.statusCode)
        : isSet(object.status_code)
        ? globalThis.Number(object.status_code)
        : 0,
      headers: isObject(object.headers)
        ? (globalThis.Object.entries(object.headers) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: TunnelData): unknown {
    const obj: any = {};
    if (message.tunnelId !== "") {
      obj.tunnelId = message.tunnelId;
    }
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.isRequest !== false) {
      obj.isRequest = message.isRequest;
    }
    if (message.isClose !== false) {
      obj.isClose = message.isClose;
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.statusCode !== 0) {
      obj.statusCode = Math.round(message.statusCode);
    }
    if (message.headers) {
      const entries = globalThis.Object.entries(message.headers) as [string, string][];
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<TunnelData>): TunnelData {
    return TunnelData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TunnelData>): TunnelData {
    const message = createBaseTunnelData();
    message.tunnelId = object.tunnelId ?? "";
    message.connectionId = object.connectionId ?? "";
    message.data = object.data ?? Buffer.alloc(0);
    message.sequence = object.sequence ?? 0;
    message.isRequest = object.isRequest ?? false;
    message.isClose = object.isClose ?? false;
    message.method = object.method ?? "";
    message.path = object.path ?? "";
    message.statusCode = object.statusCode ?? 0;
    message.headers = (globalThis.Object.entries(object.headers ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseTunnelData_HeadersEntry(): TunnelData_HeadersEntry {
  return { key: "", value: "" };
}

export const TunnelData_HeadersEntry: MessageFns<TunnelData_HeadersEntry> = {
  encode(message: TunnelData_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TunnelData_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTunnelData_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TunnelData_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TunnelData_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<TunnelData_HeadersEntry>): TunnelData_HeadersEntry {
    return TunnelData_HeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TunnelData_HeadersEntry>): TunnelData_HeadersEntry {
    const message = createBaseTunnelData_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTunnelClose(): TunnelClose {
  return { tunnelId: "", reason: "" };
}

export const TunnelClose: MessageFns<TunnelClose> = {
  encode(message: TunnelClose, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tunnelId !== "") {
      writer.uint32(10).string(message.tunnelId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TunnelClose {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTunnelClose();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tunnelId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TunnelClose {
    return {
      tunnelId: isSet(object.tunnelId)
        ? globalThis.String(object.tunnelId)
        : isSet(object.tunnel_id)
        ? globalThis.String(object.tunnel_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: TunnelClose): unknown {
    const obj: any = {};
    if (message.tunnelId !== "") {
      obj.tunnelId = message.tunnelId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<TunnelClose>): TunnelClose {
    return TunnelClose.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TunnelClose>): TunnelClose {
    const message = createBaseTunnelClose();
    message.tunnelId = object.tunnelId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseTunnelCreated(): TunnelCreated {
  return { tunnelId: "", success: false, error: "", publicUrl: "" };
}

export const TunnelCreated: MessageFns<TunnelCreated> = {
  encode(message: TunnelCreated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tunnelId !== "") {
      writer.uint32(10).string(message.tunnelId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    if (message.publicUrl !== "") {
      writer.uint32(34).string(message.publicUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TunnelCreated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTunnelCreated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tunnelId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.publicUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TunnelCreated {
    return {
      tunnelId: isSet(object.tunnelId)
        ? globalThis.String(object.tunnelId)
        : isSet(object.tunnel_id)
        ? globalThis.String(object.tunnel_id)
        : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      publicUrl: isSet(object.publicUrl)
        ? globalThis.String(object.publicUrl)
        : isSet(object.public_url)
        ? globalThis.String(object.public_url)
        : "",
    };
  },

  toJSON(message: TunnelCreated): unknown {
    const obj: any = {};
    if (message.tunnelId !== "") {
      obj.tunnelId = message.tunnelId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.publicUrl !== "") {
      obj.publicUrl = message.publicUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<TunnelCreated>): TunnelCreated {
    return TunnelCreated.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TunnelCreated>): TunnelCreated {
    const message = createBaseTunnelCreated();
    message.tunnelId = object.tunnelId ?? "";
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    message.publicUrl = object.publicUrl ?? "";
    return message;
  },
};

function createBaseTunnelClosed(): TunnelClosed {
  return { tunnelId: "" };
}

export const TunnelClosed: MessageFns<TunnelClosed> = {
  encode(message: TunnelClosed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tunnelId !== "") {
      writer.uint32(10).string(message.tunnelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TunnelClosed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTunnelClosed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tunnelId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TunnelClosed {
    return {
      tunnelId: isSet(object.tunnelId)
        ? globalThis.String(object.tunnelId)
        : isSet(object.tunnel_id)
        ? globalThis.String(object.tunnel_id)
        : "",
    };
  },

  toJSON(message: TunnelClosed): unknown {
    const obj: any = {};
    if (message.tunnelId !== "") {
      obj.tunnelId = message.tunnelId;
    }
    return obj;
  },

  create(base?: DeepPartial<TunnelClosed>): TunnelClosed {
    return TunnelClosed.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TunnelClosed>): TunnelClosed {
    const message = createBaseTunnelClosed();
    message.tunnelId = object.tunnelId ?? "";
    return message;
  },
};

function createBaseTunnelError(): TunnelError {
  return { tunnelId: "", connectionId: "", errorCode: "", message: "", isFatal: false };
}

export const TunnelError: MessageFns<TunnelError> = {
  encode(message: TunnelError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tunnelId !== "") {
      writer.uint32(10).string(message.tunnelId);
    }
    if (message.connectionId !== "") {
      writer.uint32(18).string(message.connectionId);
    }
    if (message.errorCode !== "") {
      writer.uint32(26).string(message.errorCode);
    }
    if (message.message !== "") {
      writer.uint32(34).string(message.message);
    }
    if (message.isFatal !== false) {
      writer.uint32(40).bool(message.isFatal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TunnelError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTunnelError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tunnelId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isFatal = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TunnelError {
    return {
      tunnelId: isSet(object.tunnelId)
        ? globalThis.String(object.tunnelId)
        : isSet(object.tunnel_id)
        ? globalThis.String(object.tunnel_id)
        : "",
      connectionId: isSet(object.connectionId)
        ? globalThis.String(object.connectionId)
        : isSet(object.connection_id)
        ? globalThis.String(object.connection_id)
        : "",
      errorCode: isSet(object.errorCode)
        ? globalThis.String(object.errorCode)
        : isSet(object.error_code)
        ? globalThis.String(object.error_code)
        : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      isFatal: isSet(object.isFatal)
        ? globalThis.Boolean(object.isFatal)
        : isSet(object.is_fatal)
        ? globalThis.Boolean(object.is_fatal)
        : false,
    };
  },

  toJSON(message: TunnelError): unknown {
    const obj: any = {};
    if (message.tunnelId !== "") {
      obj.tunnelId = message.tunnelId;
    }
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.isFatal !== false) {
      obj.isFatal = message.isFatal;
    }
    return obj;
  },

  create(base?: DeepPartial<TunnelError>): TunnelError {
    return TunnelError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TunnelError>): TunnelError {
    const message = createBaseTunnelError();
    message.tunnelId = object.tunnelId ?? "";
    message.connectionId = object.connectionId ?? "";
    message.errorCode = object.errorCode ?? "";
    message.message = object.message ?? "";
    message.isFatal = object.isFatal ?? false;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
