// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: control_messages.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { SessionConfig, TerminalSize } from "./common_types";
import { FileOperationRequest } from "./file_operations/requests";
import { StreamingRelayChunk } from "./file_operations/transfer";
import { Timestamp } from "./google/protobuf/timestamp";
import { TunnelClose, TunnelCreate, TunnelData } from "./tunnel";

export const protobufPackage = "terminal";

/** Browser command types */
export enum BrowserCommandType {
  BROWSER_CMD_CREATE_SESSION = 0,
  BROWSER_CMD_CLOSE_SESSION = 1,
  BROWSER_CMD_NAVIGATE = 2,
  BROWSER_CMD_CLICK = 3,
  BROWSER_CMD_TYPE = 4,
  BROWSER_CMD_WAIT = 5,
  BROWSER_CMD_EXTRACT = 6,
  BROWSER_CMD_EXTRACT_REGEX = 7,
  BROWSER_CMD_GET_HTML = 8,
  BROWSER_CMD_GET_TEXT = 9,
  BROWSER_CMD_EXECUTE_SCRIPT = 10,
  BROWSER_CMD_SCREENSHOT = 11,
  BROWSER_CMD_GET_STATE = 12,
  BROWSER_CMD_SET_COOKIES = 13,
  BROWSER_CMD_GET_COOKIES = 14,
  /** BROWSER_CMD_VALIDATE_SELECTORS - Selector validation & data extraction (v2.17.0) */
  BROWSER_CMD_VALIDATE_SELECTORS = 15,
  BROWSER_CMD_EXTRACT_DATA = 16,
  UNRECOGNIZED = -1,
}

export function browserCommandTypeFromJSON(object: any): BrowserCommandType {
  switch (object) {
    case 0:
    case "BROWSER_CMD_CREATE_SESSION":
      return BrowserCommandType.BROWSER_CMD_CREATE_SESSION;
    case 1:
    case "BROWSER_CMD_CLOSE_SESSION":
      return BrowserCommandType.BROWSER_CMD_CLOSE_SESSION;
    case 2:
    case "BROWSER_CMD_NAVIGATE":
      return BrowserCommandType.BROWSER_CMD_NAVIGATE;
    case 3:
    case "BROWSER_CMD_CLICK":
      return BrowserCommandType.BROWSER_CMD_CLICK;
    case 4:
    case "BROWSER_CMD_TYPE":
      return BrowserCommandType.BROWSER_CMD_TYPE;
    case 5:
    case "BROWSER_CMD_WAIT":
      return BrowserCommandType.BROWSER_CMD_WAIT;
    case 6:
    case "BROWSER_CMD_EXTRACT":
      return BrowserCommandType.BROWSER_CMD_EXTRACT;
    case 7:
    case "BROWSER_CMD_EXTRACT_REGEX":
      return BrowserCommandType.BROWSER_CMD_EXTRACT_REGEX;
    case 8:
    case "BROWSER_CMD_GET_HTML":
      return BrowserCommandType.BROWSER_CMD_GET_HTML;
    case 9:
    case "BROWSER_CMD_GET_TEXT":
      return BrowserCommandType.BROWSER_CMD_GET_TEXT;
    case 10:
    case "BROWSER_CMD_EXECUTE_SCRIPT":
      return BrowserCommandType.BROWSER_CMD_EXECUTE_SCRIPT;
    case 11:
    case "BROWSER_CMD_SCREENSHOT":
      return BrowserCommandType.BROWSER_CMD_SCREENSHOT;
    case 12:
    case "BROWSER_CMD_GET_STATE":
      return BrowserCommandType.BROWSER_CMD_GET_STATE;
    case 13:
    case "BROWSER_CMD_SET_COOKIES":
      return BrowserCommandType.BROWSER_CMD_SET_COOKIES;
    case 14:
    case "BROWSER_CMD_GET_COOKIES":
      return BrowserCommandType.BROWSER_CMD_GET_COOKIES;
    case 15:
    case "BROWSER_CMD_VALIDATE_SELECTORS":
      return BrowserCommandType.BROWSER_CMD_VALIDATE_SELECTORS;
    case 16:
    case "BROWSER_CMD_EXTRACT_DATA":
      return BrowserCommandType.BROWSER_CMD_EXTRACT_DATA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BrowserCommandType.UNRECOGNIZED;
  }
}

export function browserCommandTypeToJSON(object: BrowserCommandType): string {
  switch (object) {
    case BrowserCommandType.BROWSER_CMD_CREATE_SESSION:
      return "BROWSER_CMD_CREATE_SESSION";
    case BrowserCommandType.BROWSER_CMD_CLOSE_SESSION:
      return "BROWSER_CMD_CLOSE_SESSION";
    case BrowserCommandType.BROWSER_CMD_NAVIGATE:
      return "BROWSER_CMD_NAVIGATE";
    case BrowserCommandType.BROWSER_CMD_CLICK:
      return "BROWSER_CMD_CLICK";
    case BrowserCommandType.BROWSER_CMD_TYPE:
      return "BROWSER_CMD_TYPE";
    case BrowserCommandType.BROWSER_CMD_WAIT:
      return "BROWSER_CMD_WAIT";
    case BrowserCommandType.BROWSER_CMD_EXTRACT:
      return "BROWSER_CMD_EXTRACT";
    case BrowserCommandType.BROWSER_CMD_EXTRACT_REGEX:
      return "BROWSER_CMD_EXTRACT_REGEX";
    case BrowserCommandType.BROWSER_CMD_GET_HTML:
      return "BROWSER_CMD_GET_HTML";
    case BrowserCommandType.BROWSER_CMD_GET_TEXT:
      return "BROWSER_CMD_GET_TEXT";
    case BrowserCommandType.BROWSER_CMD_EXECUTE_SCRIPT:
      return "BROWSER_CMD_EXECUTE_SCRIPT";
    case BrowserCommandType.BROWSER_CMD_SCREENSHOT:
      return "BROWSER_CMD_SCREENSHOT";
    case BrowserCommandType.BROWSER_CMD_GET_STATE:
      return "BROWSER_CMD_GET_STATE";
    case BrowserCommandType.BROWSER_CMD_SET_COOKIES:
      return "BROWSER_CMD_SET_COOKIES";
    case BrowserCommandType.BROWSER_CMD_GET_COOKIES:
      return "BROWSER_CMD_GET_COOKIES";
    case BrowserCommandType.BROWSER_CMD_VALIDATE_SELECTORS:
      return "BROWSER_CMD_VALIDATE_SELECTORS";
    case BrowserCommandType.BROWSER_CMD_EXTRACT_DATA:
      return "BROWSER_CMD_EXTRACT_DATA";
    case BrowserCommandType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Notification delivery method */
export enum NotificationMethod {
  /** NOTIFICATION_METHOD_AUTO - System decides (visual if available, else audio) */
  NOTIFICATION_METHOD_AUTO = 0,
  /** NOTIFICATION_METHOD_VISUAL - Desktop notification only */
  NOTIFICATION_METHOD_VISUAL = 1,
  /** NOTIFICATION_METHOD_AUDIO - Voice/sound only (TTS) */
  NOTIFICATION_METHOD_AUDIO = 2,
  /** NOTIFICATION_METHOD_BOTH - Visual + audio */
  NOTIFICATION_METHOD_BOTH = 3,
  UNRECOGNIZED = -1,
}

export function notificationMethodFromJSON(object: any): NotificationMethod {
  switch (object) {
    case 0:
    case "NOTIFICATION_METHOD_AUTO":
      return NotificationMethod.NOTIFICATION_METHOD_AUTO;
    case 1:
    case "NOTIFICATION_METHOD_VISUAL":
      return NotificationMethod.NOTIFICATION_METHOD_VISUAL;
    case 2:
    case "NOTIFICATION_METHOD_AUDIO":
      return NotificationMethod.NOTIFICATION_METHOD_AUDIO;
    case 3:
    case "NOTIFICATION_METHOD_BOTH":
      return NotificationMethod.NOTIFICATION_METHOD_BOTH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NotificationMethod.UNRECOGNIZED;
  }
}

export function notificationMethodToJSON(object: NotificationMethod): string {
  switch (object) {
    case NotificationMethod.NOTIFICATION_METHOD_AUTO:
      return "NOTIFICATION_METHOD_AUTO";
    case NotificationMethod.NOTIFICATION_METHOD_VISUAL:
      return "NOTIFICATION_METHOD_VISUAL";
    case NotificationMethod.NOTIFICATION_METHOD_AUDIO:
      return "NOTIFICATION_METHOD_AUDIO";
    case NotificationMethod.NOTIFICATION_METHOD_BOTH:
      return "NOTIFICATION_METHOD_BOTH";
    case NotificationMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Agent type enum */
export enum AgentType {
  /** AGENT_TYPE_CHAT - Simple chat agent (no PTY) */
  AGENT_TYPE_CHAT = 0,
  /** AGENT_TYPE_TERMINAL - Terminal agent with PTY access */
  AGENT_TYPE_TERMINAL = 1,
  /** AGENT_TYPE_COMMAND - Command execution agent */
  AGENT_TYPE_COMMAND = 2,
  /** AGENT_TYPE_ROUTER - Router agent (delegates to specialists) */
  AGENT_TYPE_ROUTER = 3,
  /** AGENT_TYPE_PLANNER - Planner agent (complex tasks) */
  AGENT_TYPE_PLANNER = 4,
  /** AGENT_TYPE_BROWSER - Browser automation agent (v2.13.0) */
  AGENT_TYPE_BROWSER = 5,
  /** AGENT_TYPE_SCRAPER - Web scraping agent (v2.13.0) */
  AGENT_TYPE_SCRAPER = 6,
  /** AGENT_TYPE_FORM_FILLER - Form automation agent (v2.13.0) */
  AGENT_TYPE_FORM_FILLER = 7,
  UNRECOGNIZED = -1,
}

export function agentTypeFromJSON(object: any): AgentType {
  switch (object) {
    case 0:
    case "AGENT_TYPE_CHAT":
      return AgentType.AGENT_TYPE_CHAT;
    case 1:
    case "AGENT_TYPE_TERMINAL":
      return AgentType.AGENT_TYPE_TERMINAL;
    case 2:
    case "AGENT_TYPE_COMMAND":
      return AgentType.AGENT_TYPE_COMMAND;
    case 3:
    case "AGENT_TYPE_ROUTER":
      return AgentType.AGENT_TYPE_ROUTER;
    case 4:
    case "AGENT_TYPE_PLANNER":
      return AgentType.AGENT_TYPE_PLANNER;
    case 5:
    case "AGENT_TYPE_BROWSER":
      return AgentType.AGENT_TYPE_BROWSER;
    case 6:
    case "AGENT_TYPE_SCRAPER":
      return AgentType.AGENT_TYPE_SCRAPER;
    case 7:
    case "AGENT_TYPE_FORM_FILLER":
      return AgentType.AGENT_TYPE_FORM_FILLER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AgentType.UNRECOGNIZED;
  }
}

export function agentTypeToJSON(object: AgentType): string {
  switch (object) {
    case AgentType.AGENT_TYPE_CHAT:
      return "AGENT_TYPE_CHAT";
    case AgentType.AGENT_TYPE_TERMINAL:
      return "AGENT_TYPE_TERMINAL";
    case AgentType.AGENT_TYPE_COMMAND:
      return "AGENT_TYPE_COMMAND";
    case AgentType.AGENT_TYPE_ROUTER:
      return "AGENT_TYPE_ROUTER";
    case AgentType.AGENT_TYPE_PLANNER:
      return "AGENT_TYPE_PLANNER";
    case AgentType.AGENT_TYPE_BROWSER:
      return "AGENT_TYPE_BROWSER";
    case AgentType.AGENT_TYPE_SCRAPER:
      return "AGENT_TYPE_SCRAPER";
    case AgentType.AGENT_TYPE_FORM_FILLER:
      return "AGENT_TYPE_FORM_FILLER";
    case AgentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message from Django to Agent (control commands) */
export interface ControlMessage {
  /** Unique command ID */
  commandId: string;
  timestamp: Date | undefined;
  payload?:
    | //
    /** Terminal input */
    { $case: "input"; input: TerminalInput }
    | //
    /** Terminal resize */
    { $case: "resize"; resize: ResizeCommand }
    | //
    /** Session control */
    { $case: "startSession"; startSession: StartSessionCommand }
    | //
    /** Close terminal session */
    { $case: "closeSession"; closeSession: CloseSessionCommand }
    | //
    /** Process control */
    { $case: "signal"; signal: SignalCommand }
    | //
    /** Cancel running command */
    { $case: "cancel"; cancel: CancelCommand }
    | //
    /** Connection management */
    { $case: "ping"; ping: PingCommand }
    | //
    /** Update session config */
    { $case: "configUpdate"; configUpdate: ConfigUpdateCommand }
    | //
    /** History request (agent reads shell history file) */
    { $case: "getHistory"; getHistory: GetHistoryCommand }
    | //
    /** File operations (routed through streaming) */
    { $case: "fileOperation"; fileOperation: FileOperationRequest }
    | //
    /** Push notifications (desktop notifications to user) */
    { $case: "pushNotification"; pushNotification: PushNotification }
    | //
    /** Streaming relay (file transfer chunks) */
    { $case: "streamingRelayChunk"; streamingRelayChunk: StreamingRelayChunk }
    | //
    /** Tunnel (HTTP/TCP tunnel to local service) */
    { $case: "tunnelCreate"; tunnelCreate: TunnelCreate }
    | //
    /** Tunnel data packet (request) */
    { $case: "tunnelData"; tunnelData: TunnelData }
    | //
    /** Close tunnel */
    { $case: "tunnelClose"; tunnelClose: TunnelClose }
    | //
    /** Permission management (v2.3.0) */
    { $case: "refreshPermissions"; refreshPermissions: RefreshPermissionsCommand }
    | //
    /** AI Agent execution (v2.12.0) */
    { $case: "agentRun"; agentRun: AgentRunCommand }
    | //
    /** Cancel running agent (v2.15.0) */
    { $case: "agentCancel"; agentCancel: AgentCancelCommand }
    | //
    /**
     * Browser Direct Control (v2.16.0)
     * SDK → Django → Agent browser automation without LLM
     */
    { $case: "browser"; browser: BrowserCommand }
    | undefined;
}

/**
 * Browser command wrapper
 * Contains command type and JSON-encoded payload
 */
export interface BrowserCommand {
  /** Unique request ID for correlation */
  requestId: string;
  /** Command type */
  type: BrowserCommandType;
  /** JSON-encoded request (BrowserNavigateRequest, etc.) */
  payloadJson: string;
}

/** Push notification to show on agent's desktop */
export interface PushNotification {
  /** Notification ID */
  id: string;
  /** Type: info, success, warning, error, session, system, custom */
  type: string;
  /** Notification title */
  title: string;
  /** Notification message */
  message: string;
  /** Additional data */
  data: { [key: string]: string };
  /** Priority: 0=normal, 1=high, 2=urgent */
  priority: number;
  /** If true, process without showing notification */
  silent: boolean;
  /** Delivery method (visual, audio, both) */
  method: NotificationMethod;
}

export interface PushNotification_DataEntry {
  key: string;
  value: string;
}

/** Terminal input from browser (keyboard, paste) */
export interface TerminalInput {
  /** Raw input bytes */
  data: Buffer;
  /** Sequence number */
  sequence: string;
}

/** Terminal resize */
export interface ResizeCommand {
  /** New terminal size */
  size: TerminalSize | undefined;
}

/** Start terminal session (after registration) */
export interface StartSessionCommand {
  /** Session configuration */
  config:
    | SessionConfig
    | undefined;
  /** Browser terminal URL (e.g., https://cmdop.com/terminal?s=abc123) */
  webTerminalUrl: string;
  /** Optional: URL expiration time */
  expiresAt: Date | undefined;
}

/** Close terminal session */
export interface CloseSessionCommand {
  /** Reason for closing */
  reason: string;
  /** Force close (kill processes) */
  force: boolean;
}

/** Send signal to PTY process */
export interface SignalCommand {
  /** Signal number (2=SIGINT, 15=SIGTERM, 9=SIGKILL) */
  signal: number;
}

/** Cancel running command */
export interface CancelCommand {
  /** Command to cancel (if tracking) */
  commandId: string;
}

/** Ping for latency measurement */
export interface PingCommand {
  /** Ping sequence number */
  sequence: string;
}

/** Configuration update */
export interface ConfigUpdateCommand {
  /** New configuration */
  config: SessionConfig | undefined;
}

/** Get history command (request shell history from agent) */
export interface GetHistoryCommand {
  /** Max commands to return */
  limit: number;
  /** Offset for pagination */
  offset: number;
  /** History source: "shell" (file), "session" (memory) */
  source: string;
}

/**
 * Refresh permissions command (v2.3.0)
 * Triggers agent to re-check all protected directories
 * On macOS, this will show TCC dialogs for any denied directories
 */
export interface RefreshPermissionsCommand {
}

/**
 * Run AI agent command
 * Sent from Django to Agent to execute AI prompt
 */
export interface AgentRunCommand {
  /** Unique request ID for correlation */
  requestId: string;
  /** User prompt/question */
  prompt: string;
  /** Type of agent to run */
  agentType: AgentType;
  /** Additional options (model, max_turns, etc.) */
  options: { [key: string]: string };
  /** If true, stream events back (tokens, tool calls) */
  streamEvents: boolean;
  /**
   * Optional: JSON Schema for structured output
   * If provided, agent returns output_json matching this schema
   */
  outputSchema: string;
  /** Browser agent options (v2.13.0) */
  browserOptions: BrowserAgentOptions | undefined;
}

export interface AgentRunCommand_OptionsEntry {
  key: string;
  value: string;
}

/** Browser agent configuration options (v2.13.0) */
export interface BrowserAgentOptions {
  /** Session configuration */
  sessionType: string;
  /** Browser profile ID for persistent sessions */
  profileId: string;
  /** Initial URL to navigate to */
  startUrl: string;
  /** Perception settings */
  useAxtree: boolean;
  /** Use differential perception (default: true) */
  useDiff: boolean;
  /** Max tokens for state (default: 8000) */
  maxTokens: number;
  /** Stealth settings */
  stealthLevel: string;
  /** Enable proxy rotation */
  useProxy: boolean;
  /** Specific proxy URL */
  proxyUrl: string;
  /** Session limits */
  maxActions: number;
  /** Navigation timeout (default: 30000) */
  navigationTimeoutMs: number;
  /** Action timeout (default: 10000) */
  actionTimeoutMs: number;
  /** Screenshot settings */
  screenshotOnAction: boolean;
  /** Full page screenshots */
  screenshotFullpage: boolean;
  /** png, jpeg (default: png) */
  screenshotFormat: string;
}

/**
 * Cancel running AI agent
 * Sent from Django to Agent to stop ongoing agent execution
 */
export interface AgentCancelCommand {
  /** Request ID to cancel (from AgentRunCommand) */
  requestId: string;
  /** Cancellation reason: "user", "timeout", "error" */
  reason: string;
}

function createBaseControlMessage(): ControlMessage {
  return { commandId: "", timestamp: undefined, payload: undefined };
}

export const ControlMessage: MessageFns<ControlMessage> = {
  encode(message: ControlMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commandId !== "") {
      writer.uint32(10).string(message.commandId);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).join();
    }
    switch (message.payload?.$case) {
      case "input":
        TerminalInput.encode(message.payload.input, writer.uint32(82).fork()).join();
        break;
      case "resize":
        ResizeCommand.encode(message.payload.resize, writer.uint32(90).fork()).join();
        break;
      case "startSession":
        StartSessionCommand.encode(message.payload.startSession, writer.uint32(162).fork()).join();
        break;
      case "closeSession":
        CloseSessionCommand.encode(message.payload.closeSession, writer.uint32(170).fork()).join();
        break;
      case "signal":
        SignalCommand.encode(message.payload.signal, writer.uint32(242).fork()).join();
        break;
      case "cancel":
        CancelCommand.encode(message.payload.cancel, writer.uint32(250).fork()).join();
        break;
      case "ping":
        PingCommand.encode(message.payload.ping, writer.uint32(322).fork()).join();
        break;
      case "configUpdate":
        ConfigUpdateCommand.encode(message.payload.configUpdate, writer.uint32(330).fork()).join();
        break;
      case "getHistory":
        GetHistoryCommand.encode(message.payload.getHistory, writer.uint32(402).fork()).join();
        break;
      case "fileOperation":
        FileOperationRequest.encode(message.payload.fileOperation, writer.uint32(482).fork()).join();
        break;
      case "pushNotification":
        PushNotification.encode(message.payload.pushNotification, writer.uint32(562).fork()).join();
        break;
      case "streamingRelayChunk":
        StreamingRelayChunk.encode(message.payload.streamingRelayChunk, writer.uint32(642).fork()).join();
        break;
      case "tunnelCreate":
        TunnelCreate.encode(message.payload.tunnelCreate, writer.uint32(722).fork()).join();
        break;
      case "tunnelData":
        TunnelData.encode(message.payload.tunnelData, writer.uint32(730).fork()).join();
        break;
      case "tunnelClose":
        TunnelClose.encode(message.payload.tunnelClose, writer.uint32(738).fork()).join();
        break;
      case "refreshPermissions":
        RefreshPermissionsCommand.encode(message.payload.refreshPermissions, writer.uint32(802).fork()).join();
        break;
      case "agentRun":
        AgentRunCommand.encode(message.payload.agentRun, writer.uint32(882).fork()).join();
        break;
      case "agentCancel":
        AgentCancelCommand.encode(message.payload.agentCancel, writer.uint32(890).fork()).join();
        break;
      case "browser":
        BrowserCommand.encode(message.payload.browser, writer.uint32(962).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ControlMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseControlMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.payload = { $case: "input", input: TerminalInput.decode(reader, reader.uint32()) };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.payload = { $case: "resize", resize: ResizeCommand.decode(reader, reader.uint32()) };
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.payload = {
            $case: "startSession",
            startSession: StartSessionCommand.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.payload = {
            $case: "closeSession",
            closeSession: CloseSessionCommand.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.payload = { $case: "signal", signal: SignalCommand.decode(reader, reader.uint32()) };
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.payload = { $case: "cancel", cancel: CancelCommand.decode(reader, reader.uint32()) };
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.payload = { $case: "ping", ping: PingCommand.decode(reader, reader.uint32()) };
          continue;
        }
        case 41: {
          if (tag !== 330) {
            break;
          }

          message.payload = {
            $case: "configUpdate",
            configUpdate: ConfigUpdateCommand.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.payload = { $case: "getHistory", getHistory: GetHistoryCommand.decode(reader, reader.uint32()) };
          continue;
        }
        case 60: {
          if (tag !== 482) {
            break;
          }

          message.payload = {
            $case: "fileOperation",
            fileOperation: FileOperationRequest.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 70: {
          if (tag !== 562) {
            break;
          }

          message.payload = {
            $case: "pushNotification",
            pushNotification: PushNotification.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 80: {
          if (tag !== 642) {
            break;
          }

          message.payload = {
            $case: "streamingRelayChunk",
            streamingRelayChunk: StreamingRelayChunk.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 90: {
          if (tag !== 722) {
            break;
          }

          message.payload = { $case: "tunnelCreate", tunnelCreate: TunnelCreate.decode(reader, reader.uint32()) };
          continue;
        }
        case 91: {
          if (tag !== 730) {
            break;
          }

          message.payload = { $case: "tunnelData", tunnelData: TunnelData.decode(reader, reader.uint32()) };
          continue;
        }
        case 92: {
          if (tag !== 738) {
            break;
          }

          message.payload = { $case: "tunnelClose", tunnelClose: TunnelClose.decode(reader, reader.uint32()) };
          continue;
        }
        case 100: {
          if (tag !== 802) {
            break;
          }

          message.payload = {
            $case: "refreshPermissions",
            refreshPermissions: RefreshPermissionsCommand.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 110: {
          if (tag !== 882) {
            break;
          }

          message.payload = { $case: "agentRun", agentRun: AgentRunCommand.decode(reader, reader.uint32()) };
          continue;
        }
        case 111: {
          if (tag !== 890) {
            break;
          }

          message.payload = { $case: "agentCancel", agentCancel: AgentCancelCommand.decode(reader, reader.uint32()) };
          continue;
        }
        case 120: {
          if (tag !== 962) {
            break;
          }

          message.payload = { $case: "browser", browser: BrowserCommand.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ControlMessage {
    return {
      commandId: isSet(object.commandId)
        ? globalThis.String(object.commandId)
        : isSet(object.command_id)
        ? globalThis.String(object.command_id)
        : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      payload: isSet(object.input)
        ? { $case: "input", input: TerminalInput.fromJSON(object.input) }
        : isSet(object.resize)
        ? { $case: "resize", resize: ResizeCommand.fromJSON(object.resize) }
        : isSet(object.startSession)
        ? { $case: "startSession", startSession: StartSessionCommand.fromJSON(object.startSession) }
        : isSet(object.start_session)
        ? { $case: "startSession", startSession: StartSessionCommand.fromJSON(object.start_session) }
        : isSet(object.closeSession)
        ? { $case: "closeSession", closeSession: CloseSessionCommand.fromJSON(object.closeSession) }
        : isSet(object.close_session)
        ? { $case: "closeSession", closeSession: CloseSessionCommand.fromJSON(object.close_session) }
        : isSet(object.signal)
        ? { $case: "signal", signal: SignalCommand.fromJSON(object.signal) }
        : isSet(object.cancel)
        ? { $case: "cancel", cancel: CancelCommand.fromJSON(object.cancel) }
        : isSet(object.ping)
        ? { $case: "ping", ping: PingCommand.fromJSON(object.ping) }
        : isSet(object.configUpdate)
        ? { $case: "configUpdate", configUpdate: ConfigUpdateCommand.fromJSON(object.configUpdate) }
        : isSet(object.config_update)
        ? { $case: "configUpdate", configUpdate: ConfigUpdateCommand.fromJSON(object.config_update) }
        : isSet(object.getHistory)
        ? { $case: "getHistory", getHistory: GetHistoryCommand.fromJSON(object.getHistory) }
        : isSet(object.get_history)
        ? { $case: "getHistory", getHistory: GetHistoryCommand.fromJSON(object.get_history) }
        : isSet(object.fileOperation)
        ? { $case: "fileOperation", fileOperation: FileOperationRequest.fromJSON(object.fileOperation) }
        : isSet(object.file_operation)
        ? { $case: "fileOperation", fileOperation: FileOperationRequest.fromJSON(object.file_operation) }
        : isSet(object.pushNotification)
        ? { $case: "pushNotification", pushNotification: PushNotification.fromJSON(object.pushNotification) }
        : isSet(object.push_notification)
        ? { $case: "pushNotification", pushNotification: PushNotification.fromJSON(object.push_notification) }
        : isSet(object.streamingRelayChunk)
        ? {
          $case: "streamingRelayChunk",
          streamingRelayChunk: StreamingRelayChunk.fromJSON(object.streamingRelayChunk),
        }
        : isSet(object.streaming_relay_chunk)
        ? {
          $case: "streamingRelayChunk",
          streamingRelayChunk: StreamingRelayChunk.fromJSON(object.streaming_relay_chunk),
        }
        : isSet(object.tunnelCreate)
        ? { $case: "tunnelCreate", tunnelCreate: TunnelCreate.fromJSON(object.tunnelCreate) }
        : isSet(object.tunnel_create)
        ? { $case: "tunnelCreate", tunnelCreate: TunnelCreate.fromJSON(object.tunnel_create) }
        : isSet(object.tunnelData)
        ? { $case: "tunnelData", tunnelData: TunnelData.fromJSON(object.tunnelData) }
        : isSet(object.tunnel_data)
        ? { $case: "tunnelData", tunnelData: TunnelData.fromJSON(object.tunnel_data) }
        : isSet(object.tunnelClose)
        ? { $case: "tunnelClose", tunnelClose: TunnelClose.fromJSON(object.tunnelClose) }
        : isSet(object.tunnel_close)
        ? { $case: "tunnelClose", tunnelClose: TunnelClose.fromJSON(object.tunnel_close) }
        : isSet(object.refreshPermissions)
        ? {
          $case: "refreshPermissions",
          refreshPermissions: RefreshPermissionsCommand.fromJSON(object.refreshPermissions),
        }
        : isSet(object.refresh_permissions)
        ? {
          $case: "refreshPermissions",
          refreshPermissions: RefreshPermissionsCommand.fromJSON(object.refresh_permissions),
        }
        : isSet(object.agentRun)
        ? { $case: "agentRun", agentRun: AgentRunCommand.fromJSON(object.agentRun) }
        : isSet(object.agent_run)
        ? { $case: "agentRun", agentRun: AgentRunCommand.fromJSON(object.agent_run) }
        : isSet(object.agentCancel)
        ? { $case: "agentCancel", agentCancel: AgentCancelCommand.fromJSON(object.agentCancel) }
        : isSet(object.agent_cancel)
        ? { $case: "agentCancel", agentCancel: AgentCancelCommand.fromJSON(object.agent_cancel) }
        : isSet(object.browser)
        ? { $case: "browser", browser: BrowserCommand.fromJSON(object.browser) }
        : undefined,
    };
  },

  toJSON(message: ControlMessage): unknown {
    const obj: any = {};
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.payload?.$case === "input") {
      obj.input = TerminalInput.toJSON(message.payload.input);
    } else if (message.payload?.$case === "resize") {
      obj.resize = ResizeCommand.toJSON(message.payload.resize);
    } else if (message.payload?.$case === "startSession") {
      obj.startSession = StartSessionCommand.toJSON(message.payload.startSession);
    } else if (message.payload?.$case === "closeSession") {
      obj.closeSession = CloseSessionCommand.toJSON(message.payload.closeSession);
    } else if (message.payload?.$case === "signal") {
      obj.signal = SignalCommand.toJSON(message.payload.signal);
    } else if (message.payload?.$case === "cancel") {
      obj.cancel = CancelCommand.toJSON(message.payload.cancel);
    } else if (message.payload?.$case === "ping") {
      obj.ping = PingCommand.toJSON(message.payload.ping);
    } else if (message.payload?.$case === "configUpdate") {
      obj.configUpdate = ConfigUpdateCommand.toJSON(message.payload.configUpdate);
    } else if (message.payload?.$case === "getHistory") {
      obj.getHistory = GetHistoryCommand.toJSON(message.payload.getHistory);
    } else if (message.payload?.$case === "fileOperation") {
      obj.fileOperation = FileOperationRequest.toJSON(message.payload.fileOperation);
    } else if (message.payload?.$case === "pushNotification") {
      obj.pushNotification = PushNotification.toJSON(message.payload.pushNotification);
    } else if (message.payload?.$case === "streamingRelayChunk") {
      obj.streamingRelayChunk = StreamingRelayChunk.toJSON(message.payload.streamingRelayChunk);
    } else if (message.payload?.$case === "tunnelCreate") {
      obj.tunnelCreate = TunnelCreate.toJSON(message.payload.tunnelCreate);
    } else if (message.payload?.$case === "tunnelData") {
      obj.tunnelData = TunnelData.toJSON(message.payload.tunnelData);
    } else if (message.payload?.$case === "tunnelClose") {
      obj.tunnelClose = TunnelClose.toJSON(message.payload.tunnelClose);
    } else if (message.payload?.$case === "refreshPermissions") {
      obj.refreshPermissions = RefreshPermissionsCommand.toJSON(message.payload.refreshPermissions);
    } else if (message.payload?.$case === "agentRun") {
      obj.agentRun = AgentRunCommand.toJSON(message.payload.agentRun);
    } else if (message.payload?.$case === "agentCancel") {
      obj.agentCancel = AgentCancelCommand.toJSON(message.payload.agentCancel);
    } else if (message.payload?.$case === "browser") {
      obj.browser = BrowserCommand.toJSON(message.payload.browser);
    }
    return obj;
  },

  create(base?: DeepPartial<ControlMessage>): ControlMessage {
    return ControlMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ControlMessage>): ControlMessage {
    const message = createBaseControlMessage();
    message.commandId = object.commandId ?? "";
    message.timestamp = object.timestamp ?? undefined;
    switch (object.payload?.$case) {
      case "input": {
        if (object.payload?.input !== undefined && object.payload?.input !== null) {
          message.payload = { $case: "input", input: TerminalInput.fromPartial(object.payload.input) };
        }
        break;
      }
      case "resize": {
        if (object.payload?.resize !== undefined && object.payload?.resize !== null) {
          message.payload = { $case: "resize", resize: ResizeCommand.fromPartial(object.payload.resize) };
        }
        break;
      }
      case "startSession": {
        if (object.payload?.startSession !== undefined && object.payload?.startSession !== null) {
          message.payload = {
            $case: "startSession",
            startSession: StartSessionCommand.fromPartial(object.payload.startSession),
          };
        }
        break;
      }
      case "closeSession": {
        if (object.payload?.closeSession !== undefined && object.payload?.closeSession !== null) {
          message.payload = {
            $case: "closeSession",
            closeSession: CloseSessionCommand.fromPartial(object.payload.closeSession),
          };
        }
        break;
      }
      case "signal": {
        if (object.payload?.signal !== undefined && object.payload?.signal !== null) {
          message.payload = { $case: "signal", signal: SignalCommand.fromPartial(object.payload.signal) };
        }
        break;
      }
      case "cancel": {
        if (object.payload?.cancel !== undefined && object.payload?.cancel !== null) {
          message.payload = { $case: "cancel", cancel: CancelCommand.fromPartial(object.payload.cancel) };
        }
        break;
      }
      case "ping": {
        if (object.payload?.ping !== undefined && object.payload?.ping !== null) {
          message.payload = { $case: "ping", ping: PingCommand.fromPartial(object.payload.ping) };
        }
        break;
      }
      case "configUpdate": {
        if (object.payload?.configUpdate !== undefined && object.payload?.configUpdate !== null) {
          message.payload = {
            $case: "configUpdate",
            configUpdate: ConfigUpdateCommand.fromPartial(object.payload.configUpdate),
          };
        }
        break;
      }
      case "getHistory": {
        if (object.payload?.getHistory !== undefined && object.payload?.getHistory !== null) {
          message.payload = {
            $case: "getHistory",
            getHistory: GetHistoryCommand.fromPartial(object.payload.getHistory),
          };
        }
        break;
      }
      case "fileOperation": {
        if (object.payload?.fileOperation !== undefined && object.payload?.fileOperation !== null) {
          message.payload = {
            $case: "fileOperation",
            fileOperation: FileOperationRequest.fromPartial(object.payload.fileOperation),
          };
        }
        break;
      }
      case "pushNotification": {
        if (object.payload?.pushNotification !== undefined && object.payload?.pushNotification !== null) {
          message.payload = {
            $case: "pushNotification",
            pushNotification: PushNotification.fromPartial(object.payload.pushNotification),
          };
        }
        break;
      }
      case "streamingRelayChunk": {
        if (object.payload?.streamingRelayChunk !== undefined && object.payload?.streamingRelayChunk !== null) {
          message.payload = {
            $case: "streamingRelayChunk",
            streamingRelayChunk: StreamingRelayChunk.fromPartial(object.payload.streamingRelayChunk),
          };
        }
        break;
      }
      case "tunnelCreate": {
        if (object.payload?.tunnelCreate !== undefined && object.payload?.tunnelCreate !== null) {
          message.payload = {
            $case: "tunnelCreate",
            tunnelCreate: TunnelCreate.fromPartial(object.payload.tunnelCreate),
          };
        }
        break;
      }
      case "tunnelData": {
        if (object.payload?.tunnelData !== undefined && object.payload?.tunnelData !== null) {
          message.payload = { $case: "tunnelData", tunnelData: TunnelData.fromPartial(object.payload.tunnelData) };
        }
        break;
      }
      case "tunnelClose": {
        if (object.payload?.tunnelClose !== undefined && object.payload?.tunnelClose !== null) {
          message.payload = { $case: "tunnelClose", tunnelClose: TunnelClose.fromPartial(object.payload.tunnelClose) };
        }
        break;
      }
      case "refreshPermissions": {
        if (object.payload?.refreshPermissions !== undefined && object.payload?.refreshPermissions !== null) {
          message.payload = {
            $case: "refreshPermissions",
            refreshPermissions: RefreshPermissionsCommand.fromPartial(object.payload.refreshPermissions),
          };
        }
        break;
      }
      case "agentRun": {
        if (object.payload?.agentRun !== undefined && object.payload?.agentRun !== null) {
          message.payload = { $case: "agentRun", agentRun: AgentRunCommand.fromPartial(object.payload.agentRun) };
        }
        break;
      }
      case "agentCancel": {
        if (object.payload?.agentCancel !== undefined && object.payload?.agentCancel !== null) {
          message.payload = {
            $case: "agentCancel",
            agentCancel: AgentCancelCommand.fromPartial(object.payload.agentCancel),
          };
        }
        break;
      }
      case "browser": {
        if (object.payload?.browser !== undefined && object.payload?.browser !== null) {
          message.payload = { $case: "browser", browser: BrowserCommand.fromPartial(object.payload.browser) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseBrowserCommand(): BrowserCommand {
  return { requestId: "", type: 0, payloadJson: "" };
}

export const BrowserCommand: MessageFns<BrowserCommand> = {
  encode(message: BrowserCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.payloadJson !== "") {
      writer.uint32(26).string(message.payloadJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrowserCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrowserCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.payloadJson = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrowserCommand {
    return {
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : "",
      type: isSet(object.type) ? browserCommandTypeFromJSON(object.type) : 0,
      payloadJson: isSet(object.payloadJson)
        ? globalThis.String(object.payloadJson)
        : isSet(object.payload_json)
        ? globalThis.String(object.payload_json)
        : "",
    };
  },

  toJSON(message: BrowserCommand): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.type !== 0) {
      obj.type = browserCommandTypeToJSON(message.type);
    }
    if (message.payloadJson !== "") {
      obj.payloadJson = message.payloadJson;
    }
    return obj;
  },

  create(base?: DeepPartial<BrowserCommand>): BrowserCommand {
    return BrowserCommand.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BrowserCommand>): BrowserCommand {
    const message = createBaseBrowserCommand();
    message.requestId = object.requestId ?? "";
    message.type = object.type ?? 0;
    message.payloadJson = object.payloadJson ?? "";
    return message;
  },
};

function createBasePushNotification(): PushNotification {
  return { id: "", type: "", title: "", message: "", data: {}, priority: 0, silent: false, method: 0 };
}

export const PushNotification: MessageFns<PushNotification> = {
  encode(message: PushNotification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.message !== "") {
      writer.uint32(34).string(message.message);
    }
    globalThis.Object.entries(message.data).forEach(([key, value]: [string, string]) => {
      PushNotification_DataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.priority !== 0) {
      writer.uint32(48).int32(message.priority);
    }
    if (message.silent !== false) {
      writer.uint32(56).bool(message.silent);
    }
    if (message.method !== 0) {
      writer.uint32(64).int32(message.method);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PushNotification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePushNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = PushNotification_DataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.data[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.silent = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.method = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PushNotification {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isObject(object.data)
        ? (globalThis.Object.entries(object.data) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      silent: isSet(object.silent) ? globalThis.Boolean(object.silent) : false,
      method: isSet(object.method) ? notificationMethodFromJSON(object.method) : 0,
    };
  },

  toJSON(message: PushNotification): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data) {
      const entries = globalThis.Object.entries(message.data) as [string, string][];
      if (entries.length > 0) {
        obj.data = {};
        entries.forEach(([k, v]) => {
          obj.data[k] = v;
        });
      }
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.silent !== false) {
      obj.silent = message.silent;
    }
    if (message.method !== 0) {
      obj.method = notificationMethodToJSON(message.method);
    }
    return obj;
  },

  create(base?: DeepPartial<PushNotification>): PushNotification {
    return PushNotification.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PushNotification>): PushNotification {
    const message = createBasePushNotification();
    message.id = object.id ?? "";
    message.type = object.type ?? "";
    message.title = object.title ?? "";
    message.message = object.message ?? "";
    message.data = (globalThis.Object.entries(object.data ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.priority = object.priority ?? 0;
    message.silent = object.silent ?? false;
    message.method = object.method ?? 0;
    return message;
  },
};

function createBasePushNotification_DataEntry(): PushNotification_DataEntry {
  return { key: "", value: "" };
}

export const PushNotification_DataEntry: MessageFns<PushNotification_DataEntry> = {
  encode(message: PushNotification_DataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PushNotification_DataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePushNotification_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PushNotification_DataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PushNotification_DataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<PushNotification_DataEntry>): PushNotification_DataEntry {
    return PushNotification_DataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PushNotification_DataEntry>): PushNotification_DataEntry {
    const message = createBasePushNotification_DataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTerminalInput(): TerminalInput {
  return { data: Buffer.alloc(0), sequence: "0" };
}

export const TerminalInput: MessageFns<TerminalInput> = {
  encode(message: TerminalInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.sequence !== "0") {
      writer.uint32(16).int64(message.sequence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TerminalInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTerminalInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sequence = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TerminalInput {
    return {
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      sequence: isSet(object.sequence) ? globalThis.String(object.sequence) : "0",
    };
  },

  toJSON(message: TerminalInput): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.sequence !== "0") {
      obj.sequence = message.sequence;
    }
    return obj;
  },

  create(base?: DeepPartial<TerminalInput>): TerminalInput {
    return TerminalInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TerminalInput>): TerminalInput {
    const message = createBaseTerminalInput();
    message.data = object.data ?? Buffer.alloc(0);
    message.sequence = object.sequence ?? "0";
    return message;
  },
};

function createBaseResizeCommand(): ResizeCommand {
  return { size: undefined };
}

export const ResizeCommand: MessageFns<ResizeCommand> = {
  encode(message: ResizeCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.size !== undefined) {
      TerminalSize.encode(message.size, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResizeCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResizeCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.size = TerminalSize.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResizeCommand {
    return { size: isSet(object.size) ? TerminalSize.fromJSON(object.size) : undefined };
  },

  toJSON(message: ResizeCommand): unknown {
    const obj: any = {};
    if (message.size !== undefined) {
      obj.size = TerminalSize.toJSON(message.size);
    }
    return obj;
  },

  create(base?: DeepPartial<ResizeCommand>): ResizeCommand {
    return ResizeCommand.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResizeCommand>): ResizeCommand {
    const message = createBaseResizeCommand();
    message.size = (object.size !== undefined && object.size !== null)
      ? TerminalSize.fromPartial(object.size)
      : undefined;
    return message;
  },
};

function createBaseStartSessionCommand(): StartSessionCommand {
  return { config: undefined, webTerminalUrl: "", expiresAt: undefined };
}

export const StartSessionCommand: MessageFns<StartSessionCommand> = {
  encode(message: StartSessionCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      SessionConfig.encode(message.config, writer.uint32(10).fork()).join();
    }
    if (message.webTerminalUrl !== "") {
      writer.uint32(18).string(message.webTerminalUrl);
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartSessionCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartSessionCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config = SessionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.webTerminalUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartSessionCommand {
    return {
      config: isSet(object.config) ? SessionConfig.fromJSON(object.config) : undefined,
      webTerminalUrl: isSet(object.webTerminalUrl)
        ? globalThis.String(object.webTerminalUrl)
        : isSet(object.web_terminal_url)
        ? globalThis.String(object.web_terminal_url)
        : "",
      expiresAt: isSet(object.expiresAt)
        ? fromJsonTimestamp(object.expiresAt)
        : isSet(object.expires_at)
        ? fromJsonTimestamp(object.expires_at)
        : undefined,
    };
  },

  toJSON(message: StartSessionCommand): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = SessionConfig.toJSON(message.config);
    }
    if (message.webTerminalUrl !== "") {
      obj.webTerminalUrl = message.webTerminalUrl;
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<StartSessionCommand>): StartSessionCommand {
    return StartSessionCommand.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartSessionCommand>): StartSessionCommand {
    const message = createBaseStartSessionCommand();
    message.config = (object.config !== undefined && object.config !== null)
      ? SessionConfig.fromPartial(object.config)
      : undefined;
    message.webTerminalUrl = object.webTerminalUrl ?? "";
    message.expiresAt = object.expiresAt ?? undefined;
    return message;
  },
};

function createBaseCloseSessionCommand(): CloseSessionCommand {
  return { reason: "", force: false };
}

export const CloseSessionCommand: MessageFns<CloseSessionCommand> = {
  encode(message: CloseSessionCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    if (message.force !== false) {
      writer.uint32(16).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloseSessionCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloseSessionCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.force = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloseSessionCommand {
    return {
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: CloseSessionCommand): unknown {
    const obj: any = {};
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<CloseSessionCommand>): CloseSessionCommand {
    return CloseSessionCommand.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloseSessionCommand>): CloseSessionCommand {
    const message = createBaseCloseSessionCommand();
    message.reason = object.reason ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseSignalCommand(): SignalCommand {
  return { signal: 0 };
}

export const SignalCommand: MessageFns<SignalCommand> = {
  encode(message: SignalCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signal !== 0) {
      writer.uint32(8).int32(message.signal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignalCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignalCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.signal = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignalCommand {
    return { signal: isSet(object.signal) ? globalThis.Number(object.signal) : 0 };
  },

  toJSON(message: SignalCommand): unknown {
    const obj: any = {};
    if (message.signal !== 0) {
      obj.signal = Math.round(message.signal);
    }
    return obj;
  },

  create(base?: DeepPartial<SignalCommand>): SignalCommand {
    return SignalCommand.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignalCommand>): SignalCommand {
    const message = createBaseSignalCommand();
    message.signal = object.signal ?? 0;
    return message;
  },
};

function createBaseCancelCommand(): CancelCommand {
  return { commandId: "" };
}

export const CancelCommand: MessageFns<CancelCommand> = {
  encode(message: CancelCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commandId !== "") {
      writer.uint32(10).string(message.commandId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelCommand {
    return {
      commandId: isSet(object.commandId)
        ? globalThis.String(object.commandId)
        : isSet(object.command_id)
        ? globalThis.String(object.command_id)
        : "",
    };
  },

  toJSON(message: CancelCommand): unknown {
    const obj: any = {};
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelCommand>): CancelCommand {
    return CancelCommand.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelCommand>): CancelCommand {
    const message = createBaseCancelCommand();
    message.commandId = object.commandId ?? "";
    return message;
  },
};

function createBasePingCommand(): PingCommand {
  return { sequence: "0" };
}

export const PingCommand: MessageFns<PingCommand> = {
  encode(message: PingCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sequence !== "0") {
      writer.uint32(8).int64(message.sequence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PingCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sequence = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PingCommand {
    return { sequence: isSet(object.sequence) ? globalThis.String(object.sequence) : "0" };
  },

  toJSON(message: PingCommand): unknown {
    const obj: any = {};
    if (message.sequence !== "0") {
      obj.sequence = message.sequence;
    }
    return obj;
  },

  create(base?: DeepPartial<PingCommand>): PingCommand {
    return PingCommand.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PingCommand>): PingCommand {
    const message = createBasePingCommand();
    message.sequence = object.sequence ?? "0";
    return message;
  },
};

function createBaseConfigUpdateCommand(): ConfigUpdateCommand {
  return { config: undefined };
}

export const ConfigUpdateCommand: MessageFns<ConfigUpdateCommand> = {
  encode(message: ConfigUpdateCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      SessionConfig.encode(message.config, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigUpdateCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigUpdateCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config = SessionConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigUpdateCommand {
    return { config: isSet(object.config) ? SessionConfig.fromJSON(object.config) : undefined };
  },

  toJSON(message: ConfigUpdateCommand): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = SessionConfig.toJSON(message.config);
    }
    return obj;
  },

  create(base?: DeepPartial<ConfigUpdateCommand>): ConfigUpdateCommand {
    return ConfigUpdateCommand.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConfigUpdateCommand>): ConfigUpdateCommand {
    const message = createBaseConfigUpdateCommand();
    message.config = (object.config !== undefined && object.config !== null)
      ? SessionConfig.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseGetHistoryCommand(): GetHistoryCommand {
  return { limit: 0, offset: 0, source: "" };
}

export const GetHistoryCommand: MessageFns<GetHistoryCommand> = {
  encode(message: GetHistoryCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.limit !== 0) {
      writer.uint32(8).int32(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(16).int32(message.offset);
    }
    if (message.source !== "") {
      writer.uint32(26).string(message.source);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHistoryCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHistoryCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.source = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHistoryCommand {
    return {
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      source: isSet(object.source) ? globalThis.String(object.source) : "",
    };
  },

  toJSON(message: GetHistoryCommand): unknown {
    const obj: any = {};
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    return obj;
  },

  create(base?: DeepPartial<GetHistoryCommand>): GetHistoryCommand {
    return GetHistoryCommand.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetHistoryCommand>): GetHistoryCommand {
    const message = createBaseGetHistoryCommand();
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.source = object.source ?? "";
    return message;
  },
};

function createBaseRefreshPermissionsCommand(): RefreshPermissionsCommand {
  return {};
}

export const RefreshPermissionsCommand: MessageFns<RefreshPermissionsCommand> = {
  encode(_: RefreshPermissionsCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshPermissionsCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshPermissionsCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RefreshPermissionsCommand {
    return {};
  },

  toJSON(_: RefreshPermissionsCommand): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RefreshPermissionsCommand>): RefreshPermissionsCommand {
    return RefreshPermissionsCommand.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RefreshPermissionsCommand>): RefreshPermissionsCommand {
    const message = createBaseRefreshPermissionsCommand();
    return message;
  },
};

function createBaseAgentRunCommand(): AgentRunCommand {
  return {
    requestId: "",
    prompt: "",
    agentType: 0,
    options: {},
    streamEvents: false,
    outputSchema: "",
    browserOptions: undefined,
  };
}

export const AgentRunCommand: MessageFns<AgentRunCommand> = {
  encode(message: AgentRunCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.prompt !== "") {
      writer.uint32(18).string(message.prompt);
    }
    if (message.agentType !== 0) {
      writer.uint32(24).int32(message.agentType);
    }
    globalThis.Object.entries(message.options).forEach(([key, value]: [string, string]) => {
      AgentRunCommand_OptionsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.streamEvents !== false) {
      writer.uint32(40).bool(message.streamEvents);
    }
    if (message.outputSchema !== "") {
      writer.uint32(50).string(message.outputSchema);
    }
    if (message.browserOptions !== undefined) {
      BrowserAgentOptions.encode(message.browserOptions, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentRunCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentRunCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.agentType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = AgentRunCommand_OptionsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.options[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.streamEvents = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.outputSchema = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.browserOptions = BrowserAgentOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentRunCommand {
    return {
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : "",
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
      agentType: isSet(object.agentType)
        ? agentTypeFromJSON(object.agentType)
        : isSet(object.agent_type)
        ? agentTypeFromJSON(object.agent_type)
        : 0,
      options: isObject(object.options)
        ? (globalThis.Object.entries(object.options) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      streamEvents: isSet(object.streamEvents)
        ? globalThis.Boolean(object.streamEvents)
        : isSet(object.stream_events)
        ? globalThis.Boolean(object.stream_events)
        : false,
      outputSchema: isSet(object.outputSchema)
        ? globalThis.String(object.outputSchema)
        : isSet(object.output_schema)
        ? globalThis.String(object.output_schema)
        : "",
      browserOptions: isSet(object.browserOptions)
        ? BrowserAgentOptions.fromJSON(object.browserOptions)
        : isSet(object.browser_options)
        ? BrowserAgentOptions.fromJSON(object.browser_options)
        : undefined,
    };
  },

  toJSON(message: AgentRunCommand): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    if (message.agentType !== 0) {
      obj.agentType = agentTypeToJSON(message.agentType);
    }
    if (message.options) {
      const entries = globalThis.Object.entries(message.options) as [string, string][];
      if (entries.length > 0) {
        obj.options = {};
        entries.forEach(([k, v]) => {
          obj.options[k] = v;
        });
      }
    }
    if (message.streamEvents !== false) {
      obj.streamEvents = message.streamEvents;
    }
    if (message.outputSchema !== "") {
      obj.outputSchema = message.outputSchema;
    }
    if (message.browserOptions !== undefined) {
      obj.browserOptions = BrowserAgentOptions.toJSON(message.browserOptions);
    }
    return obj;
  },

  create(base?: DeepPartial<AgentRunCommand>): AgentRunCommand {
    return AgentRunCommand.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgentRunCommand>): AgentRunCommand {
    const message = createBaseAgentRunCommand();
    message.requestId = object.requestId ?? "";
    message.prompt = object.prompt ?? "";
    message.agentType = object.agentType ?? 0;
    message.options = (globalThis.Object.entries(object.options ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.streamEvents = object.streamEvents ?? false;
    message.outputSchema = object.outputSchema ?? "";
    message.browserOptions = (object.browserOptions !== undefined && object.browserOptions !== null)
      ? BrowserAgentOptions.fromPartial(object.browserOptions)
      : undefined;
    return message;
  },
};

function createBaseAgentRunCommand_OptionsEntry(): AgentRunCommand_OptionsEntry {
  return { key: "", value: "" };
}

export const AgentRunCommand_OptionsEntry: MessageFns<AgentRunCommand_OptionsEntry> = {
  encode(message: AgentRunCommand_OptionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentRunCommand_OptionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentRunCommand_OptionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentRunCommand_OptionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AgentRunCommand_OptionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AgentRunCommand_OptionsEntry>): AgentRunCommand_OptionsEntry {
    return AgentRunCommand_OptionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgentRunCommand_OptionsEntry>): AgentRunCommand_OptionsEntry {
    const message = createBaseAgentRunCommand_OptionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBrowserAgentOptions(): BrowserAgentOptions {
  return {
    sessionType: "",
    profileId: "",
    startUrl: "",
    useAxtree: false,
    useDiff: false,
    maxTokens: 0,
    stealthLevel: "",
    useProxy: false,
    proxyUrl: "",
    maxActions: 0,
    navigationTimeoutMs: 0,
    actionTimeoutMs: 0,
    screenshotOnAction: false,
    screenshotFullpage: false,
    screenshotFormat: "",
  };
}

export const BrowserAgentOptions: MessageFns<BrowserAgentOptions> = {
  encode(message: BrowserAgentOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionType !== "") {
      writer.uint32(10).string(message.sessionType);
    }
    if (message.profileId !== "") {
      writer.uint32(18).string(message.profileId);
    }
    if (message.startUrl !== "") {
      writer.uint32(26).string(message.startUrl);
    }
    if (message.useAxtree !== false) {
      writer.uint32(32).bool(message.useAxtree);
    }
    if (message.useDiff !== false) {
      writer.uint32(40).bool(message.useDiff);
    }
    if (message.maxTokens !== 0) {
      writer.uint32(48).int32(message.maxTokens);
    }
    if (message.stealthLevel !== "") {
      writer.uint32(58).string(message.stealthLevel);
    }
    if (message.useProxy !== false) {
      writer.uint32(64).bool(message.useProxy);
    }
    if (message.proxyUrl !== "") {
      writer.uint32(74).string(message.proxyUrl);
    }
    if (message.maxActions !== 0) {
      writer.uint32(80).int32(message.maxActions);
    }
    if (message.navigationTimeoutMs !== 0) {
      writer.uint32(88).int32(message.navigationTimeoutMs);
    }
    if (message.actionTimeoutMs !== 0) {
      writer.uint32(96).int32(message.actionTimeoutMs);
    }
    if (message.screenshotOnAction !== false) {
      writer.uint32(104).bool(message.screenshotOnAction);
    }
    if (message.screenshotFullpage !== false) {
      writer.uint32(112).bool(message.screenshotFullpage);
    }
    if (message.screenshotFormat !== "") {
      writer.uint32(122).string(message.screenshotFormat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrowserAgentOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrowserAgentOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.startUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.useAxtree = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.useDiff = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.maxTokens = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.stealthLevel = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.useProxy = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.proxyUrl = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.maxActions = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.navigationTimeoutMs = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.actionTimeoutMs = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.screenshotOnAction = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.screenshotFullpage = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.screenshotFormat = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrowserAgentOptions {
    return {
      sessionType: isSet(object.sessionType)
        ? globalThis.String(object.sessionType)
        : isSet(object.session_type)
        ? globalThis.String(object.session_type)
        : "",
      profileId: isSet(object.profileId)
        ? globalThis.String(object.profileId)
        : isSet(object.profile_id)
        ? globalThis.String(object.profile_id)
        : "",
      startUrl: isSet(object.startUrl)
        ? globalThis.String(object.startUrl)
        : isSet(object.start_url)
        ? globalThis.String(object.start_url)
        : "",
      useAxtree: isSet(object.useAxtree)
        ? globalThis.Boolean(object.useAxtree)
        : isSet(object.use_axtree)
        ? globalThis.Boolean(object.use_axtree)
        : false,
      useDiff: isSet(object.useDiff)
        ? globalThis.Boolean(object.useDiff)
        : isSet(object.use_diff)
        ? globalThis.Boolean(object.use_diff)
        : false,
      maxTokens: isSet(object.maxTokens)
        ? globalThis.Number(object.maxTokens)
        : isSet(object.max_tokens)
        ? globalThis.Number(object.max_tokens)
        : 0,
      stealthLevel: isSet(object.stealthLevel)
        ? globalThis.String(object.stealthLevel)
        : isSet(object.stealth_level)
        ? globalThis.String(object.stealth_level)
        : "",
      useProxy: isSet(object.useProxy)
        ? globalThis.Boolean(object.useProxy)
        : isSet(object.use_proxy)
        ? globalThis.Boolean(object.use_proxy)
        : false,
      proxyUrl: isSet(object.proxyUrl)
        ? globalThis.String(object.proxyUrl)
        : isSet(object.proxy_url)
        ? globalThis.String(object.proxy_url)
        : "",
      maxActions: isSet(object.maxActions)
        ? globalThis.Number(object.maxActions)
        : isSet(object.max_actions)
        ? globalThis.Number(object.max_actions)
        : 0,
      navigationTimeoutMs: isSet(object.navigationTimeoutMs)
        ? globalThis.Number(object.navigationTimeoutMs)
        : isSet(object.navigation_timeout_ms)
        ? globalThis.Number(object.navigation_timeout_ms)
        : 0,
      actionTimeoutMs: isSet(object.actionTimeoutMs)
        ? globalThis.Number(object.actionTimeoutMs)
        : isSet(object.action_timeout_ms)
        ? globalThis.Number(object.action_timeout_ms)
        : 0,
      screenshotOnAction: isSet(object.screenshotOnAction)
        ? globalThis.Boolean(object.screenshotOnAction)
        : isSet(object.screenshot_on_action)
        ? globalThis.Boolean(object.screenshot_on_action)
        : false,
      screenshotFullpage: isSet(object.screenshotFullpage)
        ? globalThis.Boolean(object.screenshotFullpage)
        : isSet(object.screenshot_fullpage)
        ? globalThis.Boolean(object.screenshot_fullpage)
        : false,
      screenshotFormat: isSet(object.screenshotFormat)
        ? globalThis.String(object.screenshotFormat)
        : isSet(object.screenshot_format)
        ? globalThis.String(object.screenshot_format)
        : "",
    };
  },

  toJSON(message: BrowserAgentOptions): unknown {
    const obj: any = {};
    if (message.sessionType !== "") {
      obj.sessionType = message.sessionType;
    }
    if (message.profileId !== "") {
      obj.profileId = message.profileId;
    }
    if (message.startUrl !== "") {
      obj.startUrl = message.startUrl;
    }
    if (message.useAxtree !== false) {
      obj.useAxtree = message.useAxtree;
    }
    if (message.useDiff !== false) {
      obj.useDiff = message.useDiff;
    }
    if (message.maxTokens !== 0) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.stealthLevel !== "") {
      obj.stealthLevel = message.stealthLevel;
    }
    if (message.useProxy !== false) {
      obj.useProxy = message.useProxy;
    }
    if (message.proxyUrl !== "") {
      obj.proxyUrl = message.proxyUrl;
    }
    if (message.maxActions !== 0) {
      obj.maxActions = Math.round(message.maxActions);
    }
    if (message.navigationTimeoutMs !== 0) {
      obj.navigationTimeoutMs = Math.round(message.navigationTimeoutMs);
    }
    if (message.actionTimeoutMs !== 0) {
      obj.actionTimeoutMs = Math.round(message.actionTimeoutMs);
    }
    if (message.screenshotOnAction !== false) {
      obj.screenshotOnAction = message.screenshotOnAction;
    }
    if (message.screenshotFullpage !== false) {
      obj.screenshotFullpage = message.screenshotFullpage;
    }
    if (message.screenshotFormat !== "") {
      obj.screenshotFormat = message.screenshotFormat;
    }
    return obj;
  },

  create(base?: DeepPartial<BrowserAgentOptions>): BrowserAgentOptions {
    return BrowserAgentOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BrowserAgentOptions>): BrowserAgentOptions {
    const message = createBaseBrowserAgentOptions();
    message.sessionType = object.sessionType ?? "";
    message.profileId = object.profileId ?? "";
    message.startUrl = object.startUrl ?? "";
    message.useAxtree = object.useAxtree ?? false;
    message.useDiff = object.useDiff ?? false;
    message.maxTokens = object.maxTokens ?? 0;
    message.stealthLevel = object.stealthLevel ?? "";
    message.useProxy = object.useProxy ?? false;
    message.proxyUrl = object.proxyUrl ?? "";
    message.maxActions = object.maxActions ?? 0;
    message.navigationTimeoutMs = object.navigationTimeoutMs ?? 0;
    message.actionTimeoutMs = object.actionTimeoutMs ?? 0;
    message.screenshotOnAction = object.screenshotOnAction ?? false;
    message.screenshotFullpage = object.screenshotFullpage ?? false;
    message.screenshotFormat = object.screenshotFormat ?? "";
    return message;
  },
};

function createBaseAgentCancelCommand(): AgentCancelCommand {
  return { requestId: "", reason: "" };
}

export const AgentCancelCommand: MessageFns<AgentCancelCommand> = {
  encode(message: AgentCancelCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentCancelCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentCancelCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentCancelCommand {
    return {
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: AgentCancelCommand): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<AgentCancelCommand>): AgentCancelCommand {
    return AgentCancelCommand.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgentCancelCommand>): AgentCancelCommand {
    const message = createBaseAgentCancelCommand();
    message.requestId = object.requestId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
